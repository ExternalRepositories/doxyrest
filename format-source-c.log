----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\CmdLine.cpp
----------------------
[-] CmdLineParser::onSwitch (
[+] CmdLineParser::onSwitch(
[-] 	switch (switchKind)
[+] 	switch(switchKind)
[-] 		m_cmdLine->m_frameDirList.insertTail (value);
[+] 		m_cmdLine->m_frameDirList.insertTail(value);
[-] 		Define* define = AXL_MEM_NEW (Define);
[+] 		Define* define = AXL_MEM_NEW(Define);
[-] 		size_t i = value.find ('=');
[+] 		size_t i = value.find('=');
[-] 			define->m_name = value.getSubString (0, i);
[+] 			define->m_name = value.getSubString(0, i);
[-] 			define->m_value = value.getSubString (i + 1);
[+] 			define->m_value = value.getSubString(i + 1);
[-] 		m_cmdLine->m_defineList.insertTail (define);
[+] 		m_cmdLine->m_defineList.insertTail(define);
[-] CmdLineParser::finalize ()
[+] CmdLineParser::finalize()
[-] 	if (m_cmdLine->m_inputFileName.isEmpty ())
[+] 	if (m_cmdLine->m_inputFileName.isEmpty())
[-] 		if (m_cmdLine->m_outputFileName.isEmpty ())
[+] 		if (m_cmdLine->m_outputFileName.isEmpty())
[-] 			m_cmdLine->m_outputFileName = io::getFileName (m_cmdLine->m_inputFileName) + ".rst";
[+] 			m_cmdLine->m_outputFileName = io::getFileName(m_cmdLine->m_inputFileName) + ".rst";
[-] 		if (m_cmdLine->m_frameFileName.isEmpty ())
[+] 		if (m_cmdLine->m_frameFileName.isEmpty())
[-] 			err::setError ("master frame file name missing\n");
[+] 			err::setError("master frame file name missing\n");
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\DoxyXmlEnum.cpp
----------------------
[-] getBoolKindString (BoolKind boolKind)
[+] getBoolKindString(BoolKind boolKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) boolKind < countof (stringTable) ?
[+] 	return (size_t)boolKind < countof(stringTable) ?
[-] 		stringTable [boolKind] :
[+] 		stringTable[boolKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getLanguageKindString (LanguageKind languageKind)
[+] getLanguageKindString(LanguageKind languageKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) languageKind < countof (stringTable) ?
[+] 	return (size_t)languageKind < countof(stringTable) ?
[-] 		stringTable [languageKind] :
[+] 		stringTable[languageKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getMemberKindString (MemberKind memberKind)
[+] getMemberKindString(MemberKind memberKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) memberKind < countof (stringTable) ?
[+] 	return (size_t)memberKind < countof(stringTable) ?
[-] 		stringTable [memberKind] :
[+] 		stringTable[memberKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getProtectionKindString (ProtectionKind protectionKind)
[+] getProtectionKindString(ProtectionKind protectionKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) protectionKind < countof (stringTable) ?
[+] 	return (size_t)protectionKind < countof(stringTable) ?
[-] 		stringTable [protectionKind] :
[+] 		stringTable[protectionKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getVirtualKindString (VirtualKind virtualKind)
[+] getVirtualKindString(VirtualKind virtualKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) virtualKind < countof (stringTable) ?
[+] 	return (size_t)virtualKind < countof(stringTable) ?
[-] 		stringTable [virtualKind] :
[+] 		stringTable[virtualKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getRefKindString (RefKind refKind)
[+] getRefKindString(RefKind refKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) refKind < countof (stringTable) ?
[+] 	return (size_t)refKind < countof(stringTable) ?
[-] 		stringTable [refKind] :
[+] 		stringTable[refKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getGraphRelationKindString (GraphRelationKind graphRelationKind)
[+] getGraphRelationKindString(GraphRelationKind graphRelationKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) graphRelationKind < countof (stringTable) ?
[+] 	return (size_t)graphRelationKind < countof(stringTable) ?
[-] 		stringTable [graphRelationKind] :
[+] 		stringTable[graphRelationKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getCompoundKindString (CompoundKind compoundKind)
[+] getCompoundKindString(CompoundKind compoundKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) compoundKind < countof (stringTable) ?
[+] 	return (size_t)compoundKind < countof(stringTable) ?
[-] 		stringTable [compoundKind] :
[+] 		stringTable[compoundKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getSectionKindString (SectionKind sectionKind)
[+] getSectionKindString(SectionKind sectionKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) sectionKind < countof (stringTable) ?
[+] 	return (size_t)sectionKind < countof(stringTable) ?
[-] 		stringTable [sectionKind] :
[+] 		stringTable[sectionKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getImageKindString (ImageKind imageKind)
[+] getImageKindString(ImageKind imageKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) imageKind < countof (stringTable) ?
[+] 	return (size_t)imageKind < countof(stringTable) ?
[-] 		stringTable [imageKind] :
[+] 		stringTable[imageKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getParamListKindString (ParamListKind paramListKind)
[+] getParamListKindString(ParamListKind paramListKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) paramListKind < countof (stringTable) ?
[+] 	return (size_t)paramListKind < countof(stringTable) ?
[-] 		stringTable [paramListKind] :
[+] 		stringTable[paramListKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getParamDirKindString (ParamDirKind paramDirKind)
[+] getParamDirKindString(ParamDirKind paramDirKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) paramDirKind < countof (stringTable) ?
[+] 	return (size_t)paramDirKind < countof(stringTable) ?
[-] 		stringTable [paramDirKind] :
[+] 		stringTable[paramDirKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
[-] getAccessorKindString (AccessorKind accessorKind)
[+] getAccessorKindString(AccessorKind accessorKind)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	return (size_t) accessorKind < countof (stringTable) ?
[+] 	return (size_t)accessorKind < countof(stringTable) ?
[-] 		stringTable [accessorKind] :
[+] 		stringTable[accessorKind] :
[-] 		stringTable [0];
[+] 		stringTable[0];
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\DoxyXmlParser.cpp
----------------------
[-] DoxyXmlParser::DoxyXmlParser ()
[+] DoxyXmlParser::DoxyXmlParser()
[-] DoxyXmlParser::parseFile (
[+] DoxyXmlParser::parseFile(
[-] 	m_filePath = io::getFullFilePath (fileName);
[+] 	m_filePath = io::getFullFilePath(fileName);
[-] 	m_baseDir = io::getDir (m_filePath);
[+] 	m_baseDir = io::getDir(m_filePath);
[-] 	return xml::ExpatParser <DoxyXmlParser>::parseFile (fileName);
[+] 	return xml::ExpatParser<DoxyXmlParser>::parseFile(fileName);
[-] DoxyXmlParser::clear ()
[+] DoxyXmlParser::clear()
[-] 	size_t count = m_typeStack.getCount ();
[+] 	size_t count = m_typeStack.getCount();
[-] 		DoxyXmlType* type = m_typeStack [i].m_type;
[+] 		DoxyXmlType* type = m_typeStack[i].m_type;
[-] 		AXL_MEM_DELETE (type);
[+] 		AXL_MEM_DELETE(type);
[-] 	m_typeStack.clear ();
[+] 	m_typeStack.clear();
[-] DoxyXmlParser::popType ()
[+] DoxyXmlParser::popType()
[-] 	ASSERT (!m_typeStack.isEmpty ());
[+] 	ASSERT(!m_typeStack.isEmpty());
[-] 	DoxyXmlType* type = m_typeStack.getBack ().m_type;
[+] 	DoxyXmlType* type = m_typeStack.getBack().m_type;
[-] 	type->onPopType ();
[+] 	type->onPopType();
[-] 	AXL_MEM_DELETE (type);
[+] 	AXL_MEM_DELETE(type);
[-] 	m_typeStack.pop ();
[+] 	m_typeStack.pop();
[-] DoxyXmlParser::onStartElement (
[+] DoxyXmlParser::onStartElement(
[-] 	printElement (name, attributes);
[+] 	printElement(name, attributes);
[-] 	if (!m_typeStack.isEmpty ())
[+] 	if (!m_typeStack.isEmpty())
[-] 		TypeStackEntry* entry = &m_typeStack.getBack ();
[+] 		TypeStackEntry* entry = &m_typeStack.getBack();
[-] 			entry->m_type->onStartElement (name, attributes);
[+] 			entry->m_type->onStartElement(name, attributes);
[-] 			if (entry == &m_typeStack.getBack ()) // no new types were added
[+] 			if (entry == &m_typeStack.getBack()) // no new types were added
[-] 		ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 		ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 		switch (elemKind)
[+] 		switch(elemKind)
[-] 			pushType <DoxygenIndexType> (name, attributes);
[+] 			pushType<DoxygenIndexType> (name, attributes);
[-] 			pushType <DoxygenCompoundType> (name, attributes);
[+] 			pushType<DoxygenCompoundType> (name, attributes);
[-] DoxyXmlParser::onEndElement (const char* name)
[+] DoxyXmlParser::onEndElement(const char* name)
[-] 	printIndent ();
[+] 	printIndent();
[-] 	printf ("</%s>\n", name);
[+] 	printf("</%s>\n", name);
[-] 	if (!m_typeStack.isEmpty ())
[+] 	if (!m_typeStack.isEmpty())
[-] 		TypeStackEntry* entry = &m_typeStack.getBack ();
[+] 		TypeStackEntry* entry = &m_typeStack.getBack();
[-] 			entry->m_type->onEndElement (name);
[+] 			entry->m_type->onEndElement(name);
[-] 			popType ();
[+] 			popType();
[-] DoxyXmlParser::onCharacterData (
[+] DoxyXmlParser::onCharacterData(
[-] 	printIndent ();
[+] 	printIndent();
[-] 	printf ("%s\n", sl::String (string, length).sz ());
[+] 	printf("%s\n", sl::String (string, length).sz ());
[-] 	if (!m_typeStack.isEmpty ())
[+] 	if (!m_typeStack.isEmpty())
[-] 		TypeStackEntry* entry = &m_typeStack.getBack ();
[+] 		TypeStackEntry* entry = &m_typeStack.getBack();
[-] 			entry->m_type->onCharacterData (string, length);
[+] 			entry->m_type->onCharacterData(string, length);
[-] DoxyXmlParser::printIndent ()
[+] DoxyXmlParser::printIndent()
[-] 		printf ("  ");
[+] 		printf("  ");
[-] DoxyXmlParser::printElement (
[+] DoxyXmlParser::printElement(
[-] 	printIndent ();
[+] 	printIndent();
[-] 	printf ("<%s", name);
[+] 	printf("<%s", name);
[-] 		printf ("\n");
[+] 		printf("\n");
[-] 			printIndent ();
[+] 			printIndent();
[-] 			printf ("%s = %s\n", attributes [0], attributes [1]);
[+] 			printf("%s = %s\n", attributes [0], attributes [1]);
[-] 		printIndent ();
[+] 		printIndent();
[-] 	printf (">\n");
[+] 	printf(">\n");
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\DoxyXmlType.cpp
----------------------
[-] DoxygenIndexType::create (
[+] DoxygenIndexType::create(
[-] 	Module* module = m_parser->getModule ();
[+] 	Module* module = m_parser->getModule();
[-] 		IndexAttrKind attrKind = IndexAttrKindMap::findValue (attributes [0], IndexAttrKind_Undefined);
[+] 		IndexAttrKind attrKind = IndexAttrKindMap::findValue(attributes[0], IndexAttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			module->m_version = attributes [1];
[+] 			module->m_version = attributes[1];
[-] DoxygenIndexType::onStartElement (
[+] DoxygenIndexType::onStartElement(
[-] 	IndexElemKind elemKind = IndexElemKindMap::findValue (name, IndexElemKind_Undefined);
[+] 	IndexElemKind elemKind = IndexElemKindMap::findValue(name, IndexElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		onCompound (name, attributes);
[+] 		onCompound(name, attributes);
[-] DoxygenIndexType::onCompound (
[+] DoxygenIndexType::onCompound(
[-] 		CompoundAttrKind attrKind = CompoundAttrKindMap::findValue (attributes [0], CompoundAttrKind_Undefined);
[+] 		CompoundAttrKind attrKind = CompoundAttrKindMap::findValue(attributes[0], CompoundAttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			refId = attributes [1];
[+] 			refId = attributes[1];
[-] 			compoundKind = CompoundKindMap::findValue (attributes [1], CompoundKind_Undefined);
[+] 			compoundKind = CompoundKindMap::findValue(attributes[1], CompoundKind_Undefined);
[-] 	if (refId.isEmpty ())
[+] 	if (refId.isEmpty())
[-] 	return parseCompound (refId);
[+] 	return parseCompound(refId);
[-] DoxygenIndexType::parseCompound (const char* refId)
[+] DoxygenIndexType::parseCompound(const char* refId)
[-] 	sl::String filePath = m_parser->getBaseDir () + "/" + refId + ".xml";
[+] 	sl::String filePath = m_parser->getBaseDir() + "/" + refId + ".xml";
[-] 	return parser.parseFile (
[+] 	return parser.parseFile(
[-] 		m_parser->getModule (),
[+] 		m_parser->getModule(),
[-] DoxygenCompoundType::create (
[+] DoxygenCompoundType::create(
[-] 	Module* module = m_parser->getModule ();
[+] 	Module* module = m_parser->getModule();
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			if (module->m_version.isEmpty ())
[+] 			if (module->m_version.isEmpty())
[-] 				module->m_version = attributes [1];
[+] 				module->m_version = attributes[1];
[-] 			else if (module->m_version != attributes [1])
[+] 			else if (module->m_version != attributes[1])
[-] DoxygenCompoundType::onStartElement (
[+] DoxygenCompoundType::onStartElement(
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		return m_parser->pushType <CompoundDefType> (name, attributes);
[+] 		return m_parser->pushType<CompoundDefType> (name, attributes);
[-] CompoundDefType::create (
[+] CompoundDefType::create(
[-] 	Module* module = parser->getModule ();
[+] 	Module* module = parser->getModule();
[-] 	m_compound = AXL_MEM_NEW (Compound);
[+] 	m_compound = AXL_MEM_NEW(Compound);
[-] 	module->m_compoundList.insertTail (m_compound);
[+] 	module->m_compoundList.insertTail(m_compound);
[-] 	parser->pushCompound (m_compound);
[+] 	parser->pushCompound(m_compound);
[-] 	sl::StringHashTableIterator <Compound*> mapIt;
[+] 	sl::StringHashTableIterator<Compound*> mapIt;
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			m_compound->m_id = attributes [1];
[+] 			m_compound->m_id = attributes[1];
[-] 			mapIt = module->m_compoundMap.visit (m_compound->m_id);
[+] 			mapIt = module->m_compoundMap.visit(m_compound->m_id);
[-] 				printf (
[+] 				printf(
[-] 					m_compound->m_id.sz (),
[+] 					m_compound->m_id.sz(),
[-] 					getCompoundKindString (prevCompound->m_compoundKind),
[+] 					getCompoundKindString(prevCompound->m_compoundKind),
[-] 					prevCompound->m_name.sz ()
[+] 					prevCompound->m_name.sz()
[-] 				if (prevCompound->m_detailedDescription.isEmpty () && prevCompound->m_briefDescription.isEmpty ())
[+] 				if (prevCompound->m_detailedDescription.isEmpty() && prevCompound->m_briefDescription.isEmpty())
[-] 					printf ("  replacing old compound as it has no documentation\n");
[+] 					printf("  replacing old compound as it has no documentation\n");
[-] 			m_compound->m_compoundKind = CompoundKindMap::findValue (attributes [1], CompoundKind_Undefined);
[+] 			m_compound->m_compoundKind = CompoundKindMap::findValue(attributes[1], CompoundKind_Undefined);
[-] 			m_compound->m_languageKind = LanguageKindMap::findValue (attributes [1], LanguageKind_Undefined);
[+] 			m_compound->m_languageKind = LanguageKindMap::findValue(attributes[1], LanguageKind_Undefined);
[-] 			m_compound->m_protectionKind = ProtectionKindMap::findValue (attributes [1], ProtectionKind_Undefined);
[+] 			m_compound->m_protectionKind = ProtectionKindMap::findValue(attributes[1], ProtectionKind_Undefined);
[-] 			m_compound->m_isFinal = BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes;
[+] 			m_compound->m_isFinal = BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes;
[-] 			m_compound->m_isSealed = BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes;
[+] 			m_compound->m_isSealed = BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes;
[-] 			m_compound->m_isAbstract = BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes;
[+] 			m_compound->m_isAbstract = BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes;
[-] 	switch (m_compound->m_compoundKind)
[+] 	switch(m_compound->m_compoundKind)
[-] 		module->m_groupArray.append (m_compound);
[+] 		module->m_groupArray.append(m_compound);
[-] 		module->m_pageArray.append (m_compound);
[+] 		module->m_pageArray.append(m_compound);
[-] 		module->m_exampleArray.append (m_compound);
[+] 		module->m_exampleArray.append(m_compound);
[-] 		module->m_namespaceArray.append (m_compound);
[+] 		module->m_namespaceArray.append(m_compound);
[-] CompoundDefType::onStartElement (
[+] CompoundDefType::onStartElement(
[-] 	sl::BoxIterator <sl::String> stringIt;
[+] 	sl::BoxIterator<sl::String> stringIt;
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		m_parser->pushType <StringType> (&m_compound->m_name, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_compound->m_name, name, attributes);
[-] 		m_parser->pushType <StringType> (&m_compound->m_title, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_compound->m_title, name, attributes);
[-] 		m_parser->pushType <RefType> (&m_compound->m_baseRefList, name, attributes);
[+] 		m_parser->pushType<RefType> (&m_compound->m_baseRefList, name, attributes);
[-] 		m_parser->pushType <RefType> (&m_compound->m_derivedRefList, name, attributes);
[+] 		m_parser->pushType<RefType> (&m_compound->m_derivedRefList, name, attributes);
[-] 		stringIt = m_compound->m_importList.insertTail ();
[+] 		stringIt = m_compound->m_importList.insertTail();
[-] 		m_parser->pushType <StringType> (stringIt.p (), name, attributes);
[+] 		m_parser->pushType<StringType> (stringIt.p(), name, attributes);
[-] 		m_parser->pushType <RefType> (&m_compound->m_innerRefList, name, attributes);
[+] 		m_parser->pushType<RefType> (&m_compound->m_innerRefList, name, attributes);
[-] 		m_parser->pushType <TemplateParamListType> (&m_compound->m_templateParamList, name, attributes);
[+] 		m_parser->pushType<TemplateParamListType> (&m_compound->m_templateParamList, name, attributes);
[-] 		m_parser->pushType <SectionDefType> (m_compound, name, attributes);
[+] 		m_parser->pushType<SectionDefType> (m_compound, name, attributes);
[-] 		m_parser->pushType <DescriptionType> (&m_compound->m_briefDescription, name, attributes);
[+] 		m_parser->pushType<DescriptionType> (&m_compound->m_briefDescription, name, attributes);
[-] 		m_parser->pushType <DescriptionType> (&m_compound->m_detailedDescription, name, attributes);
[+] 		m_parser->pushType<DescriptionType> (&m_compound->m_detailedDescription, name, attributes);
[-] 		m_parser->pushType <LocationType> (&m_compound->m_location, name, attributes);
[+] 		m_parser->pushType<LocationType> (&m_compound->m_location, name, attributes);
[-] CompoundDefType::onPopType ()
[+] CompoundDefType::onPopType()
[-] 	ASSERT (m_parser);
[+] 	ASSERT(m_parser);
[-] 	Compound* prevCompound = m_parser->popCompound ();
[+] 	Compound* prevCompound = m_parser->popCompound();
[-] 	ASSERT (prevCompound == m_compound);
[+] 	ASSERT(prevCompound == m_compound);
[-] RefType::create (
[+] RefType::create(
[-] 	sl::List <Ref>* list,
[+] 	sl::List<Ref>* list,
[-] 	m_ref = AXL_MEM_NEW (Ref);
[+] 	m_ref = AXL_MEM_NEW(Ref);
[-] 	list->insertTail (m_ref);
[+] 	list->insertTail(m_ref);
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			m_ref->m_id = attributes [1];
[+] 			m_ref->m_id = attributes[1];
[-] 			m_ref->m_importId = attributes [1];
[+] 			m_ref->m_importId = attributes[1];
[-] 			m_ref->m_protectionKind = ProtectionKindMap::findValue (attributes [1], ProtectionKind_Undefined);
[+] 			m_ref->m_protectionKind = ProtectionKindMap::findValue(attributes[1], ProtectionKind_Undefined);
[-] 			m_ref->m_virtualKind = VirtualKindMap::findValue (attributes [1], VirtualKind_Undefined);
[+] 			m_ref->m_virtualKind = VirtualKindMap::findValue(attributes[1], VirtualKind_Undefined);
[-] SectionDefType::create (
[+] SectionDefType::create(
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			sectionKind = SectionKindMap::findValue (attributes [1], SectionKind_Undefined);
[+] 			sectionKind = SectionKindMap::findValue(attributes[1], SectionKind_Undefined);
[-] SectionDefType::onStartElement (
[+] SectionDefType::onStartElement(
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		return m_parser->pushType <MemberDefType> (m_parent, name, attributes);
[+] 		return m_parser->pushType<MemberDefType> (m_parent, name, attributes);
[-] MemberDefType::create (
[+] MemberDefType::create(
[-] 	Module* module = parser->getModule ();
[+] 	Module* module = parser->getModule();
[-] 	m_member = AXL_MEM_NEW (Member);
[+] 	m_member = AXL_MEM_NEW(Member);
[-] 	parent->m_memberList.insertTail (m_member);
[+] 	parent->m_memberList.insertTail(m_member);
[-] 	sl::StringHashTableIterator <Member*> mapIt;
[+] 	sl::StringHashTableIterator<Member*> mapIt;
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			m_member->m_memberKind = MemberKindMap::findValue (attributes [1], MemberKind_Undefined);
[+] 			m_member->m_memberKind = MemberKindMap::findValue(attributes[1], MemberKind_Undefined);
[-] 			m_member->m_id = attributes [1];
[+] 			m_member->m_id = attributes[1];
[-] 			mapIt = module->m_memberMap.visit (m_member->m_id);
[+] 			mapIt = module->m_memberMap.visit(m_member->m_id);
[-] 				printf (
[+] 				printf(
[-] 					m_member->m_id.sz (),
[+] 					m_member->m_id.sz(),
[-] 					getMemberKindString (prevMember->m_memberKind),
[+] 					getMemberKindString(prevMember->m_memberKind),
[-] 					prevMember->m_name.sz ()
[+] 					prevMember->m_name.sz()
[-] 				if (prevMember->m_detailedDescription.isEmpty () && prevMember->m_briefDescription.isEmpty ())
[+] 				if (prevMember->m_detailedDescription.isEmpty() && prevMember->m_briefDescription.isEmpty())
[-] 					printf ("  replacing old member as it has no documentation\n");
[+] 					printf("  replacing old member as it has no documentation\n");
[-] 			m_member->m_protectionKind = ProtectionKindMap::findValue (attributes [1], ProtectionKind_Undefined);
[+] 			m_member->m_protectionKind = ProtectionKindMap::findValue(attributes[1], ProtectionKind_Undefined);
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			m_member->m_virtualKind = VirtualKindMap::findValue (attributes [1], VirtualKind_Undefined);
[+] 			m_member->m_virtualKind = VirtualKindMap::findValue(attributes[1], VirtualKind_Undefined);
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] 			if (BoolKindMap::findValue (attributes [1], BoolKind_Undefined) == BoolKind_Yes)
[+] 			if (BoolKindMap::findValue(attributes[1], BoolKind_Undefined) == BoolKind_Yes)
[-] MemberDefType::onStartElement (
[+] MemberDefType::onStartElement(
[-] 	sl::BoxIterator <sl::String> stringIt;
[+] 	sl::BoxIterator<sl::String> stringIt;
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		stringIt = m_member->m_importList.insertTail ();
[+] 		stringIt = m_member->m_importList.insertTail();
[-] 		m_parser->pushType <StringType> (stringIt.p (), name, attributes);
[+] 		m_parser->pushType<StringType> (stringIt.p(), name, attributes);
[-] 		m_parser->pushType <TemplateParamListType> (&m_member->m_templateParamList, name, attributes);
[+] 		m_parser->pushType<TemplateParamListType> (&m_member->m_templateParamList, name, attributes);
[-] 		m_parser->pushType <LinkedTextType> (&m_member->m_type, name, attributes);
[+] 		m_parser->pushType<LinkedTextType> (&m_member->m_type, name, attributes);
[-] 		m_parser->pushType <StringType> (&m_member->m_definition, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_member->m_definition, name, attributes);
[-] 		m_parser->pushType <StringType> (&m_member->m_argString, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_member->m_argString, name, attributes);
[-] 		m_parser->pushType <StringType> (&m_member->m_name, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_member->m_name, name, attributes);
[-] 		m_parser->pushType <StringType> (&m_member->m_bitField, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_member->m_bitField, name, attributes);
[-] 		m_parser->pushType <LinkedTextType> (&m_member->m_initializer, name, attributes);
[+] 		m_parser->pushType<LinkedTextType> (&m_member->m_initializer, name, attributes);
[-] 		m_parser->pushType <LinkedTextType> (&m_member->m_exceptions, name, attributes);
[+] 		m_parser->pushType<LinkedTextType> (&m_member->m_exceptions, name, attributes);
[-] 		m_parser->pushType <ParamType> (&m_member->m_paramList, name, attributes);
[+] 		m_parser->pushType<ParamType> (&m_member->m_paramList, name, attributes);
[-] 		m_parser->pushType <EnumValueType> (m_member, name, attributes);
[+] 		m_parser->pushType<EnumValueType> (m_member, name, attributes);
[-] 		m_parser->pushType <DescriptionType> (&m_member->m_briefDescription, name, attributes);
[+] 		m_parser->pushType<DescriptionType> (&m_member->m_briefDescription, name, attributes);
[-] 		m_parser->pushType <DescriptionType> (&m_member->m_detailedDescription, name, attributes);
[+] 		m_parser->pushType<DescriptionType> (&m_member->m_detailedDescription, name, attributes);
[-] 		m_parser->pushType <DescriptionType> (&m_member->m_inBodyDescription, name, attributes);
[+] 		m_parser->pushType<DescriptionType> (&m_member->m_inBodyDescription, name, attributes);
[-] 		m_parser->pushType <LocationType> (&m_member->m_location, name, attributes);
[+] 		m_parser->pushType<LocationType> (&m_member->m_location, name, attributes);
[-] 		m_parser->pushType <StringType> (&m_member->m_modifiers, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_member->m_modifiers, name, attributes);
[-] DescriptionType::create (
[+] DescriptionType::create(
[-] DescriptionType::onStartElement (
[+] DescriptionType::onStartElement(
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		m_parser->pushType <StringType> (&m_description->m_title, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_description->m_title, name, attributes);
[-] 		m_parser->pushType <DocParaType> (&m_description->m_docBlockList, name, attributes);
[+] 		m_parser->pushType<DocParaType> (&m_description->m_docBlockList, name, attributes);
[-] 		m_parser->pushType <DocSectionBlockType> (&m_description->m_docBlockList, name, attributes);
[+] 		m_parser->pushType<DocSectionBlockType> (&m_description->m_docBlockList, name, attributes);
[-] LocationType::create (
[+] LocationType::create(
[-] 	sl::StringHashTableIterator <Member*> mapIt;
[+] 	sl::StringHashTableIterator<Member*> mapIt;
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			location->m_file = attributes [1];
[+] 			location->m_file = attributes[1];
[-] 			location->m_line = atoi (attributes [1]);
[+] 			location->m_line = atoi(attributes[1]);
[-] 			location->m_column = atoi (attributes [1]);
[+] 			location->m_column = atoi(attributes[1]);
[-] 			location->m_bodyFile = attributes [1];
[+] 			location->m_bodyFile = attributes[1];
[-] 			location->m_bodyStartLine = atoi (attributes [1]);
[+] 			location->m_bodyStartLine = atoi(attributes[1]);
[-] 			location->m_bodyEndLine = atoi (attributes [1]);
[+] 			location->m_bodyEndLine = atoi(attributes[1]);
[-] DocSectionBlockType::create (
[+] DocSectionBlockType::create(
[-] 	sl::List <DocBlock>* list,
[+] 	sl::List<DocBlock>* list,
[-] 	m_sectionBlock = AXL_MEM_NEW (DocSectionBlock);
[+] 	m_sectionBlock = AXL_MEM_NEW(DocSectionBlock);
[-] 	list->insertTail (m_sectionBlock);
[+] 	list->insertTail(m_sectionBlock);
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			m_sectionBlock->m_id = attributes [1];
[+] 			m_sectionBlock->m_id = attributes[1];
[-] DocSectionBlockType::onStartElement (
[+] DocSectionBlockType::onStartElement(
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		m_parser->pushType <StringType> (&m_sectionBlock->m_title, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_sectionBlock->m_title, name, attributes);
[-] 		m_parser->pushType <DocParaType> (&m_sectionBlock->m_childBlockList, name, attributes);
[+] 		m_parser->pushType<DocParaType> (&m_sectionBlock->m_childBlockList, name, attributes);
[-] 		m_parser->pushType <DocSectionBlockType> (&m_sectionBlock->m_childBlockList, name, attributes);
[+] 		m_parser->pushType<DocSectionBlockType> (&m_sectionBlock->m_childBlockList, name, attributes);
[-] EnumValueType::create (
[+] EnumValueType::create(
[-] 	Module* module = parser->getModule ();
[+] 	Module* module = parser->getModule();
[-] 	m_enumValue = AXL_MEM_NEW (EnumValue);
[+] 	m_enumValue = AXL_MEM_NEW(EnumValue);
[-] 	member->m_enumValueList.insertTail (m_enumValue);
[+] 	member->m_enumValueList.insertTail(m_enumValue);
[-] 	sl::StringHashTableIterator <EnumValue*> mapIt;
[+] 	sl::StringHashTableIterator<EnumValue*> mapIt;
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			m_enumValue->m_id = attributes [1];
[+] 			m_enumValue->m_id = attributes[1];
[-] 			ASSERT (member->m_parentCompound);
[+] 			ASSERT(member->m_parentCompound);
[-] 			mapIt = module->m_enumValueMap.visit (m_enumValue->m_id);
[+] 			mapIt = module->m_enumValueMap.visit(m_enumValue->m_id);
[-] 				printf (
[+] 				printf(
[-] 					m_enumValue->m_id.sz (),
[+] 					m_enumValue->m_id.sz(),
[-] 					prevEnumValue->m_name.sz ()
[+] 					prevEnumValue->m_name.sz()
[-] 				if (prevEnumValue->m_detailedDescription.isEmpty () && prevEnumValue->m_briefDescription.isEmpty ())
[+] 				if (prevEnumValue->m_detailedDescription.isEmpty() && prevEnumValue->m_briefDescription.isEmpty())
[-] 					printf ("  replacing old enum value it has no documentation\n");
[+] 					printf("  replacing old enum value it has no documentation\n");
[-] 			m_enumValue->m_protectionKind = ProtectionKindMap::findValue (attributes [1], ProtectionKind_Undefined);
[+] 			m_enumValue->m_protectionKind = ProtectionKindMap::findValue(attributes[1], ProtectionKind_Undefined);
[-] EnumValueType::onStartElement (
[+] EnumValueType::onStartElement(
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		m_parser->pushType <StringType> (&m_enumValue->m_name, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_enumValue->m_name, name, attributes);
[-] 		m_parser->pushType <LinkedTextType> (&m_enumValue->m_initializer, name, attributes);
[+] 		m_parser->pushType<LinkedTextType> (&m_enumValue->m_initializer, name, attributes);
[-] 		m_parser->pushType <DescriptionType> (&m_enumValue->m_briefDescription, name, attributes);
[+] 		m_parser->pushType<DescriptionType> (&m_enumValue->m_briefDescription, name, attributes);
[-] 		m_parser->pushType <DescriptionType> (&m_enumValue->m_detailedDescription, name, attributes);
[+] 		m_parser->pushType<DescriptionType> (&m_enumValue->m_detailedDescription, name, attributes);
[-] TemplateParamListType::create (
[+] TemplateParamListType::create(
[-] 	sl::List <Param>* list,
[+] 	sl::List<Param>* list,
[-] TemplateParamListType::onStartElement (
[+] TemplateParamListType::onStartElement(
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		m_parser->pushType <ParamType> (m_list, name, attributes);
[+] 		m_parser->pushType<ParamType> (m_list, name, attributes);
[-] ParamType::create (
[+] ParamType::create(
[-] 	sl::List <Param>* list,
[+] 	sl::List<Param>* list,
[-] 	m_param = AXL_MEM_NEW (Param);
[+] 	m_param = AXL_MEM_NEW(Param);
[-] 	list->insertTail (m_param);
[+] 	list->insertTail(m_param);
[-] ParamType::onStartElement (
[+] ParamType::onStartElement(
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		m_parser->pushType <LinkedTextType> (&m_param->m_type, name, attributes);
[+] 		m_parser->pushType<LinkedTextType> (&m_param->m_type, name, attributes);
[-] 		m_parser->pushType <StringType> (&m_param->m_declarationName, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_param->m_declarationName, name, attributes);
[-] 		m_parser->pushType <StringType> (&m_param->m_definitionName, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_param->m_definitionName, name, attributes);
[-] 		m_parser->pushType <StringType> (&m_param->m_array, name, attributes);
[+] 		m_parser->pushType<StringType> (&m_param->m_array, name, attributes);
[-] 		m_parser->pushType <LinkedTextType> (&m_param->m_defaultValue, name, attributes);
[+] 		m_parser->pushType<LinkedTextType> (&m_param->m_defaultValue, name, attributes);
[-] 		m_parser->pushType <LinkedTextType> (&m_param->m_typeConstraint, name, attributes);
[+] 		m_parser->pushType<LinkedTextType> (&m_param->m_typeConstraint, name, attributes);
[-] 		m_parser->pushType <DescriptionType> (&m_param->m_briefDescription, name, attributes);
[+] 		m_parser->pushType<DescriptionType> (&m_param->m_briefDescription, name, attributes);
[-] LinkedTextType::create (
[+] LinkedTextType::create(
[-] 	m_refText = AXL_MEM_NEW (RefText);
[+] 	m_refText = AXL_MEM_NEW(RefText);
[-] 	m_linkedText->m_refTextList.insertTail (m_refText);
[+] 	m_linkedText->m_refTextList.insertTail(m_refText);
[-] LinkedTextType::onStartElement (
[+] LinkedTextType::onStartElement(
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		m_parser->pushType <RefTextType> (m_linkedText, name, attributes);
[+] 		m_parser->pushType<RefTextType> (m_linkedText, name, attributes);
[-] 	m_refText = AXL_MEM_NEW (RefText);
[+] 	m_refText = AXL_MEM_NEW(RefText);
[-] 	m_linkedText->m_refTextList.insertTail (m_refText);
[+] 	m_linkedText->m_refTextList.insertTail(m_refText);
[-] RefTextType::create (
[+] RefTextType::create(
[-] 	m_refText = AXL_MEM_NEW (RefText);
[+] 	m_refText = AXL_MEM_NEW(RefText);
[-] 	linkedText->m_refTextList.insertTail (m_refText);
[+] 	linkedText->m_refTextList.insertTail(m_refText);
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			m_refText->m_id = attributes [1];
[+] 			m_refText->m_id = attributes[1];
[-] 			m_refText->m_refKind = RefKindMap::findValue (attributes [1], RefKind_Undefined);
[+] 			m_refText->m_refKind = RefKindMap::findValue(attributes[1], RefKind_Undefined);
[-] 			m_refText->m_external = attributes [1];
[+] 			m_refText->m_external = attributes[1];
[-] 			m_refText->m_tooltip = attributes [1];
[+] 			m_refText->m_tooltip = attributes[1];
[-] DocParaType::create (
[+] DocParaType::create(
[-] 	sl::List <DocBlock>* blockList,
[+] 	sl::List<DocBlock>* blockList,
[-] 	m_paragraphBlock = AXL_MEM_NEW (DocBlock);
[+] 	m_paragraphBlock = AXL_MEM_NEW(DocBlock);
[-] 	blockList->insertTail (m_paragraphBlock);
[+] 	blockList->insertTail(m_paragraphBlock);
[-] 	m_textBlock = AXL_MEM_NEW (DocBlock);
[+] 	m_textBlock = AXL_MEM_NEW(DocBlock);
[-] 	m_paragraphBlock->m_childBlockList.insertTail (m_textBlock);
[+] 	m_paragraphBlock->m_childBlockList.insertTail(m_textBlock);
[-] DocParaType::onStartElement (
[+] DocParaType::onStartElement(
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		m_parser->pushType <DocRefTextType> (&m_paragraphBlock->m_childBlockList, name, attributes);
[+] 		m_parser->pushType<DocRefTextType> (&m_paragraphBlock->m_childBlockList, name, attributes);
[-] 		m_parser->pushType <DocAnchorType> (&m_paragraphBlock->m_childBlockList, name, attributes);
[+] 		m_parser->pushType<DocAnchorType> (&m_paragraphBlock->m_childBlockList, name, attributes);
[-] 		m_parser->pushType <DocImageType> (&m_paragraphBlock->m_childBlockList, name, attributes);
[+] 		m_parser->pushType<DocImageType> (&m_paragraphBlock->m_childBlockList, name, attributes);
[-] 		m_parser->pushType <DocSimpleSectionType> (&m_paragraphBlock->m_childBlockList, name, attributes);
[+] 		m_parser->pushType<DocSimpleSectionType> (&m_paragraphBlock->m_childBlockList, name, attributes);
[-] 		m_parser->pushType <DocParaType> (&m_paragraphBlock->m_childBlockList, name, attributes);
[+] 		m_parser->pushType<DocParaType> (&m_paragraphBlock->m_childBlockList, name, attributes);
[-] 	m_textBlock = AXL_MEM_NEW (DocBlock);
[+] 	m_textBlock = AXL_MEM_NEW(DocBlock);
[-] 	m_paragraphBlock->m_childBlockList.insertTail (m_textBlock);
[+] 	m_paragraphBlock->m_childBlockList.insertTail(m_textBlock);
[-] DocRefTextType::create (
[+] DocRefTextType::create(
[-] 	sl::List <DocBlock>* list,
[+] 	sl::List<DocBlock>* list,
[-] 	m_refBlock = AXL_MEM_NEW (DocRefBlock);
[+] 	m_refBlock = AXL_MEM_NEW(DocRefBlock);
[-] 	m_refBlock->m_module = m_parser->getModule ();
[+] 	m_refBlock->m_module = m_parser->getModule();
[-] 	list->insertTail (m_refBlock);
[+] 	list->insertTail(m_refBlock);
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			m_refBlock->m_id = attributes [1];
[+] 			m_refBlock->m_id = attributes[1];
[-] 			m_refBlock->m_refKind = RefKindMap::findValue (attributes [1], RefKind_Undefined);
[+] 			m_refBlock->m_refKind = RefKindMap::findValue(attributes[1], RefKind_Undefined);
[-] 			m_refBlock->m_external = attributes [1];
[+] 			m_refBlock->m_external = attributes[1];
[-] DocAnchorType::create (
[+] DocAnchorType::create(
[-] 	sl::List <DocBlock>* list,
[+] 	sl::List<DocBlock>* list,
[-] 	m_anchorBlock = AXL_MEM_NEW (DocAnchorBlock);
[+] 	m_anchorBlock = AXL_MEM_NEW(DocAnchorBlock);
[-] 	list->insertTail (m_anchorBlock);
[+] 	list->insertTail(m_anchorBlock);
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			m_anchorBlock->m_id = attributes [1];
[+] 			m_anchorBlock->m_id = attributes[1];
[-] 	Compound* compound = parser->getCurrentCompound ();
[+] 	Compound* compound = parser->getCurrentCompound();
[-] 	if (m_anchorBlock->m_id.isPrefix ("_")) // doxygen citelist pages seem to omit page ids in acnhors; restore those
[+] 	if (m_anchorBlock->m_id.isPrefix("_")) // doxygen citelist pages seem to omit page ids in acnhors; restore those
[-] 		m_anchorBlock->m_id.insert (0, compound->m_id);
[+] 		m_anchorBlock->m_id.insert(0, compound->m_id);
[-] 	m_anchorBlock->m_id.makeLowerCase (); // there is no configuration setting to force Doxygen to case-fold anchors
[+] 	m_anchorBlock->m_id.makeLowerCase(); // there is no configuration setting to force Doxygen to case-fold anchors
[-] DocImageType::create (
[+] DocImageType::create(
[-] 	sl::List <DocBlock>* list,
[+] 	sl::List<DocBlock>* list,
[-] 	m_imageBlock = AXL_MEM_NEW (DocImageBlock);
[+] 	m_imageBlock = AXL_MEM_NEW(DocImageBlock);
[-] 	list->insertTail (m_imageBlock);
[+] 	list->insertTail(m_imageBlock);
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			m_imageBlock->m_imageKind = ImageKindMap::findValue (attributes [1], ImageKind_Undefined);
[+] 			m_imageBlock->m_imageKind = ImageKindMap::findValue(attributes[1], ImageKind_Undefined);
[-] 			m_imageBlock->m_name = attributes [1];
[+] 			m_imageBlock->m_name = attributes[1];
[-] 			m_imageBlock->m_width = atoi (attributes [1]);
[+] 			m_imageBlock->m_width = atoi(attributes[1]);
[-] 			m_imageBlock->m_height = atoi (attributes [1]);
[+] 			m_imageBlock->m_height = atoi(attributes[1]);
[-] DocSimpleSectionType::create (
[+] DocSimpleSectionType::create(
[-] 	sl::List <DocBlock>* list,
[+] 	sl::List<DocBlock>* list,
[-] 	m_sectionBlock = AXL_MEM_NEW (DocSimpleSectionBlock);
[+] 	m_sectionBlock = AXL_MEM_NEW(DocSimpleSectionBlock);
[-] 	list->insertTail (m_sectionBlock);
[+] 	list->insertTail(m_sectionBlock);
[-] 		AttrKind attrKind = AttrKindMap::findValue (attributes [0], AttrKind_Undefined);
[+] 		AttrKind attrKind = AttrKindMap::findValue(attributes[0], AttrKind_Undefined);
[-] 		switch (attrKind)
[+] 		switch(attrKind)
[-] 			m_sectionBlock->m_simpleSectionKind = attributes [1];
[+] 			m_sectionBlock->m_simpleSectionKind = attributes[1];
[-] DocSimpleSectionType::onStartElement (
[+] DocSimpleSectionType::onStartElement(
[-] 	ElemKind elemKind = ElemKindMap::findValue (name, ElemKind_Undefined);
[+] 	ElemKind elemKind = ElemKindMap::findValue(name, ElemKind_Undefined);
[-] 	switch (elemKind)
[+] 	switch(elemKind)
[-] 		m_parser->pushType <DocParaType> (&m_sectionBlock->m_childBlockList, name, attributes);
[+] 		m_parser->pushType<DocParaType> (&m_sectionBlock->m_childBlockList, name, attributes);
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\Generator.cpp
----------------------
[-] Generator::prepare (
[+] Generator::prepare(
[-] 	m_stringTemplate.create ();
[+] 	m_stringTemplate.create();
[-] 	m_stringTemplate.m_luaState.registerFunction ("includeFile", includeFile_lua, this);
[+] 	m_stringTemplate.m_luaState.registerFunction("includeFile", includeFile_lua, this);
[-] 	m_stringTemplate.m_luaState.registerFunction ("generateFile", generateFile_lua, this);
[+] 	m_stringTemplate.m_luaState.registerFunction("generateFile", generateFile_lua, this);
[-] 	m_stringTemplate.m_luaState.createTable ();
[+] 	m_stringTemplate.m_luaState.createTable();
[-] 	m_stringTemplate.m_luaState.setGlobal ("g_exportCache");
[+] 	m_stringTemplate.m_luaState.setGlobal("g_exportCache");
[-] 	globalNamespace->luaExport (&m_stringTemplate.m_luaState);
[+] 	globalNamespace->luaExport(&m_stringTemplate.m_luaState);
[-] 	m_stringTemplate.m_luaState.setGlobal ("g_globalNamespace");
[+] 	m_stringTemplate.m_luaState.setGlobal("g_globalNamespace");
[-] 	luaExportArray (&m_stringTemplate.m_luaState, module->m_groupArray);
[+] 	luaExportArray(&m_stringTemplate.m_luaState, module->m_groupArray);
[-] 	m_stringTemplate.m_luaState.setGlobal ("g_groupArray");
[+] 	m_stringTemplate.m_luaState.setGlobal("g_groupArray");
[-] 	luaExportArray (&m_stringTemplate.m_luaState, module->m_pageArray);
[+] 	luaExportArray(&m_stringTemplate.m_luaState, module->m_pageArray);
[-] 	m_stringTemplate.m_luaState.setGlobal ("g_pageArray");
[+] 	m_stringTemplate.m_luaState.setGlobal("g_pageArray");
[-] 	luaExportArray (&m_stringTemplate.m_luaState, module->m_exampleArray);
[+] 	luaExportArray(&m_stringTemplate.m_luaState, module->m_exampleArray);
[-] 	m_stringTemplate.m_luaState.setGlobal ("g_exampleArray");
[+] 	m_stringTemplate.m_luaState.setGlobal("g_exampleArray");
[-] 	sl::ConstIterator <Define> it = m_cmdLine->m_defineList.getHead ();
[+] 	sl::ConstIterator<Define> it = m_cmdLine->m_defineList.getHead();
[-] 			m_stringTemplate.m_luaState.setGlobalString (define->m_name, define->m_value);
[+] 			m_stringTemplate.m_luaState.setGlobalString(define->m_name, define->m_value);
[-] 			m_stringTemplate.m_luaState.setGlobalBoolean (define->m_name, true);
[+] 			m_stringTemplate.m_luaState.setGlobalBoolean(define->m_name, true);
[-] 	m_stringTemplate.m_luaState.pushNil ();
[+] 	m_stringTemplate.m_luaState.pushNil();
[-] 	m_stringTemplate.m_luaState.setGlobal ("g_exportCache");
[+] 	m_stringTemplate.m_luaState.setGlobal("g_exportCache");
[-] Generator::generate (
[+] Generator::generate(
[-] 	sl::String frameFilePath = io::findFilePath (frameFileName, &m_cmdLine->m_frameDirList);
[+] 	sl::String frameFilePath = io::findFilePath(frameFileName, &m_cmdLine->m_frameDirList);
[-] 	if (frameFilePath.isEmpty ())
[+] 	if (frameFilePath.isEmpty())
[-] 		err::setFormatStringError ("frame file '%s' not found", frameFileName.sz ());
[+] 		err::setFormatStringError("frame file '%s' not found", frameFileName.sz ());
[-] 	sl::String targetDir = io::getDir (targetFileName);
[+] 	sl::String targetDir = io::getDir(targetFileName);
[-] 	result = io::ensureDirExists (targetDir);
[+] 	result = io::ensureDirExists(targetDir);
[-] 	m_frameDir = io::getDir (frameFilePath);
[+] 	m_frameDir = io::getDir(frameFilePath);
[-] 	m_targetDir = io::getFullFilePath (targetDir);
[+] 	m_targetDir = io::getFullFilePath(targetDir);
[-] 	m_stringTemplate.m_luaState.setGlobalString ("g_frameDir", m_frameDir);
[+] 	m_stringTemplate.m_luaState.setGlobalString("g_frameDir", m_frameDir);
[-] 	m_stringTemplate.m_luaState.setGlobalString ("g_targetDir", m_targetDir);
[+] 	m_stringTemplate.m_luaState.setGlobalString("g_targetDir", m_targetDir);
[-] 	m_stringTemplate.m_luaState.setGlobalString ("g_targetFileName", targetFileName);
[+] 	m_stringTemplate.m_luaState.setGlobalString("g_targetFileName", targetFileName);
[-] 	result = m_stringTemplate.processFile (&stringBuffer, frameFilePath);
[+] 	result = m_stringTemplate.processFile(&stringBuffer, frameFilePath);
[-] 	result = targetFile.open (targetFileName);
[+] 	result = targetFile.open(targetFileName);
[-] 	size_t size = stringBuffer.getLength ();
[+] 	size_t size = stringBuffer.getLength();
[-] 	result = targetFile.write (stringBuffer, size) != -1;
[+] 	result = targetFile.write(stringBuffer, size) != -1;
[-] 	targetFile.setSize (size);
[+] 	targetFile.setSize(size);
[-] Generator::processFile (
[+] Generator::processFile(
[-] 	sl::String frameFilePath = io::findFilePath (frameFileName, m_frameDir, &m_cmdLine->m_frameDirList);
[+] 	sl::String frameFilePath = io::findFilePath(frameFileName, m_frameDir, &m_cmdLine->m_frameDirList);
[-] 	if (frameFilePath.isEmpty ())
[+] 	if (frameFilePath.isEmpty())
[-] 		err::setFormatStringError ("frame '%s' not found", frameFileName.sz ());
[+] 		err::setFormatStringError("frame '%s' not found", frameFileName.sz ());
[-] 	sl::String prevFrameDir = m_stringTemplate.m_luaState.getGlobalString ("g_frameDir");
[+] 	sl::String prevFrameDir = m_stringTemplate.m_luaState.getGlobalString("g_frameDir");
[-] 	m_frameDir = io::getDir (frameFilePath);
[+] 	m_frameDir = io::getDir(frameFilePath);
[-] 	m_stringTemplate.m_luaState.setGlobalString ("g_frameDir", m_frameDir);
[+] 	m_stringTemplate.m_luaState.setGlobalString("g_frameDir", m_frameDir);
[-] 	int top = m_stringTemplate.m_luaState.getTop ();
[+] 	int top = m_stringTemplate.m_luaState.getTop();
[-] 	ASSERT ((size_t) top >= baseArgCount);
[+] 	ASSERT((size_t)top >= baseArgCount);
[-] 	m_stringTemplate.setArgCount (top - baseArgCount);
[+] 	m_stringTemplate.setArgCount(top - baseArgCount);
[-] 	if (targetFileName.isEmpty ())
[+] 	if (targetFileName.isEmpty())
[-] 		result = m_stringTemplate.processFile (NULL, frameFilePath);
[+] 		result = m_stringTemplate.processFile(NULL, frameFilePath);
[-] 		sl::String prevTargetFileName = m_stringTemplate.m_luaState.getGlobalString ("g_targetFileName");
[+] 		sl::String prevTargetFileName = m_stringTemplate.m_luaState.getGlobalString("g_targetFileName");
[-] 		m_stringTemplate.m_luaState.setGlobalString ("g_targetFileName", targetFileName);
[+] 		m_stringTemplate.m_luaState.setGlobalString("g_targetFileName", targetFileName);
[-] 		sl::String targetFilePath = io::concatFilePath (m_targetDir, targetFileName);
[+] 		sl::String targetFilePath = io::concatFilePath(m_targetDir, targetFileName);
[-] 		result = m_stringTemplate.processFileToFile (targetFilePath, frameFilePath);
[+] 		result = m_stringTemplate.processFileToFile(targetFilePath, frameFilePath);
[-] 		m_stringTemplate.m_luaState.setGlobalString ("g_targetFileName", prevTargetFileName);
[+] 		m_stringTemplate.m_luaState.setGlobalString("g_targetFileName", prevTargetFileName);
[-] 	m_stringTemplate.m_luaState.setGlobalString ("g_frameDir", prevFrameDir);
[+] 	m_stringTemplate.m_luaState.setGlobalString("g_frameDir", prevFrameDir);
[-] Generator::includeFile_lua (lua_State* h)
[+] Generator::includeFile_lua(lua_State* h)
[-] 	lua::LuaNonOwnerState luaState (h);
[+] 	lua::LuaNonOwnerState luaState(h);
[-] 	Generator* self = (Generator*) luaState.getContext ();
[+] 	Generator* self = (Generator*)luaState.getContext();
[-] 	ASSERT (self->m_stringTemplate.m_luaState == h);
[+] 	ASSERT(self->m_stringTemplate.m_luaState == h);
[-] 	sl::StringRef fileName = luaState.getString (1);
[+] 	sl::StringRef fileName = luaState.getString(1);
[-] 	bool result = self->processFile (NULL, fileName, 1);
[+] 	bool result = self->processFile(NULL, fileName, 1);
[-] 		luaState.prepareLastErrorString ();
[+] 		luaState.prepareLastErrorString();
[-] 		luaState.error ();
[+] 		luaState.error();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
[-] Generator::generateFile_lua (lua_State* h)
[+] Generator::generateFile_lua(lua_State* h)
[-] 	lua::LuaNonOwnerState luaState (h);
[+] 	lua::LuaNonOwnerState luaState(h);
[-] 	Generator* self = (Generator*) luaState.getContext ();
[+] 	Generator* self = (Generator*)luaState.getContext();
[-] 	ASSERT (self->m_stringTemplate.m_luaState == h);
[+] 	ASSERT(self->m_stringTemplate.m_luaState == h);
[-] 	sl::StringRef targetFileName = luaState.getString (1);
[+] 	sl::StringRef targetFileName = luaState.getString(1);
[-] 	sl::StringRef frameFileName = luaState.getString (2);
[+] 	sl::StringRef frameFileName = luaState.getString(2);
[-] 	bool result = self->processFile (targetFileName, frameFileName, 2);
[+] 	bool result = self->processFile(targetFileName, frameFileName, 2);
[-] 		luaState.prepareLastErrorString ();
[+] 		luaState.prepareLastErrorString();
[-] 		luaState.error ();
[+] 		luaState.error();
[-] 		ASSERT (false);
[+] 		ASSERT(false);
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\main.cpp
----------------------
[-] printVersion ()
[+] printVersion()
[-] 	printf (
[+] 	printf(
[-] printUsage ()
[+] printUsage()
[-] 	printVersion ();
[+] 	printVersion();
[-] 	sl::String helpString = CmdLineSwitchTable::getHelpString ();
[+] 	sl::String helpString = CmdLineSwitchTable::getHelpString();
[-] 	printf ("Usage: doxyrest <doxygen-index.xml> <options>...\n%s", helpString.sz ());
[+] 	printf("Usage: doxyrest <doxygen-index.xml> <options>...\n%s", helpString.sz ());
[-] printIndent (size_t indent)
[+] printIndent(size_t indent)
[-] 		printf ("  ");
[+] 		printf("  ");
[-] printDocBlock (
[+] printDocBlock(
[-] 	printIndent (indent);
[+] 	printIndent(indent);
[-] 	sl::Iterator <DocBlock> it;
[+] 	sl::Iterator<DocBlock> it;
[-] 	switch (block->m_blockKind)
[+] 	switch(block->m_blockKind)
[-] 		if (!block->m_title.isEmpty ())
[+] 		if (!block->m_title.isEmpty())
[-] 			printf ("\\paragraph %s\n", block->m_title.sz ());
[+] 			printf("\\paragraph %s\n", block->m_title.sz ());
[-] 			printIndent (indent);
[+] 			printIndent(indent);
[-] 			printf ("\\paragraph\n");
[+] 			printf("\\paragraph\n");
[-] 			printIndent (indent);
[+] 			printIndent(indent);
[-] 		printf ("%s\n", ((DocParagraphBlock*) block)->m_plainText.sz ());
[+] 		printf("%s\n", ((DocParagraphBlock*) block)->m_plainText.sz ());
[-] 		if (!block->m_title.isEmpty ())
[+] 		if (!block->m_title.isEmpty())
[-] 			printf ("\\sect%d %s\n", level, block->m_title.sz ());
[+] 			printf("\\sect%d %s\n", level, block->m_title.sz ());
[-] 			printf ("\\sect%d\n", level);
[+] 			printf("\\sect%d\n", level);
[-] 		it = ((DocSectionBlock*) block)->m_childBlockList.getHead ();
[+] 		it = ((DocSectionBlock*)block)->m_childBlockList.getHead();
[-] 			printDocBlock (*it, indent + 1, level + 1);
[+] 			printDocBlock(*it, indent + 1, level + 1);
[-] 		printf ("\\internal\n");
[+] 		printf("\\internal\n");
[-] 		it = ((DocSectionBlock*) block)->m_childBlockList.getHead ();
[+] 		it = ((DocSectionBlock*)block)->m_childBlockList.getHead();
[-] 			printDocBlock (*it, indent + 1, level + 1);
[+] 			printDocBlock(*it, indent + 1, level + 1);
[-] printDescription (
[+] printDescription(
[-] 	if (!description->m_title.isEmpty ())
[+] 	if (!description->m_title.isEmpty())
[-] 		printIndent (indent);
[+] 		printIndent(indent);
[-] 		printf ("\\title %s\n", description->m_title.sz ());
[+] 		printf("\\title %s\n", description->m_title.sz ());
[-] 	sl::Iterator <DocBlock> it = description->m_docBlockList.getHead ();
[+] 	sl::Iterator<DocBlock> it = description->m_docBlockList.getHead();
[-] 		printDocBlock (*it, indent, 1);
[+] 		printDocBlock(*it, indent, 1);
[-] printEnumValue (EnumValue* enumValue)
[+] printEnumValue(EnumValue* enumValue)
[-] 	printf (
[+] 	printf(
[-] 		enumValue->m_name.sz (),
[+] 		enumValue->m_name.sz(),
[-] 		enumValue->m_initializer.m_plainText.sz ()
[+] 		enumValue->m_initializer.m_plainText.sz()
[-] 	if (!enumValue->m_briefDescription.isEmpty ())
[+] 	if (!enumValue->m_briefDescription.isEmpty())
[-] 		printf ("    briefDescription\n");
[+] 		printf("    briefDescription\n");
[-] 		printDescription (&enumValue->m_briefDescription, 3);
[+] 		printDescription(&enumValue->m_briefDescription, 3);
[-] 	if (!enumValue->m_detailedDescription.isEmpty ())
[+] 	if (!enumValue->m_detailedDescription.isEmpty())
[-] 		printf ("    detailedDescription\n");
[+] 		printf("    detailedDescription\n");
[-] 		printDescription (&enumValue->m_detailedDescription, 3);
[+] 		printDescription(&enumValue->m_detailedDescription, 3);
[-] printEnumValueList (const sl::ConstList <EnumValue>& list)
[+] printEnumValueList(const sl::ConstList<EnumValue>& list)
[-] 	sl::Iterator <EnumValue> it = list.getHead ();
[+] 	sl::Iterator<EnumValue> it = list.getHead();
[-] 		printEnumValue (*it);
[+] 		printEnumValue(*it);
[-] printParam (Param* param)
[+] printParam(Param* param)
[-] 	printf (
[+] 	printf(
[-] 		param->m_declarationName.sz (),
[+] 		param->m_declarationName.sz(),
[-] 		param->m_definitionName.sz (),
[+] 		param->m_definitionName.sz(),
[-] 		param->m_type.m_plainText.sz (),
[+] 		param->m_type.m_plainText.sz(),
[-] 		param->m_array.sz (),
[+] 		param->m_array.sz(),
[-] 		param->m_defaultValue.m_plainText.sz (),
[+] 		param->m_defaultValue.m_plainText.sz(),
[-] 		param->m_typeConstraint.m_plainText.sz ()
[+] 		param->m_typeConstraint.m_plainText.sz()
[-] 	if (!param->m_briefDescription.isEmpty ())
[+] 	if (!param->m_briefDescription.isEmpty())
[-] 		printf ("    briefDescription\n");
[+] 		printf("    briefDescription\n");
[-] 		printDescription (&param->m_briefDescription, 3);
[+] 		printDescription(&param->m_briefDescription, 3);
[-] printParamList (const sl::ConstList <Param>& list)
[+] printParamList(const sl::ConstList<Param>& list)
[-] 	sl::Iterator <Param> it = list.getHead ();
[+] 	sl::Iterator<Param> it = list.getHead();
[-] 		printParam (*it);
[+] 		printParam(*it);
[-] 	printf (
[+] 	printf(
[-] 		getMemberKindString (member->m_memberKind),
[+] 		getMemberKindString(member->m_memberKind),
[-] 		member->m_name.sz (),
[+] 		member->m_name.sz(),
[-] 		member->m_id.sz (),
[+] 		member->m_id.sz(),
[-] 		member->m_type.m_plainText.sz (),
[+] 		member->m_type.m_plainText.sz(),
[-] 		member->m_definition.sz (),
[+] 		member->m_definition.sz(),
[-] 		member->m_argString.sz (),
[+] 		member->m_argString.sz(),
[-] 		member->m_bitField.sz (),
[+] 		member->m_bitField.sz(),
[-] 		member->m_initializer.m_plainText.sz (),
[+] 		member->m_initializer.m_plainText.sz(),
[-] 		member->m_exceptions.m_plainText.sz (),
[+] 		member->m_exceptions.m_plainText.sz(),
[-] 		getProtectionKindString (member->m_protectionKind),
[+] 		getProtectionKindString(member->m_protectionKind),
[-] 		getVirtualKindString (member->m_virtualKind),
[+] 		getVirtualKindString(member->m_virtualKind),
[-] 		getMemberFlagString (member->m_flags).sz ()
[+] 		getMemberFlagString(member->m_flags).sz()
[-] 	if (!member->m_briefDescription.isEmpty ())
[+] 	if (!member->m_briefDescription.isEmpty())
[-] 		printf ("  briefDescription\n");
[+] 		printf("  briefDescription\n");
[-] 		printDescription (&member->m_briefDescription, 2);
[+] 		printDescription(&member->m_briefDescription, 2);
[-] 	if (!member->m_detailedDescription.isEmpty ())
[+] 	if (!member->m_detailedDescription.isEmpty())
[-] 		printf ("  detailedDescription\n");
[+] 		printf("  detailedDescription\n");
[-] 		printDescription (&member->m_detailedDescription, 2);
[+] 		printDescription(&member->m_detailedDescription, 2);
[-] 	if (!member->m_detailedDescription.isEmpty ())
[+] 	if (!member->m_detailedDescription.isEmpty())
[-] 		printf ("  inBodyDescription\n");
[+] 		printf("  inBodyDescription\n");
[-] 		printDescription (&member->m_inBodyDescription, 2);
[+] 		printDescription(&member->m_inBodyDescription, 2);
[-] 		printf ("  enumMembers {\n");
[+] 		printf("  enumMembers {\n");
[-] 		sl::Iterator <EnumValue> it = member->m_enumValueList.getHead ();
[+] 		sl::Iterator<EnumValue> it = member->m_enumValueList.getHead();
[-] 			printEnumValue (*it);
[+] 			printEnumValue(*it);
[-] 		printf ("  }\n");
[+] 		printf("  }\n");
[-] 	if (!member->m_templateParamList.isEmpty ())
[+] 	if (!member->m_templateParamList.isEmpty())
[-] 		printf ("  templateParamList <\n");
[+] 		printf("  templateParamList <\n");
[-] 		printParamList (member->m_templateParamList);
[+] 		printParamList(member->m_templateParamList);
[-] 		printf ("  >\n");
[+] 		printf("  >\n");
[-] 	if (!member->m_paramList.isEmpty ())
[+] 	if (!member->m_paramList.isEmpty())
[-] 		printf ("  paramList (\n");
[+] 		printf("  paramList (\n");
[-] 		printParamList (member->m_paramList);
[+] 		printParamList(member->m_paramList);
[-] 		printf ("  )\n");
[+] 		printf("  )\n");
[-] printMemberList (const sl::ConstList <Member>& list)
[+] printMemberList(const sl::ConstList<Member>& list)
[-] 	sl::Iterator <Member> it = list.getHead ();
[+] 	sl::Iterator<Member> it = list.getHead();
[-] 		printMember (*it);
[+] 		printMember(*it);
[-] printMemberArray (const sl::Array <Member*>& array)
[+] printMemberArray(const sl::Array<Member*>& array)
[-] 	size_t count = array.getCount ();
[+] 	size_t count = array.getCount();
[-] 		printMember (array [i]);
[+] 		printMember(array[i]);
[-] printCompound (Compound* compound)
[+] printCompound(Compound* compound)
[-] 	printf (
[+] 	printf(
[-] 		getCompoundKindString (compound->m_compoundKind),
[+] 		getCompoundKindString(compound->m_compoundKind),
[-] 		compound->m_name.sz (),
[+] 		compound->m_name.sz(),
[-] 		compound->m_id.sz (),
[+] 		compound->m_id.sz(),
[-] 		compound->m_title.sz (),
[+] 		compound->m_title.sz(),
[-] 		getLanguageKindString (compound->m_languageKind),
[+] 		getLanguageKindString(compound->m_languageKind),
[-] 		getProtectionKindString (compound->m_protectionKind),
[+] 		getProtectionKindString(compound->m_protectionKind),
[-] 	if (!compound->m_briefDescription.isEmpty ())
[+] 	if (!compound->m_briefDescription.isEmpty())
[-] 		printf ("  briefDescription\n");
[+] 		printf("  briefDescription\n");
[-] 		printDescription (&compound->m_briefDescription, 2);
[+] 		printDescription(&compound->m_briefDescription, 2);
[-] 	if (!compound->m_detailedDescription.isEmpty ())
[+] 	if (!compound->m_detailedDescription.isEmpty())
[-] 		printf ("  detailedDescription\n");
[+] 		printf("  detailedDescription\n");
[-] 		printDescription (&compound->m_detailedDescription, 2);
[+] 		printDescription(&compound->m_detailedDescription, 2);
[-] 	sl::Iterator <Member> it = compound->m_memberList.getHead ();
[+] 	sl::Iterator<Member> it = compound->m_memberList.getHead();
[-] 		printMember (*it);
[+] 		printMember(*it);
[-] 	printf ("\n");
[+] 	printf("\n");
[-] printNamespaceContents (NamespaceContents* nspace);
[+] printNamespaceContents(NamespaceContents* nspace);
[-] printNamespaceArray (const sl::Array <Namespace*>& array)
[+] printNamespaceArray(const sl::Array<Namespace*>& array)
[-] 	size_t count = array.getCount ();
[+] 	size_t count = array.getCount();
[-] 		Namespace* nspace = array [i];
[+] 		Namespace* nspace = array[i];
[-] 		printf ("namespace %s {\n", nspace->m_compound->m_name.sz ());
[+] 		printf("namespace %s {\n", nspace->m_compound->m_name.sz ());
[-] 		printNamespaceContents (nspace);
[+] 		printNamespaceContents(nspace);
[-] 		printf ("} // namespace %s {\n", nspace->m_compound->m_name.sz ());
[+] 		printf("} // namespace %s {\n", nspace->m_compound->m_name.sz ());
[-] printNamespaceContents (NamespaceContents* nspace)
[+] printNamespaceContents(NamespaceContents* nspace)
[-] 	if (!nspace->m_namespaceArray.isEmpty ())
[+] 	if (!nspace->m_namespaceArray.isEmpty())
[-] 		printf ("NAMESPACES\n");
[+] 		printf("NAMESPACES\n");
[-] 		printNamespaceArray (nspace->m_namespaceArray);
[+] 		printNamespaceArray(nspace->m_namespaceArray);
[-] 	if (!nspace->m_enumArray.isEmpty ())
[+] 	if (!nspace->m_enumArray.isEmpty())
[-] 		printf ("ENUMS\n");
[+] 		printf("ENUMS\n");
[-] 		printMemberArray (nspace->m_enumArray);
[+] 		printMemberArray(nspace->m_enumArray);
[-] 	if (!nspace->m_structArray.isEmpty ())
[+] 	if (!nspace->m_structArray.isEmpty())
[-] 		printf ("STRUCTS\n");
[+] 		printf("STRUCTS\n");
[-] 		printNamespaceArray (nspace->m_structArray);
[+] 		printNamespaceArray(nspace->m_structArray);
[-] 	if (!nspace->m_unionArray.isEmpty ())
[+] 	if (!nspace->m_unionArray.isEmpty())
[-] 		printf ("UNIONS\n");
[+] 		printf("UNIONS\n");
[-] 		printNamespaceArray (nspace->m_unionArray);
[+] 		printNamespaceArray(nspace->m_unionArray);
[-] 	if (!nspace->m_classArray.isEmpty ())
[+] 	if (!nspace->m_classArray.isEmpty())
[-] 		printf ("CLASSES\n");
[+] 		printf("CLASSES\n");
[-] 		printNamespaceArray (nspace->m_classArray);
[+] 		printNamespaceArray(nspace->m_classArray);
[-] 	if (!nspace->m_typedefArray.isEmpty ())
[+] 	if (!nspace->m_typedefArray.isEmpty())
[-] 		printf ("TYPEDEFS\n");
[+] 		printf("TYPEDEFS\n");
[-] 		printMemberArray (nspace->m_typedefArray);
[+] 		printMemberArray(nspace->m_typedefArray);
[-] 	if (!nspace->m_variableArray.isEmpty ())
[+] 	if (!nspace->m_variableArray.isEmpty())
[-] 		printf ("VARIABLES\n");
[+] 		printf("VARIABLES\n");
[-] 		printMemberArray (nspace->m_variableArray);
[+] 		printMemberArray(nspace->m_variableArray);
[-] 	if (!nspace->m_functionArray.isEmpty ())
[+] 	if (!nspace->m_functionArray.isEmpty())
[-] 		printf ("FUNCTIONS\n");
[+] 		printf("FUNCTIONS\n");
[-] 		printMemberArray (nspace->m_functionArray);
[+] 		printMemberArray(nspace->m_functionArray);
[-] 	if (!nspace->m_propertyArray.isEmpty ())
[+] 	if (!nspace->m_propertyArray.isEmpty())
[-] 		printf ("PROPERTIES\n");
[+] 		printf("PROPERTIES\n");
[-] 		printMemberArray (nspace->m_propertyArray);
[+] 		printMemberArray(nspace->m_propertyArray);
[-] 	if (!nspace->m_eventArray.isEmpty ())
[+] 	if (!nspace->m_eventArray.isEmpty())
[-] 		printf ("EVENTS\n");
[+] 		printf("EVENTS\n");
[-] 		printMemberArray (nspace->m_eventArray);
[+] 		printMemberArray(nspace->m_eventArray);
[-] 	if (!nspace->m_aliasArray.isEmpty ())
[+] 	if (!nspace->m_aliasArray.isEmpty())
[-] 		printf ("ALIASES\n");
[+] 		printf("ALIASES\n");
[-] 		printMemberArray (nspace->m_aliasArray);
[+] 		printMemberArray(nspace->m_aliasArray);
[-] run (CmdLine* cmdLine)
[+] run(CmdLine* cmdLine)
[-] 	Generator generator (cmdLine);
[+] 	Generator generator(cmdLine);
[-] 	printf ("parsing...\n");
[+] 	printf("parsing...\n");
[-] 		parser.parseFile (&module, cmdLine->m_inputFileName) &&
[+] 		parser.parseFile(&module, cmdLine->m_inputFileName) &&
[-] 		globalNamespace.build (&module, cmdLine->m_flags);
[+] 		globalNamespace.build(&module, cmdLine->m_flags);
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("generating...\n");
[+] 	printf("generating...\n");
[-] 	result = generator.generate (
[+] 	result = generator.generate(
[-] 		printf ("error: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error: %s\n", err::getLastErrorDescription ().sz ());
[-] 	printf ("namespace :: {\n");
[+] 	printf("namespace :: {\n");
[-] 	printNamespaceContents (&globalNamespace);
[+] 	printNamespaceContents(&globalNamespace);
[-] 	printf ("} // namespace :: {\n");
[+] 	printf("} // namespace :: {\n");
[-] wmain (
[+] wmain(
[-] 	wchar_t* argv []
[+] 	wchar_t* argv[]
[-] main (
[+] main(
[-] 	char* argv []
[+] 	char* argv[]
[-] 	setvbuf (stdout, NULL, _IOLBF, 1024);
[+] 	setvbuf(stdout, NULL, _IOLBF, 1024);
[-] 	g::getModule ()->setTag ("doxyrest");
[+] 	g::getModule()->setTag("doxyrest");
[-] 	xml::registerExpatErrorProvider ();
[+] 	xml::registerExpatErrorProvider();
[-] 	lex::registerParseErrorProvider ();
[+] 	lex::registerParseErrorProvider();
[-] 	CmdLineParser parser (&cmdLine);
[+] 	CmdLineParser parser(&cmdLine);
[-] 		printUsage ();
[+] 		printUsage();
[-] 	result = parser.parse (argc, argv);
[+] 	result = parser.parse(argc, argv);
[-] 		printf ("error parsing command line: %s\n", err::getLastErrorDescription ().sz ());
[+] 		printf("error parsing command line: %s\n", err::getLastErrorDescription ().sz ());
[-] 		printUsage ();
[+] 		printUsage();
[-] 		printVersion ();
[+] 		printVersion();
[-] 		result = run (&cmdLine);
[+] 		result = run(&cmdLine);
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\Module.cpp
----------------------
[-] createPath (
[+] createPath(
[-] 	parentNamespace->m_compound->preparePath ();
[+] 	parentNamespace->m_compound->preparePath();
[-] 	if (!path.isEmpty ())
[+] 	if (!path.isEmpty())
[-] removeDuplicates (sl::List <T>* list)
[+] removeDuplicates(sl::List<T>* list)
[-] 	sl::DuckTypePtrHashTable <T, bool> map;
[+] 	sl::DuckTypePtrHashTable<T, bool> map;
[-] 	sl::Iterator <T> it = list->getHead ();
[+] 	sl::Iterator<T> it = list->getHead();
[-] 		sl::Iterator <T> next = it.getNext ();
[+] 		sl::Iterator<T> next = it.getNext();
[-] 		bool result = map.addIfNotExists (*it, true) != NULL;
[+] 		bool result = map.addIfNotExists(*it, true) != NULL;
[-] 			list->erase (it);
[+] 			list->erase(it);
[-] removeDuplicates <EnumValue> (sl::List <EnumValue>* list)
[+] removeDuplicates<EnumValue> (sl::List<EnumValue>* list)
[-] 	sl::Iterator <EnumValue> it = list->getHead ();
[+] 	sl::Iterator<EnumValue> it = list->getHead();
[-] 		sl::Iterator <EnumValue> next = it.getNext ();
[+] 		sl::Iterator<EnumValue> next = it.getNext();
[-] 			list->erase (it);
[+] 			list->erase(it);
[-] removeSubPages (sl::Array <Compound*>* pageArray)
[+] removeSubPages(sl::Array<Compound*>* pageArray)
[-] 	size_t count = pageArray->getCount ();
[+] 	size_t count = pageArray->getCount();
[-] 	while (i < count && !p [i]->m_isSubPage)
[+] 	while (i < count && !p[i]->m_isSubPage)
[-] 		Compound* compound = p [i];
[+] 		Compound* compound = p[i];
[-] 			p [j] = p [i];
[+] 			p[j] = p[i];
[-] 	pageArray->setCount (j);
[+] 	pageArray->setCount(j);
[-] RefText::luaExport (lua::LuaState* luaState)
[+] RefText::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	luaState->setMemberString ("m_refKind", getRefKindString (m_refKind));
[+] 	luaState->setMemberString("m_refKind", getRefKindString (m_refKind));
[-] 	luaState->setMemberString ("m_text", m_text);
[+] 	luaState->setMemberString("m_text", m_text);
[-] 	luaState->setMemberString ("m_id", m_id);
[+] 	luaState->setMemberString("m_id", m_id);
[-] 	luaState->setMemberString ("m_external", m_external);
[+] 	luaState->setMemberString("m_external", m_external);
[-] 	luaState->setMemberString ("m_tooltip", m_tooltip);
[+] 	luaState->setMemberString("m_tooltip", m_tooltip);
[-] LinkedText::luaExport (lua::LuaState* luaState)
[+] LinkedText::luaExport(lua::LuaState* luaState)
[-] 	normalize ();
[+] 	normalize();
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	luaState->setMemberBoolean ("m_isEmpty", m_plainText.isEmpty ());
[+] 	luaState->setMemberBoolean("m_isEmpty", m_plainText.isEmpty ());
[-] 	luaState->setMemberString ("m_plainText", m_plainText);
[+] 	luaState->setMemberString("m_plainText", m_plainText);
[-] 	luaExportList (luaState, m_refTextList);
[+] 	luaExportList(luaState, m_refTextList);
[-] 	luaState->setMember ("m_refTextArray");
[+] 	luaState->setMember("m_refTextArray");
[-] LinkedText::normalize ()
[+] LinkedText::normalize()
[-] 	m_plainText.clear ();
[+] 	m_plainText.clear();
[-] 	sl::Iterator <RefText> it = m_refTextList.getHead ();
[+] 	sl::Iterator<RefText> it = m_refTextList.getHead();
[-] 		if (!it->m_text.isEmpty ())
[+] 		if (!it->m_text.isEmpty())
[-] 			sl::Iterator <RefText> next = it.getNext ();
[+] 			sl::Iterator<RefText> next = it.getNext();
[-] 			m_refTextList.erase (it);
[+] 			m_refTextList.erase(it);
[-] DocBlock::luaExportMembers (lua::LuaState* luaState)
[+] DocBlock::luaExportMembers(lua::LuaState* luaState)
[-] 	luaState->setMemberString ("m_blockKind", m_blockKind);
[+] 	luaState->setMemberString("m_blockKind", m_blockKind);
[-] 	luaState->setMemberString ("m_title", m_title);
[+] 	luaState->setMemberString("m_title", m_title);
[-] 	luaState->setMemberString ("m_text", m_text);
[+] 	luaState->setMemberString("m_text", m_text);
[-] 	luaExportList (luaState, m_childBlockList);
[+] 	luaExportList(luaState, m_childBlockList);
[-] 	luaState->setMember ("m_childBlockList");
[+] 	luaState->setMember("m_childBlockList");
[-] DocBlock::luaExport (lua::LuaState* luaState)
[+] DocBlock::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	DocBlock::luaExportMembers (luaState);
[+] 	DocBlock::luaExportMembers(luaState);
[-] DocRefBlock::luaExport (lua::LuaState* luaState)
[+] DocRefBlock::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 		Compound* compound = m_module->m_compoundMap.findValue (m_id, NULL);
[+] 		Compound* compound = m_module->m_compoundMap.findValue(m_id, NULL);
[-] 			DocBlock::luaExportMembers (luaState);
[+] 			DocBlock::luaExportMembers(luaState);
[-] 	DocBlock::luaExportMembers (luaState);
[+] 	DocBlock::luaExportMembers(luaState);
[-] 	luaState->setMemberString ("m_refKind", getRefKindString (m_refKind));
[+] 	luaState->setMemberString("m_refKind", getRefKindString (m_refKind));
[-] 	luaState->setMemberString ("m_id", m_id);
[+] 	luaState->setMemberString("m_id", m_id);
[-] 	luaState->setMemberString ("m_external", m_external);
[+] 	luaState->setMemberString("m_external", m_external);
[-] DocAnchorBlock::luaExport (lua::LuaState* luaState)
[+] DocAnchorBlock::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	DocBlock::luaExportMembers (luaState);
[+] 	DocBlock::luaExportMembers(luaState);
[-] 	luaState->setMemberString ("m_id", m_id);
[+] 	luaState->setMemberString("m_id", m_id);
[-] DocImageBlock::luaExport (lua::LuaState* luaState)
[+] DocImageBlock::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	DocBlock::luaExportMembers (luaState);
[+] 	DocBlock::luaExportMembers(luaState);
[-] 	luaState->setMemberString ("m_imageKind", getImageKindString (m_imageKind));
[+] 	luaState->setMemberString("m_imageKind", getImageKindString (m_imageKind));
[-] 	luaState->setMemberString ("m_name", m_name);
[+] 	luaState->setMemberString("m_name", m_name);
[-] 	luaState->setMemberInteger ("m_width", m_width);
[+] 	luaState->setMemberInteger("m_width", m_width);
[-] 	luaState->setMemberInteger ("m_height", m_height);
[+] 	luaState->setMemberInteger("m_height", m_height);
[-] DocSectionBlock::luaExport (lua::LuaState* luaState)
[+] DocSectionBlock::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	DocBlock::luaExportMembers (luaState);
[+] 	DocBlock::luaExportMembers(luaState);
[-] 	luaState->setMemberString ("m_id", m_id);
[+] 	luaState->setMemberString("m_id", m_id);
[-] DocSimpleSectionBlock::luaExport (lua::LuaState* luaState)
[+] DocSimpleSectionBlock::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	DocBlock::luaExportMembers (luaState);
[+] 	DocBlock::luaExportMembers(luaState);
[-] 	luaState->setMemberString ("m_simpleSectionKind", m_simpleSectionKind);
[+] 	luaState->setMemberString("m_simpleSectionKind", m_simpleSectionKind);
[-] Description::luaExport (lua::LuaState* luaState)
[+] Description::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	luaState->setMemberBoolean ("m_isEmpty", isEmpty ());
[+] 	luaState->setMemberBoolean("m_isEmpty", isEmpty ());
[-] 	luaExportList (luaState, m_docBlockList);
[+] 	luaExportList(luaState, m_docBlockList);
[-] 	luaState->setMember ("m_docBlockList");
[+] 	luaState->setMember("m_docBlockList");
[-] Location::luaExport (lua::LuaState* luaState)
[+] Location::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	luaState->setMemberString ("m_file", m_file);
[+] 	luaState->setMemberString("m_file", m_file);
[-] 	luaState->setMemberInteger ("m_line", m_line);
[+] 	luaState->setMemberInteger("m_line", m_line);
[-] 	luaState->setMemberInteger ("m_column", m_column);
[+] 	luaState->setMemberInteger("m_column", m_column);
[-] 	luaState->setMemberString ("m_bodyFile", m_bodyFile);
[+] 	luaState->setMemberString("m_bodyFile", m_bodyFile);
[-] 	luaState->setMemberInteger ("m_bodyStartLine", m_bodyStartLine);
[+] 	luaState->setMemberInteger("m_bodyStartLine", m_bodyStartLine);
[-] 	luaState->setMemberInteger ("m_bodyEndLine", m_bodyEndLine);
[+] 	luaState->setMemberInteger("m_bodyEndLine", m_bodyEndLine);
[-] Param::luaExport (lua::LuaState* luaState)
[+] Param::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	luaState->setMemberString ("m_declarationName", m_declarationName);
[+] 	luaState->setMemberString("m_declarationName", m_declarationName);
[-] 	luaState->setMemberString ("m_definitionName", m_definitionName);
[+] 	luaState->setMemberString("m_definitionName", m_definitionName);
[-] 	luaState->setMemberString ("m_array", m_array);
[+] 	luaState->setMemberString("m_array", m_array);
[-] 	m_type.luaExport (luaState);
[+] 	m_type.luaExport(luaState);
[-] 	luaState->setMember ("m_type");
[+] 	luaState->setMember("m_type");
[-] 	m_defaultValue.luaExport (luaState);
[+] 	m_defaultValue.luaExport(luaState);
[-] 	luaState->setMember ("m_defaultValue");
[+] 	luaState->setMember("m_defaultValue");
[-] 	m_typeConstraint.luaExport (luaState);
[+] 	m_typeConstraint.luaExport(luaState);
[-] 	luaState->setMember ("m_typeConstraint");
[+] 	luaState->setMember("m_typeConstraint");
[-] 	m_briefDescription.luaExport (luaState);
[+] 	m_briefDescription.luaExport(luaState);
[-] 	luaState->setMember ("m_briefDescription");
[+] 	luaState->setMember("m_briefDescription");
[-] EnumValue::luaExport (lua::LuaState* luaState)
[+] EnumValue::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	luaState->setMemberString ("m_protectionKind", getProtectionKindString (m_protectionKind));
[+] 	luaState->setMemberString("m_protectionKind", getProtectionKindString (m_protectionKind));
[-] 	luaState->setMemberString ("m_id", m_id);
[+] 	luaState->setMemberString("m_id", m_id);
[-] 	luaState->setMemberString ("m_name", m_name);
[+] 	luaState->setMemberString("m_name", m_name);
[-] 	m_parentEnum->preparePath ();
[+] 	m_parentEnum->preparePath();
[-] 	if (!path.isEmpty ())
[+] 	if (!path.isEmpty())
[-] 	luaState->setMemberString ("m_path", path);
[+] 	luaState->setMemberString("m_path", path);
[-] 	m_initializer.luaExport (luaState);
[+] 	m_initializer.luaExport(luaState);
[-] 	luaState->setMember ("m_initializer");
[+] 	luaState->setMember("m_initializer");
[-] 	m_briefDescription.luaExport (luaState);
[+] 	m_briefDescription.luaExport(luaState);
[-] 	luaState->setMember ("m_briefDescription");
[+] 	luaState->setMember("m_briefDescription");
[-] 	m_detailedDescription.luaExport (luaState);
[+] 	m_detailedDescription.luaExport(luaState);
[-] 	luaState->setMember ("m_detailedDescription");
[+] 	luaState->setMember("m_detailedDescription");
[-] getMemberFlagString (MemberFlag flag)
[+] getMemberFlagString(MemberFlag flag)
[-] 	const char* stringTable [] =
[+] 	const char* stringTable[] =
[-] 	size_t i = sl::getLoBitIdx32 (flag);
[+] 	size_t i = sl::getLoBitIdx32(flag);
[-] 	return i < countof (stringTable) ?
[+] 	return i < countof(stringTable) ?
[-] 		stringTable [i] :
[+] 		stringTable[i] :
[-] getFirstMemberFlag (uint_t flags)
[+] getFirstMemberFlag(uint_t flags)
[-] 	return (MemberFlag) (1 << sl::getLoBitIdx (flags));
[+] 	return (MemberFlag)(1 << sl::getLoBitIdx(flags));
[-] getMemberFlagString (uint_t flags)
[+] getMemberFlagString(uint_t flags)
[-] 		return sl::String ();
[+] 		return sl::String();
[-] 		MemberFlag flag = getFirstMemberFlag (flags);
[+] 		MemberFlag flag = getFirstMemberFlag(flags);
[-] 		string += getMemberFlagString (flag);
[+] 		string += getMemberFlagString(flag);
[-] 	string.chop (1);
[+] 	string.chop(1);
[-] Member::Member ()
[+] Member::Member()
[-] Member::luaExport (lua::LuaState* luaState)
[+] Member::luaExport(lua::LuaState* luaState)
[-] 		luaState->getGlobalArrayElement ("g_exportCache", m_cacheIdx);
[+] 		luaState->getGlobalArrayElement("g_exportCache", m_cacheIdx);
[-] 	m_cacheIdx = luaState->getGlobalArrayLen ("g_exportCache") + 1;
[+] 	m_cacheIdx = luaState->getGlobalArrayLen("g_exportCache") + 1;
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	luaState->pushValue (); // duplicate
[+] 	luaState->pushValue(); // duplicate
[-] 	luaState->setGlobalArrayElement ("g_exportCache", m_cacheIdx);
[+] 	luaState->setGlobalArrayElement("g_exportCache", m_cacheIdx);
[-] 	luaState->setMemberString ("m_memberKind", getMemberKindString (m_memberKind));
[+] 	luaState->setMemberString("m_memberKind", getMemberKindString (m_memberKind));
[-] 	luaState->setMemberString ("m_protectionKind", getProtectionKindString (m_protectionKind));
[+] 	luaState->setMemberString("m_protectionKind", getProtectionKindString (m_protectionKind));
[-] 	luaState->setMemberString ("m_virtualKind", getVirtualKindString (m_virtualKind));
[+] 	luaState->setMemberString("m_virtualKind", getVirtualKindString (m_virtualKind));
[-] 	luaState->setMemberString ("m_flags", getMemberFlagString (m_flags));
[+] 	luaState->setMemberString("m_flags", getMemberFlagString (m_flags));
[-] 	luaState->setMemberString ("m_id", m_id);
[+] 	luaState->setMemberString("m_id", m_id);
[-] 	luaState->setMemberString ("m_name", m_name);
[+] 	luaState->setMemberString("m_name", m_name);
[-] 	luaState->setMemberString ("m_modifiers", m_modifiers);
[+] 	luaState->setMemberString("m_modifiers", m_modifiers);
[-] 	AXL_TODO ("use g_exportCache to export group tables instead of IDs (more natural to use from the Lua frames)")
[+] 	AXL_TODO("use g_exportCache to export group tables instead of IDs (more natural to use from the Lua frames)")
[-] 		luaState->setMemberString ("m_groupId", m_groupCompound->m_id);
[+] 		luaState->setMemberString("m_groupId", m_groupCompound->m_id);
[-] 	luaExportStringList (luaState, m_importList);
[+] 	luaExportStringList(luaState, m_importList);
[-] 	luaState->setMember ("m_importArray");
[+] 	luaState->setMember("m_importArray");
[-] 	preparePath ();
[+] 	preparePath();
[-] 	luaState->setMemberString ("m_path",  m_path);
[+] 	luaState->setMemberString("m_path",  m_path);
[-] 	switch (m_memberKind)
[+] 	switch(m_memberKind)
[-] 		m_type.luaExport (luaState);
[+] 		m_type.luaExport(luaState);
[-] 		luaState->setMember ("m_type");
[+] 		luaState->setMember("m_type");
[-] 		luaState->setMemberString ("m_argString", m_argString);
[+] 		luaState->setMemberString("m_argString", m_argString);
[-] 		luaExportList (luaState, m_paramList);
[+] 		luaExportList(luaState, m_paramList);
[-] 		luaState->setMember ("m_paramArray");
[+] 		luaState->setMember("m_paramArray");
[-] 		removeDuplicates (&m_enumValueList);
[+] 		removeDuplicates(&m_enumValueList);
[-] 		luaExportList (luaState, m_enumValueList);
[+] 		luaExportList(luaState, m_enumValueList);
[-] 		luaState->setMember ("m_enumValueArray");
[+] 		luaState->setMember("m_enumValueArray");
[-] 		m_type.luaExport (luaState);
[+] 		m_type.luaExport(luaState);
[-] 		luaState->setMember ("m_type");
[+] 		luaState->setMember("m_type");
[-] 		luaState->setMemberString ("m_argString", m_argString);
[+] 		luaState->setMemberString("m_argString", m_argString);
[-] 		luaState->setMemberString ("m_bitField", m_bitField);
[+] 		luaState->setMemberString("m_bitField", m_bitField);
[-] 		luaExportList (luaState, m_paramList);
[+] 		luaExportList(luaState, m_paramList);
[-] 		luaState->setMember ("m_paramArray");
[+] 		luaState->setMember("m_paramArray");
[-] 		m_initializer.luaExport (luaState);
[+] 		m_initializer.luaExport(luaState);
[-] 		luaState->setMember ("m_initializer");
[+] 		luaState->setMember("m_initializer");
[-] 		m_type.luaExport (luaState);
[+] 		m_type.luaExport(luaState);
[-] 		luaState->setMember ("m_returnType");
[+] 		luaState->setMember("m_returnType");
[-] 		luaState->setMemberString ("m_argString", m_argString);
[+] 		luaState->setMemberString("m_argString", m_argString);
[-] 		m_exceptions.luaExport (luaState);
[+] 		m_exceptions.luaExport(luaState);
[-] 		luaState->setMember ("m_exceptions");
[+] 		luaState->setMember("m_exceptions");
[-] 		luaExportList (luaState, m_templateParamList);
[+] 		luaExportList(luaState, m_templateParamList);
[-] 		luaState->setMember ("m_templateParamArray");
[+] 		luaState->setMember("m_templateParamArray");
[-] 		luaExportList (luaState, m_templateSpecParamList);
[+] 		luaExportList(luaState, m_templateSpecParamList);
[-] 		luaState->setMember ("m_templateSpecParamArray");
[+] 		luaState->setMember("m_templateSpecParamArray");
[-] 		luaExportList (luaState, m_paramList);
[+] 		luaExportList(luaState, m_paramList);
[-] 		luaState->setMember ("m_paramArray");
[+] 		luaState->setMember("m_paramArray");
[-] 		m_type.luaExport (luaState);
[+] 		m_type.luaExport(luaState);
[-] 		luaState->setMember ("m_returnType");
[+] 		luaState->setMember("m_returnType");
[-] 		luaState->setMemberString ("m_argString", m_argString);
[+] 		luaState->setMemberString("m_argString", m_argString);
[-] 		luaExportList (luaState, m_paramList);
[+] 		luaExportList(luaState, m_paramList);
[-] 		luaState->setMember ("m_paramArray");
[+] 		luaState->setMember("m_paramArray");
[-] 		m_type.luaExport (luaState);
[+] 		m_type.luaExport(luaState);
[-] 		luaState->setMember ("m_type");
[+] 		luaState->setMember("m_type");
[-] 		luaState->setMemberString ("m_argString", m_argString);
[+] 		luaState->setMemberString("m_argString", m_argString);
[-] 		luaExportList (luaState, m_paramList);
[+] 		luaExportList(luaState, m_paramList);
[-] 		luaState->setMember ("m_paramArray");
[+] 		luaState->setMember("m_paramArray");
[-] 		m_initializer.luaExport (luaState);
[+] 		m_initializer.luaExport(luaState);
[-] 		luaState->setMember ("m_initializer");
[+] 		luaState->setMember("m_initializer");
[-] 		luaExportList (luaState, m_paramList);
[+] 		luaExportList(luaState, m_paramList);
[-] 		luaState->setMember ("m_paramArray");
[+] 		luaState->setMember("m_paramArray");
[-] 		m_initializer.luaExport (luaState);
[+] 		m_initializer.luaExport(luaState);
[-] 		luaState->setMember ("m_initializer");
[+] 		luaState->setMember("m_initializer");
[-] 	m_briefDescription.luaExport (luaState);
[+] 	m_briefDescription.luaExport(luaState);
[-] 	luaState->setMember ("m_briefDescription");
[+] 	luaState->setMember("m_briefDescription");
[-] 	m_detailedDescription.luaExport (luaState);
[+] 	m_detailedDescription.luaExport(luaState);
[-] 	luaState->setMember ("m_detailedDescription");
[+] 	luaState->setMember("m_detailedDescription");
[-] 	m_inBodyDescription.luaExport (luaState);
[+] 	m_inBodyDescription.luaExport(luaState);
[-] 	luaState->setMember ("m_inBodyDescription");
[+] 	luaState->setMember("m_inBodyDescription");
[-] 	m_location.luaExport (luaState);
[+] 	m_location.luaExport(luaState);
[-] 	luaState->setMember ("m_location");
[+] 	luaState->setMember("m_location");
[-] Compound::Compound ()
[+] Compound::Compound()
[-] Compound::luaExport (lua::LuaState* luaState)
[+] Compound::luaExport(lua::LuaState* luaState)
[-] 		luaState->getGlobalArrayElement ("g_exportCache", m_cacheIdx);
[+] 		luaState->getGlobalArrayElement("g_exportCache", m_cacheIdx);
[-] 	m_cacheIdx = luaState->getGlobalArrayLen ("g_exportCache") + 1;
[+] 	m_cacheIdx = luaState->getGlobalArrayLen("g_exportCache") + 1;
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	luaState->pushValue (); // duplicate
[+] 	luaState->pushValue(); // duplicate
[-] 	luaState->setGlobalArrayElement ("g_exportCache", m_cacheIdx);
[+] 	luaState->setGlobalArrayElement("g_exportCache", m_cacheIdx);
[-] 	luaState->setMemberString ("m_compoundKind", getCompoundKindString (m_compoundKind));
[+] 	luaState->setMemberString("m_compoundKind", getCompoundKindString (m_compoundKind));
[-] 	luaState->setMemberString ("m_id", m_id);
[+] 	luaState->setMemberString("m_id", m_id);
[-] 	luaState->setMemberString ("m_name", m_name);
[+] 	luaState->setMemberString("m_name", m_name);
[-] 	luaState->setMemberString ("m_title", m_title);
[+] 	luaState->setMemberString("m_title", m_title);
[-] 	if (!m_importId.isEmpty ())
[+] 	if (!m_importId.isEmpty())
[-] 		luaState->setMemberString ("m_importId", m_importId);
[+] 		luaState->setMemberString("m_importId", m_importId);
[-] 		luaState->setMemberString ("m_groupId", m_groupCompound->m_id);
[+] 		luaState->setMemberString("m_groupId", m_groupCompound->m_id);
[-] 	preparePath ();
[+] 	preparePath();
[-] 	luaState->setMemberString ("m_path", m_path);
[+] 	luaState->setMemberString("m_path", m_path);
[-] 	switch (m_compoundKind)
[+] 	switch(m_compoundKind)
[-] 		luaExportArray (luaState, m_subPageArray);
[+] 		luaExportArray(luaState, m_subPageArray);
[-] 		luaState->setMember ("m_subPageArray");
[+] 		luaState->setMember("m_subPageArray");
[-] 		luaExportList (luaState, m_templateParamList);
[+] 		luaExportList(luaState, m_templateParamList);
[-] 		luaState->setMember ("m_templateParamArray");
[+] 		luaState->setMember("m_templateParamArray");
[-] 		luaExportList (luaState, m_templateSpecParamList);
[+] 		luaExportList(luaState, m_templateSpecParamList);
[-] 		luaState->setMember ("m_templateSpecParamArray");
[+] 		luaState->setMember("m_templateSpecParamArray");
[-] 		luaExportArray (luaState, m_baseTypeArray);
[+] 		luaExportArray(luaState, m_baseTypeArray);
[-] 		luaState->setMember ("m_baseTypeArray");
[+] 		luaState->setMember("m_baseTypeArray");
[-] 		count = m_baseTypeProtectionArray.getCount ();
[+] 		count = m_baseTypeProtectionArray.getCount();
[-] 		luaState->createTable (count);
[+] 		luaState->createTable(count);
[-] 			luaState->setArrayElementString (i + 1, getProtectionKindString (m_baseTypeProtectionArray [i]));
[+] 			luaState->setArrayElementString(i + 1, getProtectionKindString(m_baseTypeProtectionArray[i]));
[-] 		luaState->setMember ("m_baseTypeProtectionArray");
[+] 		luaState->setMember("m_baseTypeProtectionArray");
[-] 		luaExportArray (
[+] 		luaExportArray(
[-] 			!m_derivedTypeArray_doxy.isEmpty () ?
[+] 			!m_derivedTypeArray_doxy.isEmpty() ?
[-] 		luaState->setMember ("m_derivedTypeArray");
[+] 		luaState->setMember("m_derivedTypeArray");
[-] 	luaExportStringList (luaState, m_importList);
[+] 	luaExportStringList(luaState, m_importList);
[-] 	luaState->setMember ("m_importArray");
[+] 	luaState->setMember("m_importArray");
[-] 	m_briefDescription.luaExport (luaState);
[+] 	m_briefDescription.luaExport(luaState);
[-] 	luaState->setMember ("m_briefDescription");
[+] 	luaState->setMember("m_briefDescription");
[-] 	m_detailedDescription.luaExport (luaState);
[+] 	m_detailedDescription.luaExport(luaState);
[-] 	luaState->setMember ("m_detailedDescription");
[+] 	luaState->setMember("m_detailedDescription");
[-] 	m_location.luaExport (luaState);
[+] 	m_location.luaExport(luaState);
[-] 	luaState->setMember ("m_location");
[+] 	luaState->setMember("m_location");
[-] 		m_selfNamespace->luaExportMembers (luaState);
[+] 		m_selfNamespace->luaExportMembers(luaState);
[-] Compound::unqualifyName ()
[+] Compound::unqualifyName()
[-] 	const char* end = p + m_name.getLength ();
[+] 	const char* end = p + m_name.getLength();
[-] 		switch (*p)
[+] 		switch(*p)
[-] 		m_name.offset (unqualifiedName - m_name);
[+] 		m_name.offset(unqualifiedName - m_name);
[-] Compound::unspecializeName ()
[+] Compound::unspecializeName()
[-] 	size_t i = m_name.find ('<');
[+] 	size_t i = m_name.find('<');
[-] 	const char* p = m_name.sz () + unspecializedNameLength + 1;
[+] 	const char* p = m_name.sz() + unspecializedNameLength + 1;
[-] 	const char* end = m_name.sz () + m_name.getLength ();
[+] 	const char* end = m_name.sz() + m_name.getLength();
[-] 		switch (*p)
[+] 		switch(*p)
[-] 				createTemplateSpecParam (sl::StringRef (p0, p - p0));
[+] 				createTemplateSpecParam(sl::StringRef(p0, p - p0));
[-] 				createTemplateSpecParam (sl::StringRef (p0, p - p0));
[+] 				createTemplateSpecParam(sl::StringRef(p0, p - p0));
[-] 	m_name.setReducedLength (unspecializedNameLength);
[+] 	m_name.setReducedLength(unspecializedNameLength);
[-] 	m_name.trimRight ();
[+] 	m_name.trimRight();
[-] 	const char* x = strchr (m_name, '>');
[+] 	const char* x = strchr(m_name, '>');
[-] 	ASSERT (!x);
[+] 	ASSERT(!x);
[-] Compound::createTemplateSpecParam (const sl::StringRef& name)
[+] Compound::createTemplateSpecParam(const sl::StringRef& name)
[-] 	Param* param = AXL_MEM_NEW (Param);
[+] 	Param* param = AXL_MEM_NEW(Param);
[-] 	param->m_declarationName.trim ();
[+] 	param->m_declarationName.trim();
[-] 	m_templateSpecParamList.insertTail (param);
[+] 	m_templateSpecParamList.insertTail(param);
[-] NamespaceContents::add (Compound* compound)
[+] NamespaceContents::add(Compound* compound)
[-] 	switch (compound->m_compoundKind)
[+] 	switch(compound->m_compoundKind)
[-] 		ASSERT (compound->m_selfNamespace);
[+] 		ASSERT(compound->m_selfNamespace);
[-] 		m_namespaceArray.append (compound->m_selfNamespace);
[+] 		m_namespaceArray.append(compound->m_selfNamespace);
[-] 		ASSERT (compound->m_selfNamespace);
[+] 		ASSERT(compound->m_selfNamespace);
[-] 		m_structArray.append (compound->m_selfNamespace);
[+] 		m_structArray.append(compound->m_selfNamespace);
[-] 		ASSERT (compound->m_selfNamespace);
[+] 		ASSERT(compound->m_selfNamespace);
[-] 		m_unionArray.append (compound->m_selfNamespace);
[+] 		m_unionArray.append(compound->m_selfNamespace);
[-] 		ASSERT (compound->m_selfNamespace);
[+] 		ASSERT(compound->m_selfNamespace);
[-] 		m_classArray.append (compound->m_selfNamespace);
[+] 		m_classArray.append(compound->m_selfNamespace);
[-] 		ASSERT (compound->m_selfNamespace);
[+] 		ASSERT(compound->m_selfNamespace);
[-] 		m_interfaceArray.append (compound->m_selfNamespace);
[+] 		m_interfaceArray.append(compound->m_selfNamespace);
[-] 		ASSERT (compound->m_selfNamespace);
[+] 		ASSERT(compound->m_selfNamespace);
[-] 		m_protocolArray.append (compound->m_selfNamespace);
[+] 		m_protocolArray.append(compound->m_selfNamespace);
[-] 		ASSERT (compound->m_selfNamespace);
[+] 		ASSERT(compound->m_selfNamespace);
[-] 		m_exceptionArray.append (compound->m_selfNamespace);
[+] 		m_exceptionArray.append(compound->m_selfNamespace);
[-] 		ASSERT (compound->m_selfNamespace);
[+] 		ASSERT(compound->m_selfNamespace);
[-] 		m_serviceArray.append (compound->m_selfNamespace);
[+] 		m_serviceArray.append(compound->m_selfNamespace);
[-] 		ASSERT (compound->m_selfNamespace);
[+] 		ASSERT(compound->m_selfNamespace);
[-] 		m_singletonArray.append (compound->m_selfNamespace);
[+] 		m_singletonArray.append(compound->m_selfNamespace);
[-] isCppDestructorName (
[+] isCppDestructorName(
[-] 		!memberName.isEmpty () &&
[+] 		!memberName.isEmpty() &&
[-] 		memberName [0] == '~' &&
[+] 		memberName[0] == '~' &&
[-] 		memberName.getSubString (1) == compoundName;
[+] 		memberName.getSubString(1) == compoundName;
[-] NamespaceContents::add (
[+] NamespaceContents::add(
[-] 	switch (member->m_memberKind)
[+] 	switch(member->m_memberKind)
[-] 		m_propertyArray.append (member);
[+] 		m_propertyArray.append(member);
[-] 		m_eventArray.append (member);
[+] 		m_eventArray.append(member);
[-] 		m_variableArray.append (member);
[+] 		m_variableArray.append(member);
[-] 		m_typedefArray.append (member);
[+] 		m_typedefArray.append(member);
[-] 		m_enumArray.append (member);
[+] 		m_enumArray.append(member);
[-] 			switch (thisCompound->m_languageKind)
[+] 			switch(thisCompound->m_languageKind)
[-] 				else if (isCppDestructorName (member->m_name, thisCompound->m_name))
[+] 				else if (isCppDestructorName(member->m_name, thisCompound->m_name))
[-] 			m_constructorArray.append (member);
[+] 			m_constructorArray.append(member);
[-] 			m_functionArray.append (member);
[+] 			m_functionArray.append(member);
[-] 		m_aliasArray.append (member);
[+] 		m_aliasArray.append(member);
[-] 		m_defineArray.append (member);
[+] 		m_defineArray.append(member);
[-] 		m_footnoteArray.append (member);
[+] 		m_footnoteArray.append(member);
[-] 		ASSERT (false); // should have been handled earlier
[+] 		ASSERT(false); // should have been handled earlier
[-] NamespaceContents::luaExportMembers (lua::LuaState* luaState)
[+] NamespaceContents::luaExportMembers(lua::LuaState* luaState)
[-] 	luaExportArray (luaState, m_groupArray);
[+] 	luaExportArray(luaState, m_groupArray);
[-] 	luaState->setMember ("m_groupArray");
[+] 	luaState->setMember("m_groupArray");
[-] 	luaExportArray (luaState, m_namespaceArray);
[+] 	luaExportArray(luaState, m_namespaceArray);
[-] 	luaState->setMember ("m_namespaceArray");
[+] 	luaState->setMember("m_namespaceArray");
[-] 	luaExportArray (luaState, m_enumArray);
[+] 	luaExportArray(luaState, m_enumArray);
[-] 	luaState->setMember ("m_enumArray");
[+] 	luaState->setMember("m_enumArray");
[-] 	luaExportArray (luaState, m_structArray);
[+] 	luaExportArray(luaState, m_structArray);
[-] 	luaState->setMember ("m_structArray");
[+] 	luaState->setMember("m_structArray");
[-] 	luaExportArray (luaState, m_unionArray);
[+] 	luaExportArray(luaState, m_unionArray);
[-] 	luaState->setMember ("m_unionArray");
[+] 	luaState->setMember("m_unionArray");
[-] 	luaExportArray (luaState, m_classArray);
[+] 	luaExportArray(luaState, m_classArray);
[-] 	luaState->setMember ("m_classArray");
[+] 	luaState->setMember("m_classArray");
[-] 	luaExportArray (luaState, m_interfaceArray);
[+] 	luaExportArray(luaState, m_interfaceArray);
[-] 	luaState->setMember ("m_interfaceArray");
[+] 	luaState->setMember("m_interfaceArray");
[-] 	luaExportArray (luaState, m_protocolArray);
[+] 	luaExportArray(luaState, m_protocolArray);
[-] 	luaState->setMember ("m_protocolArray");
[+] 	luaState->setMember("m_protocolArray");
[-] 	luaExportArray (luaState, m_exceptionArray);
[+] 	luaExportArray(luaState, m_exceptionArray);
[-] 	luaState->setMember ("m_exceptionArray");
[+] 	luaState->setMember("m_exceptionArray");
[-] 	luaExportArray (luaState, m_serviceArray);
[+] 	luaExportArray(luaState, m_serviceArray);
[-] 	luaState->setMember ("m_serviceArray");
[+] 	luaState->setMember("m_serviceArray");
[-] 	luaExportArray (luaState, m_singletonArray);
[+] 	luaExportArray(luaState, m_singletonArray);
[-] 	luaState->setMember ("m_singletonArray");
[+] 	luaState->setMember("m_singletonArray");
[-] 	luaExportArray (luaState, m_typedefArray);
[+] 	luaExportArray(luaState, m_typedefArray);
[-] 	luaState->setMember ("m_typedefArray");
[+] 	luaState->setMember("m_typedefArray");
[-] 	luaExportArray (luaState, m_variableArray);
[+] 	luaExportArray(luaState, m_variableArray);
[-] 	luaState->setMember ("m_variableArray");
[+] 	luaState->setMember("m_variableArray");
[-] 	luaExportArray (luaState, m_constructorArray);
[+] 	luaExportArray(luaState, m_constructorArray);
[-] 	luaState->setMember ("m_constructorArray");
[+] 	luaState->setMember("m_constructorArray");
[-] 		m_destructor->luaExport (luaState);
[+] 		m_destructor->luaExport(luaState);
[-] 		luaState->setMember ("m_destructor");
[+] 		luaState->setMember("m_destructor");
[-] 	luaExportArray (luaState, m_functionArray);
[+] 	luaExportArray(luaState, m_functionArray);
[-] 	luaState->setMember ("m_functionArray");
[+] 	luaState->setMember("m_functionArray");
[-] 	luaExportArray (luaState, m_propertyArray);
[+] 	luaExportArray(luaState, m_propertyArray);
[-] 	luaState->setMember ("m_propertyArray");
[+] 	luaState->setMember("m_propertyArray");
[-] 	luaExportArray (luaState, m_eventArray);
[+] 	luaExportArray(luaState, m_eventArray);
[-] 	luaState->setMember ("m_eventArray");
[+] 	luaState->setMember("m_eventArray");
[-] 	luaExportArray (luaState, m_aliasArray);
[+] 	luaExportArray(luaState, m_aliasArray);
[-] 	luaState->setMember ("m_aliasArray");
[+] 	luaState->setMember("m_aliasArray");
[-] 	luaExportArray (luaState, m_defineArray);
[+] 	luaExportArray(luaState, m_defineArray);
[-] 	luaState->setMember ("m_defineArray");
[+] 	luaState->setMember("m_defineArray");
[-] 	luaExportArray (luaState, m_footnoteArray);
[+] 	luaExportArray(luaState, m_footnoteArray);
[-] 	luaState->setMember ("m_footnoteArray");
[+] 	luaState->setMember("m_footnoteArray");
[-] GlobalNamespace::clear ()
[+] GlobalNamespace::clear()
[-] 	m_groupArray.clear ();
[+] 	m_groupArray.clear();
[-] 	m_namespaceArray.clear ();
[+] 	m_namespaceArray.clear();
[-] 	m_enumArray.clear ();
[+] 	m_enumArray.clear();
[-] 	m_structArray.clear ();
[+] 	m_structArray.clear();
[-] 	m_unionArray.clear ();
[+] 	m_unionArray.clear();
[-] 	m_classArray.clear ();
[+] 	m_classArray.clear();
[-] 	m_typedefArray.clear ();
[+] 	m_typedefArray.clear();
[-] 	m_variableArray.clear ();
[+] 	m_variableArray.clear();
[-] 	m_functionArray.clear ();
[+] 	m_functionArray.clear();
[-] 	m_propertyArray.clear ();
[+] 	m_propertyArray.clear();
[-] 	m_eventArray.clear ();
[+] 	m_eventArray.clear();
[-] 	m_aliasArray.clear ();
[+] 	m_aliasArray.clear();
[-] 	m_namespaceList.clear ();
[+] 	m_namespaceList.clear();
[-] GlobalNamespace::build (
[+] GlobalNamespace::build(
[-] 	clear ();
[+] 	clear();
[-] 	size_t count = module->m_groupArray.getCount ();
[+] 	size_t count = module->m_groupArray.getCount();
[-] 		Compound* compound = module->m_groupArray [i];
[+] 		Compound* compound = module->m_groupArray[i];
[-] 		sl::Iterator <Member> memberIt = compound->m_memberList.getHead ();
[+] 		sl::Iterator<Member> memberIt = compound->m_memberList.getHead();
[-] 				compound->m_groupFootnoteArray.append (*memberIt);
[+] 				compound->m_groupFootnoteArray.append(*memberIt);
[-] 				Member* member = module->m_memberMap.findValue (memberIt->m_id, NULL);
[+] 				Member* member = module->m_memberMap.findValue(memberIt->m_id, NULL);
[-] 				if (member && (isMemberGroupAllowed || member->m_parentCompound->isMemberGroupAllowed ()))
[+] 				if (member && (isMemberGroupAllowed || member->m_parentCompound->isMemberGroupAllowed()))
[-] 		sl::Iterator <Ref> refIt = compound->m_innerRefList.getHead ();
[+] 		sl::Iterator<Ref> refIt = compound->m_innerRefList.getHead();
[-] 			Compound* innerCompound = module->m_compoundMap.findValue (refIt->m_id, NULL);
[+] 			Compound* innerCompound = module->m_compoundMap.findValue(refIt->m_id, NULL);
[-] 	module->m_groupArray.clear (); // will contain non-empty root groups only
[+] 	module->m_groupArray.clear(); // will contain non-empty root groups only
[-] 	count = module->m_namespaceArray.getCount ();
[+] 	count = module->m_namespaceArray.getCount();
[-] 		Compound* compound = module->m_namespaceArray [i];
[+] 		Compound* compound = module->m_namespaceArray[i];
[-] 		Namespace* nspace = AXL_MEM_NEW (Namespace);
[+] 		Namespace* nspace = AXL_MEM_NEW(Namespace);
[-] 		m_namespaceList.insertTail (nspace);
[+] 		m_namespaceList.insertTail(nspace);
[-] 		Compound* compound = module->m_namespaceArray [i];
[+] 		Compound* compound = module->m_namespaceArray[i];
[-] 		ASSERT (nspace);
[+] 		ASSERT(nspace);
[-] 		compound->unqualifyName ();
[+] 		compound->unqualifyName();
[-] 		compound->unspecializeName ();
[+] 		compound->unspecializeName();
[-] 		sl::Iterator <Member> memberIt = compound->m_memberList.getHead ();
[+] 		sl::Iterator<Member> memberIt = compound->m_memberList.getHead();
[-] 			switch (memberIt->m_memberKind)
[+] 			switch(memberIt->m_memberKind)
[-] 				memberCompound = createMemberCompound (module, *memberIt);
[+] 				memberCompound = createMemberCompound(module, *memberIt);
[-] 				nspace->add (memberCompound);
[+] 				nspace->add(memberCompound);
[-] 					Namespace* groupNspace = getGroupNamespace (module, memberCompound->m_groupCompound);
[+] 					Namespace* groupNspace = getGroupNamespace(module, memberCompound->m_groupCompound);
[-] 					groupNspace->add (memberCompound);
[+] 					groupNspace->add(memberCompound);
[-] 				nspace->add (*memberIt, compound);
[+] 				nspace->add(*memberIt, compound);
[-] 					Namespace* groupNspace = getGroupNamespace (module, memberIt->m_groupCompound);
[+] 					Namespace* groupNspace = getGroupNamespace(module, memberIt->m_groupCompound);
[-] 					groupNspace->add (*memberIt, compound);
[+] 					groupNspace->add(*memberIt, compound);
[-] 		sl::Iterator <Ref> refIt = compound->m_innerRefList.getHead ();
[+] 		sl::Iterator<Ref> refIt = compound->m_innerRefList.getHead();
[-] 			Compound* innerCompound = module->m_compoundMap.findValue (refIt->m_id, NULL);
[+] 			Compound* innerCompound = module->m_compoundMap.findValue(refIt->m_id, NULL);
[-] 				printf ("warning: can't find inner compound refid: %s\n", refIt->m_id.sz ());
[+] 				printf("warning: can't find inner compound refid: %s\n", refIt->m_id.sz ());
[-] 			nspace->add (innerCompound);
[+] 			nspace->add(innerCompound);
[-] 				if (isMemberGroupAllowed || compound->isMemberGroupAllowed ())
[+] 				if (isMemberGroupAllowed || compound->isMemberGroupAllowed())
[-] 					Namespace* groupNspace = getGroupNamespace (module, innerCompound->m_groupCompound);
[+] 					Namespace* groupNspace = getGroupNamespace(module, innerCompound->m_groupCompound);
[-] 					groupNspace->add (innerCompound);
[+] 					groupNspace->add(innerCompound);
[-] 		removeDuplicates (&compound->m_baseRefList);
[+] 		removeDuplicates(&compound->m_baseRefList);
[-] 		removeDuplicates (&compound->m_derivedRefList);
[+] 		removeDuplicates(&compound->m_derivedRefList);
[-] 		refIt = compound->m_baseRefList.getHead ();
[+] 		refIt = compound->m_baseRefList.getHead();
[-] 			if (refIt->m_id.isEmpty () || !refIt->m_importId.isEmpty ()) // template or imported base
[+] 			if (refIt->m_id.isEmpty() || !refIt->m_importId.isEmpty()) // template or imported base
[-] 				baseCompound = AXL_MEM_NEW (Compound);
[+] 				baseCompound = AXL_MEM_NEW(Compound);
[-] 				module->m_compoundList.insertTail (baseCompound);
[+] 				module->m_compoundList.insertTail(baseCompound);
[-] 				baseCompound = module->m_compoundMap.findValue (refIt->m_id, NULL);
[+] 				baseCompound = module->m_compoundMap.findValue(refIt->m_id, NULL);
[-] 					err::setFormatStringError ("can't find base compound refid: %s\n", refIt->m_id.sz ());
[+] 					err::setFormatStringError("can't find base compound refid: %s\n", refIt->m_id.sz ());
[-] 				baseCompound->m_derivedTypeArray_auto.append (compound);
[+] 				baseCompound->m_derivedTypeArray_auto.append(compound);
[-] 			compound->m_baseTypeArray.append (baseCompound);
[+] 			compound->m_baseTypeArray.append(baseCompound);
[-] 			compound->m_baseTypeProtectionArray.append (refIt->m_protectionKind);
[+] 			compound->m_baseTypeProtectionArray.append(refIt->m_protectionKind);
[-] 		sl::StringHashTable <bool> idMap; // derivedcompoundref may specify the same class multiple types -- we don't want that
[+] 		sl::StringHashTable<bool> idMap; // derivedcompoundref may specify the same class multiple types -- we don't want that
[-] 		refIt = compound->m_derivedRefList.getHead ();
[+] 		refIt = compound->m_derivedRefList.getHead();
[-] 			if (!idMap.addIfNotExists (refIt->m_id, true))
[+] 			if (!idMap.addIfNotExists(refIt->m_id, true))
[-] 			Compound* derivedCompound = module->m_compoundMap.findValue (refIt->m_id, NULL);
[+] 			Compound* derivedCompound = module->m_compoundMap.findValue(refIt->m_id, NULL);
[-] 				printf ("warning: can't find derived compound refid: %s\n", refIt->m_id.sz ());
[+] 				printf("warning: can't find derived compound refid: %s\n", refIt->m_id.sz ());
[-] 			compound->m_derivedTypeArray_doxy.append (derivedCompound);
[+] 			compound->m_derivedTypeArray_doxy.append(derivedCompound);
[-] 	count = module->m_pageArray.getCount ();
[+] 	count = module->m_pageArray.getCount();
[-] 		Compound* compound = module->m_pageArray [i];
[+] 		Compound* compound = module->m_pageArray[i];
[-] 		sl::Iterator <Ref> refIt = compound->m_innerRefList.getHead ();
[+] 		sl::Iterator<Ref> refIt = compound->m_innerRefList.getHead();
[-] 			Compound* subPage = module->m_compoundMap.findValue (refIt->m_id, NULL);
[+] 			Compound* subPage = module->m_compoundMap.findValue(refIt->m_id, NULL);
[-] 				printf ("warning: can't find subpage refid: %s\n", refIt->m_id.sz ());
[+] 				printf("warning: can't find subpage refid: %s\n", refIt->m_id.sz ());
[-] 			compound->m_subPageArray.append (subPage);
[+] 			compound->m_subPageArray.append(subPage);
[-] 	removeSubPages (&module->m_pageArray);
[+] 	removeSubPages(&module->m_pageArray);
[-] 	sl::Iterator <Compound> compoundIt = module->m_compoundList.getHead ();
[+] 	sl::Iterator<Compound> compoundIt = module->m_compoundList.getHead();
[-] 		sl::Iterator <Member> memberIt;
[+] 		sl::Iterator<Member> memberIt;
[-] 		switch (compoundIt->m_compoundKind)
[+] 		switch(compoundIt->m_compoundKind)
[-] 			memberIt = compoundIt->m_memberList.getHead ();
[+] 			memberIt = compoundIt->m_memberList.getHead();
[-] 				switch (memberIt->m_memberKind)
[+] 				switch(memberIt->m_memberKind)
[-] 					memberCompound = createMemberCompound (module, *memberIt);
[+] 					memberCompound = createMemberCompound(module, *memberIt);
[-] 					add (memberCompound);
[+] 					add(memberCompound);
[-] 						Namespace* groupNspace = getGroupNamespace (module, memberCompound->m_groupCompound);
[+] 						Namespace* groupNspace = getGroupNamespace(module, memberCompound->m_groupCompound);
[-] 						groupNspace->add (memberCompound);
[+] 						groupNspace->add(memberCompound);
[-] 					add (*memberIt, NULL);
[+] 					add(*memberIt, NULL);
[-] 						Namespace* groupNspace = getGroupNamespace (module, memberIt->m_groupCompound);
[+] 						Namespace* groupNspace = getGroupNamespace(module, memberIt->m_groupCompound);
[-] 						groupNspace->add (*memberIt, NULL);
[+] 						groupNspace->add(*memberIt, NULL);
[-] 				add (*compoundIt);
[+] 				add(*compoundIt);
[-] 					Namespace* groupNspace = getGroupNamespace (module, compoundIt->m_groupCompound);
[+] 					Namespace* groupNspace = getGroupNamespace(module, compoundIt->m_groupCompound);
[-] 					groupNspace->add (*compoundIt);
[+] 					groupNspace->add(*compoundIt);
[-] GlobalNamespace::luaExport (lua::LuaState* luaState)
[+] GlobalNamespace::luaExport(lua::LuaState* luaState)
[-] 	luaState->createTable ();
[+] 	luaState->createTable();
[-] 	luaExportMembers (luaState);
[+] 	luaExportMembers(luaState);
[-] 	luaState->setMemberString ("m_path", "");
[+] 	luaState->setMemberString("m_path", "");
[-] 	luaState->setMemberString ("m_id", "global");
[+] 	luaState->setMemberString("m_id", "global");
[-] 	luaState->setMemberString ("m_compoundKind", "namespace");
[+] 	luaState->setMemberString("m_compoundKind", "namespace");
[-] 	emptyDescription.luaExport (luaState);
[+] 	emptyDescription.luaExport(luaState);
[-] 	luaState->setMember ("m_briefDescription");
[+] 	luaState->setMember("m_briefDescription");
[-] 	emptyDescription.luaExport (luaState);
[+] 	emptyDescription.luaExport(luaState);
[-] 	luaState->setMember ("m_detailedDescription");
[+] 	luaState->setMember("m_detailedDescription");
[-] GlobalNamespace::getGroupNamespace (
[+] GlobalNamespace::getGroupNamespace(
[-] 	Namespace* nspace = AXL_MEM_NEW (Namespace);
[+] 	Namespace* nspace = AXL_MEM_NEW(Namespace);
[-] 	m_namespaceList.insertTail (nspace);
[+] 	m_namespaceList.insertTail(nspace);
[-] 		module->m_groupArray.append (groupCompound);
[+] 		module->m_groupArray.append(groupCompound);
[-] 		Namespace* parentGroupNspace = getGroupNamespace (module, groupCompound->m_groupCompound);
[+] 		Namespace* parentGroupNspace = getGroupNamespace(module, groupCompound->m_groupCompound);
[-] 		parentGroupNspace->m_groupArray.append (nspace);
[+] 		parentGroupNspace->m_groupArray.append(nspace);
[-] GlobalNamespace::createMemberCompound (
[+] GlobalNamespace::createMemberCompound(
[-] 	Compound* compound = AXL_MEM_NEW (Compound);
[+] 	Compound* compound = AXL_MEM_NEW(Compound);
[-] 	sl::takeOver (&compound->m_briefDescription, &member->m_briefDescription);
[+] 	sl::takeOver(&compound->m_briefDescription, &member->m_briefDescription);
[-] 	sl::takeOver (&compound->m_detailedDescription, &member->m_detailedDescription);
[+] 	sl::takeOver(&compound->m_detailedDescription, &member->m_detailedDescription);
[-] 	compound->m_selfNamespace = AXL_MEM_NEW (Namespace);
[+] 	compound->m_selfNamespace = AXL_MEM_NEW(Namespace);
[-] 	m_namespaceList.insertTail (compound->m_selfNamespace);
[+] 	m_namespaceList.insertTail(compound->m_selfNamespace);
[-] 	module->m_compoundList.insertTail (compound);
[+] 	module->m_compoundList.insertTail(compound);
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\CmdLine.h
----------------------
[-] 	Define ()
[+] 	Define()
[-] 	sl::BoxList <sl::String> m_frameDirList;
[+] 	sl::BoxList<sl::String> m_frameDirList;
[-] 	sl::List <Define> m_defineList;
[+] 	sl::List<Define> m_defineList;
[-] 	CmdLine ()
[+] 	CmdLine()
[-] AXL_SL_BEGIN_CMD_LINE_SWITCH_TABLE (CmdLineSwitchTable, CmdLineSwitchKind)
[+] AXL_SL_BEGIN_CMD_LINE_SWITCH_TABLE(CmdLineSwitchTable, CmdLineSwitchKind)
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH_2 (
[+] 	AXL_SL_CMD_LINE_SWITCH_2(
[-] 	AXL_SL_CMD_LINE_SWITCH (
[+] 	AXL_SL_CMD_LINE_SWITCH(
[-] AXL_SL_END_CMD_LINE_SWITCH_TABLE ()
[+] AXL_SL_END_CMD_LINE_SWITCH_TABLE()
[-] class CmdLineParser: public sl::CmdLineParser <CmdLineParser, CmdLineSwitchTable>
[+] class CmdLineParser: public sl::CmdLineParser<CmdLineParser, CmdLineSwitchTable>
[-] 	friend class sl::CmdLineParser <CmdLineParser, CmdLineSwitchTable>;
[+] 	friend class sl::CmdLineParser<CmdLineParser, CmdLineSwitchTable>;
[-] 	CmdLineParser (CmdLine* cmdLine)
[+] 	CmdLineParser(CmdLine* cmdLine)
[-] 	onValue (const sl::StringRef& value)
[+] 	onValue(const sl::StringRef& value)
[-] 	onSwitch (
[+] 	onSwitch(
[-] 	finalize ();
[+] 	finalize();
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\DoxyXmlEnum.h
----------------------
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (BoolKindMap, BoolKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(BoolKindMap, BoolKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("yes", BoolKind_Yes)
[+] 	AXL_SL_HASH_TABLE_ENTRY("yes", BoolKind_Yes)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("no",  BoolKind_No)
[+] 	AXL_SL_HASH_TABLE_ENTRY("no",  BoolKind_No)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getBoolKindString (BoolKind boolKind);
[+] getBoolKindString(BoolKind boolKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (LanguageKindMap, LanguageKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(LanguageKindMap, LanguageKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("Unknown",     LanguageKind_Unknown)
[+] 	AXL_SL_HASH_TABLE_ENTRY("Unknown",     LanguageKind_Unknown)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("IDL",         LanguageKind_Idl)
[+] 	AXL_SL_HASH_TABLE_ENTRY("IDL",         LanguageKind_Idl)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("Java",        LanguageKind_Java)
[+] 	AXL_SL_HASH_TABLE_ENTRY("Java",        LanguageKind_Java)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("C#",          LanguageKind_CSharp)
[+] 	AXL_SL_HASH_TABLE_ENTRY("C#",          LanguageKind_CSharp)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("D",           LanguageKind_D)
[+] 	AXL_SL_HASH_TABLE_ENTRY("D",           LanguageKind_D)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("PHP",         LanguageKind_Php)
[+] 	AXL_SL_HASH_TABLE_ENTRY("PHP",         LanguageKind_Php)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("Objective-C", LanguageKind_ObjectiveC)
[+] 	AXL_SL_HASH_TABLE_ENTRY("Objective-C", LanguageKind_ObjectiveC)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("C++",         LanguageKind_Cpp)
[+] 	AXL_SL_HASH_TABLE_ENTRY("C++",         LanguageKind_Cpp)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("Javascript",  LanguageKind_JavaScript)
[+] 	AXL_SL_HASH_TABLE_ENTRY("Javascript",  LanguageKind_JavaScript)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("Python",      LanguageKind_Python)
[+] 	AXL_SL_HASH_TABLE_ENTRY("Python",      LanguageKind_Python)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("Fortran",     LanguageKind_Fortran)
[+] 	AXL_SL_HASH_TABLE_ENTRY("Fortran",     LanguageKind_Fortran)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("VHDL",        LanguageKind_Vhdl)
[+] 	AXL_SL_HASH_TABLE_ENTRY("VHDL",        LanguageKind_Vhdl)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("XML",         LanguageKind_Xml)
[+] 	AXL_SL_HASH_TABLE_ENTRY("XML",         LanguageKind_Xml)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("Tcl",         LanguageKind_Tcl)
[+] 	AXL_SL_HASH_TABLE_ENTRY("Tcl",         LanguageKind_Tcl)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("Markdown",    LanguageKind_Markdown)
[+] 	AXL_SL_HASH_TABLE_ENTRY("Markdown",    LanguageKind_Markdown)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("Jancy",       LanguageKind_Jancy)
[+] 	AXL_SL_HASH_TABLE_ENTRY("Jancy",       LanguageKind_Jancy)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getLanguageKindString (LanguageKind languageKind);
[+] getLanguageKindString(LanguageKind languageKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (MemberKindMap, MemberKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(MemberKindMap, MemberKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("define",    MemberKind_Define)
[+] 	AXL_SL_HASH_TABLE_ENTRY("define",    MemberKind_Define)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("property",  MemberKind_Property)
[+] 	AXL_SL_HASH_TABLE_ENTRY("property",  MemberKind_Property)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("event",     MemberKind_Event)
[+] 	AXL_SL_HASH_TABLE_ENTRY("event",     MemberKind_Event)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("variable",  MemberKind_Variable)
[+] 	AXL_SL_HASH_TABLE_ENTRY("variable",  MemberKind_Variable)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("typedef",   MemberKind_Typedef)
[+] 	AXL_SL_HASH_TABLE_ENTRY("typedef",   MemberKind_Typedef)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("enum",      MemberKind_Enum)
[+] 	AXL_SL_HASH_TABLE_ENTRY("enum",      MemberKind_Enum)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("enumvalue", MemberKind_EnumValue)
[+] 	AXL_SL_HASH_TABLE_ENTRY("enumvalue", MemberKind_EnumValue)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("function",  MemberKind_Function)
[+] 	AXL_SL_HASH_TABLE_ENTRY("function",  MemberKind_Function)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("signal",    MemberKind_Signal)
[+] 	AXL_SL_HASH_TABLE_ENTRY("signal",    MemberKind_Signal)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("prototype", MemberKind_Prototype)
[+] 	AXL_SL_HASH_TABLE_ENTRY("prototype", MemberKind_Prototype)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("friend",    MemberKind_Friend)
[+] 	AXL_SL_HASH_TABLE_ENTRY("friend",    MemberKind_Friend)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("dcop",      MemberKind_Dcop)
[+] 	AXL_SL_HASH_TABLE_ENTRY("dcop",      MemberKind_Dcop)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("slot",      MemberKind_Slot)
[+] 	AXL_SL_HASH_TABLE_ENTRY("slot",      MemberKind_Slot)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("interface", MemberKind_Interface)
[+] 	AXL_SL_HASH_TABLE_ENTRY("interface", MemberKind_Interface)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("service",   MemberKind_Service)
[+] 	AXL_SL_HASH_TABLE_ENTRY("service",   MemberKind_Service)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("alias",     MemberKind_Alias)
[+] 	AXL_SL_HASH_TABLE_ENTRY("alias",     MemberKind_Alias)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("footnote",  MemberKind_Footnote)
[+] 	AXL_SL_HASH_TABLE_ENTRY("footnote",  MemberKind_Footnote)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getMemberKindString (MemberKind memberKind);
[+] getMemberKindString(MemberKind memberKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (ProtectionKindMap, ProtectionKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(ProtectionKindMap, ProtectionKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("public",    ProtectionKind_Public)
[+] 	AXL_SL_HASH_TABLE_ENTRY("public",    ProtectionKind_Public)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("protected", ProtectionKind_Protected)
[+] 	AXL_SL_HASH_TABLE_ENTRY("protected", ProtectionKind_Protected)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("private",   ProtectionKind_Private)
[+] 	AXL_SL_HASH_TABLE_ENTRY("private",   ProtectionKind_Private)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("package",   ProtectionKind_Package)
[+] 	AXL_SL_HASH_TABLE_ENTRY("package",   ProtectionKind_Package)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getProtectionKindString (ProtectionKind protectionKind);
[+] getProtectionKindString(ProtectionKind protectionKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (VirtualKindMap, VirtualKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(VirtualKindMap, VirtualKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("non-virtual",  VirtualKind_NonVirtual)
[+] 	AXL_SL_HASH_TABLE_ENTRY("non-virtual",  VirtualKind_NonVirtual)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("virtual",      VirtualKind_Virtual)
[+] 	AXL_SL_HASH_TABLE_ENTRY("virtual",      VirtualKind_Virtual)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("pure-virtual", VirtualKind_PureVirtual)
[+] 	AXL_SL_HASH_TABLE_ENTRY("pure-virtual", VirtualKind_PureVirtual)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("abstract",     VirtualKind_Abstract)
[+] 	AXL_SL_HASH_TABLE_ENTRY("abstract",     VirtualKind_Abstract)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("override",     VirtualKind_Override)
[+] 	AXL_SL_HASH_TABLE_ENTRY("override",     VirtualKind_Override)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getVirtualKindString (VirtualKind virtualKind);
[+] getVirtualKindString(VirtualKind virtualKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (RefKindMap, RefKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(RefKindMap, RefKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("compound", RefKind_Compound)
[+] 	AXL_SL_HASH_TABLE_ENTRY("compound", RefKind_Compound)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("member",   RefKind_Member)
[+] 	AXL_SL_HASH_TABLE_ENTRY("member",   RefKind_Member)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getRefKindString (RefKind refKind);
[+] getRefKindString(RefKind refKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (GraphRelationKindMap, GraphRelationKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(GraphRelationKindMap, GraphRelationKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("include",               GraphRelationKind_Include)
[+] 	AXL_SL_HASH_TABLE_ENTRY("include",               GraphRelationKind_Include)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("usage",                 GraphRelationKind_Usage)
[+] 	AXL_SL_HASH_TABLE_ENTRY("usage",                 GraphRelationKind_Usage)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("template-instance",     GraphRelationKind_TemplateInstance)
[+] 	AXL_SL_HASH_TABLE_ENTRY("template-instance",     GraphRelationKind_TemplateInstance)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("public-inheritance",    GraphRelationKind_PublicInheritance)
[+] 	AXL_SL_HASH_TABLE_ENTRY("public-inheritance",    GraphRelationKind_PublicInheritance)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("protected-inheritance", GraphRelationKind_ProtectedInheritance)
[+] 	AXL_SL_HASH_TABLE_ENTRY("protected-inheritance", GraphRelationKind_ProtectedInheritance)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("private-inheritance",   GraphRelationKind_PrivateInheritance)
[+] 	AXL_SL_HASH_TABLE_ENTRY("private-inheritance",   GraphRelationKind_PrivateInheritance)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("type-constraint",       GraphRelationKind_TypeConstraint)
[+] 	AXL_SL_HASH_TABLE_ENTRY("type-constraint",       GraphRelationKind_TypeConstraint)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getGraphRelationKindString (GraphRelationKind graphRelationKind);
[+] getGraphRelationKindString(GraphRelationKind graphRelationKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (CompoundKindMap, CompoundKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(CompoundKindMap, CompoundKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("class",     CompoundKind_Class)
[+] 	AXL_SL_HASH_TABLE_ENTRY("class",     CompoundKind_Class)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("struct",    CompoundKind_Struct)
[+] 	AXL_SL_HASH_TABLE_ENTRY("struct",    CompoundKind_Struct)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("union",     CompoundKind_Union)
[+] 	AXL_SL_HASH_TABLE_ENTRY("union",     CompoundKind_Union)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("interface", CompoundKind_Interface)
[+] 	AXL_SL_HASH_TABLE_ENTRY("interface", CompoundKind_Interface)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("protocol",  CompoundKind_Protocol)
[+] 	AXL_SL_HASH_TABLE_ENTRY("protocol",  CompoundKind_Protocol)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("category",  CompoundKind_Category)
[+] 	AXL_SL_HASH_TABLE_ENTRY("category",  CompoundKind_Category)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("exception", CompoundKind_Exception)
[+] 	AXL_SL_HASH_TABLE_ENTRY("exception", CompoundKind_Exception)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("service",   CompoundKind_Service)
[+] 	AXL_SL_HASH_TABLE_ENTRY("service",   CompoundKind_Service)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("singleton", CompoundKind_Singleton)
[+] 	AXL_SL_HASH_TABLE_ENTRY("singleton", CompoundKind_Singleton)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("file",      CompoundKind_File)
[+] 	AXL_SL_HASH_TABLE_ENTRY("file",      CompoundKind_File)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("namespace", CompoundKind_Namespace)
[+] 	AXL_SL_HASH_TABLE_ENTRY("namespace", CompoundKind_Namespace)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("group",     CompoundKind_Group)
[+] 	AXL_SL_HASH_TABLE_ENTRY("group",     CompoundKind_Group)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("page",      CompoundKind_Page)
[+] 	AXL_SL_HASH_TABLE_ENTRY("page",      CompoundKind_Page)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("example",   CompoundKind_Example)
[+] 	AXL_SL_HASH_TABLE_ENTRY("example",   CompoundKind_Example)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("dir",       CompoundKind_Dir)
[+] 	AXL_SL_HASH_TABLE_ENTRY("dir",       CompoundKind_Dir)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getCompoundKindString (CompoundKind compoundKind);
[+] getCompoundKindString(CompoundKind compoundKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (SectionKindMap, SectionKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(SectionKindMap, SectionKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("user-defined",            SectionKind_UserDefined)
[+] 	AXL_SL_HASH_TABLE_ENTRY("user-defined",            SectionKind_UserDefined)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("public-type",             SectionKind_PublicType)
[+] 	AXL_SL_HASH_TABLE_ENTRY("public-type",             SectionKind_PublicType)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("public-func",             SectionKind_PublicFunc)
[+] 	AXL_SL_HASH_TABLE_ENTRY("public-func",             SectionKind_PublicFunc)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("public-attrib",           SectionKind_PublicAttrib)
[+] 	AXL_SL_HASH_TABLE_ENTRY("public-attrib",           SectionKind_PublicAttrib)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("public-slot",             SectionKind_PublicSlot)
[+] 	AXL_SL_HASH_TABLE_ENTRY("public-slot",             SectionKind_PublicSlot)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("signal",                  SectionKind_Signal)
[+] 	AXL_SL_HASH_TABLE_ENTRY("signal",                  SectionKind_Signal)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("dcop-func",               SectionKind_DcopFunc)
[+] 	AXL_SL_HASH_TABLE_ENTRY("dcop-func",               SectionKind_DcopFunc)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("property",                SectionKind_Property)
[+] 	AXL_SL_HASH_TABLE_ENTRY("property",                SectionKind_Property)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("event",                   SectionKind_Event)
[+] 	AXL_SL_HASH_TABLE_ENTRY("event",                   SectionKind_Event)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("public-static-func",      SectionKind_PublicStaticFunc)
[+] 	AXL_SL_HASH_TABLE_ENTRY("public-static-func",      SectionKind_PublicStaticFunc)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("public-static-attrib",    SectionKind_PublicStaticAttrib)
[+] 	AXL_SL_HASH_TABLE_ENTRY("public-static-attrib",    SectionKind_PublicStaticAttrib)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("protected-type",          SectionKind_ProtectedType)
[+] 	AXL_SL_HASH_TABLE_ENTRY("protected-type",          SectionKind_ProtectedType)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("protected-func",          SectionKind_ProtectedFunc)
[+] 	AXL_SL_HASH_TABLE_ENTRY("protected-func",          SectionKind_ProtectedFunc)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("protected-attrib",        SectionKind_ProtectedAttrib)
[+] 	AXL_SL_HASH_TABLE_ENTRY("protected-attrib",        SectionKind_ProtectedAttrib)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("protected-slot",          SectionKind_ProtectedSlot)
[+] 	AXL_SL_HASH_TABLE_ENTRY("protected-slot",          SectionKind_ProtectedSlot)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("protected-static-func",   SectionKind_ProtectedStaticFunc)
[+] 	AXL_SL_HASH_TABLE_ENTRY("protected-static-func",   SectionKind_ProtectedStaticFunc)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("protected-static-attrib", SectionKind_ProtectedStaticAttrib)
[+] 	AXL_SL_HASH_TABLE_ENTRY("protected-static-attrib", SectionKind_ProtectedStaticAttrib)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("package-type",            SectionKind_PackageType)
[+] 	AXL_SL_HASH_TABLE_ENTRY("package-type",            SectionKind_PackageType)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("package-func",            SectionKind_PackageFunc)
[+] 	AXL_SL_HASH_TABLE_ENTRY("package-func",            SectionKind_PackageFunc)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("package-attrib",          SectionKind_PackageAttrib)
[+] 	AXL_SL_HASH_TABLE_ENTRY("package-attrib",          SectionKind_PackageAttrib)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("package-static-func",     SectionKind_PackageStaticFunc)
[+] 	AXL_SL_HASH_TABLE_ENTRY("package-static-func",     SectionKind_PackageStaticFunc)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("package-static-attrib",   SectionKind_PackageStaticAttrib)
[+] 	AXL_SL_HASH_TABLE_ENTRY("package-static-attrib",   SectionKind_PackageStaticAttrib)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("private-type",            SectionKind_PrivateType)
[+] 	AXL_SL_HASH_TABLE_ENTRY("private-type",            SectionKind_PrivateType)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("private-func",            SectionKind_PrivateFunc)
[+] 	AXL_SL_HASH_TABLE_ENTRY("private-func",            SectionKind_PrivateFunc)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("private-attrib",          SectionKind_PrivateAttrib)
[+] 	AXL_SL_HASH_TABLE_ENTRY("private-attrib",          SectionKind_PrivateAttrib)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("private-slot",            SectionKind_PrivateSlot)
[+] 	AXL_SL_HASH_TABLE_ENTRY("private-slot",            SectionKind_PrivateSlot)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("private-static-func",     SectionKind_PrivateStaticFunc)
[+] 	AXL_SL_HASH_TABLE_ENTRY("private-static-func",     SectionKind_PrivateStaticFunc)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("private-static-attrib",   SectionKind_PrivateStaticAttrib)
[+] 	AXL_SL_HASH_TABLE_ENTRY("private-static-attrib",   SectionKind_PrivateStaticAttrib)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("friend",                  SectionKind_Friend)
[+] 	AXL_SL_HASH_TABLE_ENTRY("friend",                  SectionKind_Friend)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("related",                 SectionKind_Related)
[+] 	AXL_SL_HASH_TABLE_ENTRY("related",                 SectionKind_Related)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("define",                  SectionKind_Define)
[+] 	AXL_SL_HASH_TABLE_ENTRY("define",                  SectionKind_Define)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("prototype",               SectionKind_Prototype)
[+] 	AXL_SL_HASH_TABLE_ENTRY("prototype",               SectionKind_Prototype)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("typedef",                 SectionKind_Typedef)
[+] 	AXL_SL_HASH_TABLE_ENTRY("typedef",                 SectionKind_Typedef)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("enum",                    SectionKind_Enum)
[+] 	AXL_SL_HASH_TABLE_ENTRY("enum",                    SectionKind_Enum)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("func",                    SectionKind_Func)
[+] 	AXL_SL_HASH_TABLE_ENTRY("func",                    SectionKind_Func)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("var",                     SectionKind_Var)
[+] 	AXL_SL_HASH_TABLE_ENTRY("var",                     SectionKind_Var)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getSectionKindString (SectionKind sectionKind);
[+] getSectionKindString(SectionKind sectionKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (ImageKindMap, ImageKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(ImageKindMap, ImageKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("html",  ImageKind_Html)
[+] 	AXL_SL_HASH_TABLE_ENTRY("html",  ImageKind_Html)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("latex", ImageKind_Latex)
[+] 	AXL_SL_HASH_TABLE_ENTRY("latex", ImageKind_Latex)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("rtf",   ImageKind_Rtf)
[+] 	AXL_SL_HASH_TABLE_ENTRY("rtf",   ImageKind_Rtf)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getImageKindString (ImageKind imageKind);
[+] getImageKindString(ImageKind imageKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (ParamListKindMap, ParamListKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(ParamListKindMap, ParamListKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("param",         ParamListKind_Param)
[+] 	AXL_SL_HASH_TABLE_ENTRY("param",         ParamListKind_Param)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("retval",        ParamListKind_RetVal)
[+] 	AXL_SL_HASH_TABLE_ENTRY("retval",        ParamListKind_RetVal)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("exception",     ParamListKind_Exception)
[+] 	AXL_SL_HASH_TABLE_ENTRY("exception",     ParamListKind_Exception)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("templateparam", ParamListKind_TemplateParam)
[+] 	AXL_SL_HASH_TABLE_ENTRY("templateparam", ParamListKind_TemplateParam)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getParamListKindString (ParamListKind paramListKind);
[+] getParamListKindString(ParamListKind paramListKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (ParamDirKindMap, ParamDirKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(ParamDirKindMap, ParamDirKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("in",    ParamDirKind_In)
[+] 	AXL_SL_HASH_TABLE_ENTRY("in",    ParamDirKind_In)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("out",   ParamDirKind_Out)
[+] 	AXL_SL_HASH_TABLE_ENTRY("out",   ParamDirKind_Out)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("inout", ParamDirKind_InOut)
[+] 	AXL_SL_HASH_TABLE_ENTRY("inout", ParamDirKind_InOut)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getParamDirKindString (ParamDirKind paramDirKind);
[+] getParamDirKindString(ParamDirKind paramDirKind);
[-] AXL_SL_BEGIN_STRING_HASH_TABLE (AccessorKindMap, AccessorKind)
[+] AXL_SL_BEGIN_STRING_HASH_TABLE(AccessorKindMap, AccessorKind)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("retain",     AccessorKind_Retain)
[+] 	AXL_SL_HASH_TABLE_ENTRY("retain",     AccessorKind_Retain)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("copy",       AccessorKind_Copy)
[+] 	AXL_SL_HASH_TABLE_ENTRY("copy",       AccessorKind_Copy)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("assign",     AccessorKind_Assign)
[+] 	AXL_SL_HASH_TABLE_ENTRY("assign",     AccessorKind_Assign)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("weak",       AccessorKind_Weak)
[+] 	AXL_SL_HASH_TABLE_ENTRY("weak",       AccessorKind_Weak)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("strong",     AccessorKind_Strong)
[+] 	AXL_SL_HASH_TABLE_ENTRY("strong",     AccessorKind_Strong)
[-] 	AXL_SL_HASH_TABLE_ENTRY ("unretained", AccessorKind_Unretained)
[+] 	AXL_SL_HASH_TABLE_ENTRY("unretained", AccessorKind_Unretained)
[-] AXL_SL_END_HASH_TABLE ()
[+] AXL_SL_END_HASH_TABLE()
[-] getAccessorKindString (AccessorKind accessorKind);
[+] getAccessorKindString(AccessorKind accessorKind);
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\DoxyXmlParser.h
----------------------
[-] class DoxyXmlParser: public xml::ExpatParser <DoxyXmlParser>
[+] class DoxyXmlParser: public xml::ExpatParser<DoxyXmlParser>
[-] 	friend class xml::ExpatParser <DoxyXmlParser>;
[+] 	friend class xml::ExpatParser<DoxyXmlParser>;
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("doxygenindex", ElemKind_DoxygenIndex)
[+] 		AXL_SL_HASH_TABLE_ENTRY("doxygenindex", ElemKind_DoxygenIndex)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("doxygen",      ElemKind_DoxygenCompound)
[+] 		AXL_SL_HASH_TABLE_ENTRY("doxygen",      ElemKind_DoxygenCompound)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	sl::Array <TypeStackEntry> m_typeStack;
[+] 	sl::Array<TypeStackEntry> m_typeStack;
[-] 	sl::Array <Compound*> m_compoundStack;
[+] 	sl::Array<Compound*> m_compoundStack;
[-] 	DoxyXmlParser ();
[+] 	DoxyXmlParser();
[-] 	~DoxyXmlParser ()
[+] 	~DoxyXmlParser()
[-] 		clear ();
[+] 		clear();
[-] 	getModule ()
[+] 	getModule()
[-] 	getFilePath ()
[+] 	getFilePath()
[-] 	getBaseDir ()
[+] 	getBaseDir()
[-] 	parseFile (
[+] 	parseFile(
[-] 	parseFile (
[+] 	parseFile(
[-] 		return parseFile (module, DoxyXmlFileKind_Index, fileName, blockSize);
[+] 		return parseFile(module, DoxyXmlFileKind_Index, fileName, blockSize);
[-] 	clear ();
[+] 	clear();
[-] 	pushType (
[+] 	pushType(
[-] 		T* type = AXL_MEM_NEW (T);
[+] 		T* type = AXL_MEM_NEW(T);
[-] 		m_typeStack.append (entry);
[+] 		m_typeStack.append(entry);
[-] 		return type->create (this, name, attributes);
[+] 		return type->create(this, name, attributes);
[-] 	pushType (
[+] 	pushType(
[-] 		T* type = AXL_MEM_NEW (T);
[+] 		T* type = AXL_MEM_NEW(T);
[-] 		m_typeStack.append (entry);
[+] 		m_typeStack.append(entry);
[-] 		return type->create (this, context, name, attributes);
[+] 		return type->create(this, context, name, attributes);
[-] 	getCurrentCompound ()
[+] 	getCurrentCompound()
[-] 		return !m_compoundStack.isEmpty () ? m_compoundStack.getBack () : NULL;
[+] 		return !m_compoundStack.isEmpty() ? m_compoundStack.getBack() : NULL;
[-] 	pushCompound (Compound* compound)
[+] 	pushCompound(Compound* compound)
[-] 		return m_compoundStack.append (compound);
[+] 		return m_compoundStack.append(compound);
[-] 	popCompound ()
[+] 	popCompound()
[-] 		return m_compoundStack.getBackAndPop ();
[+] 		return m_compoundStack.getBackAndPop();
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	onEndElement (const char* name);
[+] 	onEndElement(const char* name);
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 	popType ();
[+] 	popType();
[-] 	printIndent ();
[+] 	printIndent();
[-] 	printElement (
[+] 	printElement(
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\DoxyXmlType.h
----------------------
[-] 	DoxyXmlType ()
[+] 	DoxyXmlType()
[-] 	create (
[+] 	create(
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	onEndElement (const char* name)
[+] 	onEndElement(const char* name)
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 	onPopType ()
[+] 	onPopType()
[-] 	StringType ()
[+] 	StringType()
[-] 	create (
[+] 	create(
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 		m_string->append (string, length);
[+] 		m_string->append(string, length);
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (IndexElemKindMap, IndexElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(IndexElemKindMap, IndexElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("compound", IndexElemKind_Compound)
[+] 		AXL_SL_HASH_TABLE_ENTRY("compound", IndexElemKind_Compound)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (IndexAttrKindMap, IndexAttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(IndexAttrKindMap, IndexAttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("version", IndexAttrKind_Version)
[+] 		AXL_SL_HASH_TABLE_ENTRY("version", IndexAttrKind_Version)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (CompoundAttrKindMap, CompoundAttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(CompoundAttrKindMap, CompoundAttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("refid", CompoundAttrKind_RefId)
[+] 		AXL_SL_HASH_TABLE_ENTRY("refid", CompoundAttrKind_RefId)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("kind",  CompoundAttrKind_Kind)
[+] 		AXL_SL_HASH_TABLE_ENTRY("kind",  CompoundAttrKind_Kind)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	create (
[+] 	create(
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	onCompound (
[+] 	onCompound(
[-] 	parseCompound (const char* refId);
[+] 	parseCompound(const char* refId);
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("compounddef", ElemKind_CompoundDef)
[+] 		AXL_SL_HASH_TABLE_ENTRY("compounddef", ElemKind_CompoundDef)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("version", AttrKind_Version)
[+] 		AXL_SL_HASH_TABLE_ENTRY("version", AttrKind_Version)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	create (
[+] 	create(
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("compoundname",        ElemKind_CompoundName)
[+] 		AXL_SL_HASH_TABLE_ENTRY("compoundname",        ElemKind_CompoundName)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("title",               ElemKind_Title)
[+] 		AXL_SL_HASH_TABLE_ENTRY("title",               ElemKind_Title)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("basecompoundref",     ElemKind_BaseCompoundRef)
[+] 		AXL_SL_HASH_TABLE_ENTRY("basecompoundref",     ElemKind_BaseCompoundRef)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("derivedcompoundref",  ElemKind_DerivedCompoundRef)
[+] 		AXL_SL_HASH_TABLE_ENTRY("derivedcompoundref",  ElemKind_DerivedCompoundRef)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("includes",            ElemKind_Includes)
[+] 		AXL_SL_HASH_TABLE_ENTRY("includes",            ElemKind_Includes)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("includedby",          ElemKind_IncludedBy)
[+] 		AXL_SL_HASH_TABLE_ENTRY("includedby",          ElemKind_IncludedBy)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("incdepgraph",         ElemKind_IncDepGraph)
[+] 		AXL_SL_HASH_TABLE_ENTRY("incdepgraph",         ElemKind_IncDepGraph)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("invincdepgraph",      ElemKind_InvIncDepGraph)
[+] 		AXL_SL_HASH_TABLE_ENTRY("invincdepgraph",      ElemKind_InvIncDepGraph)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("innerdir",            ElemKind_InnerDir)
[+] 		AXL_SL_HASH_TABLE_ENTRY("innerdir",            ElemKind_InnerDir)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("innerdile",           ElemKind_InnerFile)
[+] 		AXL_SL_HASH_TABLE_ENTRY("innerdile",           ElemKind_InnerFile)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("innerclass",          ElemKind_InnerClass)
[+] 		AXL_SL_HASH_TABLE_ENTRY("innerclass",          ElemKind_InnerClass)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("innernamespace",      ElemKind_InnerNamespace)
[+] 		AXL_SL_HASH_TABLE_ENTRY("innernamespace",      ElemKind_InnerNamespace)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("innerpage",           ElemKind_InnerPage)
[+] 		AXL_SL_HASH_TABLE_ENTRY("innerpage",           ElemKind_InnerPage)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("innergroup",          ElemKind_InnerGroup)
[+] 		AXL_SL_HASH_TABLE_ENTRY("innergroup",          ElemKind_InnerGroup)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("templateparamlist",   ElemKind_TemplateParamList)
[+] 		AXL_SL_HASH_TABLE_ENTRY("templateparamlist",   ElemKind_TemplateParamList)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("sectiondef",          ElemKind_SectionDef)
[+] 		AXL_SL_HASH_TABLE_ENTRY("sectiondef",          ElemKind_SectionDef)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("briefdescription",    ElemKind_BriefDescription)
[+] 		AXL_SL_HASH_TABLE_ENTRY("briefdescription",    ElemKind_BriefDescription)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("detaileddescription", ElemKind_DetailedDescription)
[+] 		AXL_SL_HASH_TABLE_ENTRY("detaileddescription", ElemKind_DetailedDescription)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("inheritancegraph",    ElemKind_InheritanceGraph)
[+] 		AXL_SL_HASH_TABLE_ENTRY("inheritancegraph",    ElemKind_InheritanceGraph)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("collaborationgraph",  ElemKind_CollaborationGraph)
[+] 		AXL_SL_HASH_TABLE_ENTRY("collaborationgraph",  ElemKind_CollaborationGraph)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("programlisting",      ElemKind_ProgramListing)
[+] 		AXL_SL_HASH_TABLE_ENTRY("programlisting",      ElemKind_ProgramListing)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("location",            ElemKind_Location)
[+] 		AXL_SL_HASH_TABLE_ENTRY("location",            ElemKind_Location)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("listofallmembers",    ElemKind_ListOfAllMembers)
[+] 		AXL_SL_HASH_TABLE_ENTRY("listofallmembers",    ElemKind_ListOfAllMembers)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("id",       AttrKind_Id)
[+] 		AXL_SL_HASH_TABLE_ENTRY("id",       AttrKind_Id)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("kind",     AttrKind_Kind)
[+] 		AXL_SL_HASH_TABLE_ENTRY("kind",     AttrKind_Kind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("language", AttrKind_Language)
[+] 		AXL_SL_HASH_TABLE_ENTRY("language", AttrKind_Language)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("prot",     AttrKind_Prot)
[+] 		AXL_SL_HASH_TABLE_ENTRY("prot",     AttrKind_Prot)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("final",    AttrKind_Final)
[+] 		AXL_SL_HASH_TABLE_ENTRY("final",    AttrKind_Final)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("sealed",   AttrKind_Sealed)
[+] 		AXL_SL_HASH_TABLE_ENTRY("sealed",   AttrKind_Sealed)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("abstract", AttrKind_Abstract)
[+] 		AXL_SL_HASH_TABLE_ENTRY("abstract", AttrKind_Abstract)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	CompoundDefType ()
[+] 	CompoundDefType()
[-] 	create (
[+] 	create(
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	onPopType ();
[+] 	onPopType();
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("member", ElemKind_Member)
[+] 		AXL_SL_HASH_TABLE_ENTRY("member", ElemKind_Member)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("scope", ElemKind_Scope)
[+] 		AXL_SL_HASH_TABLE_ENTRY("scope", ElemKind_Scope)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("name",  ElemKind_Name)
[+] 		AXL_SL_HASH_TABLE_ENTRY("name",  ElemKind_Name)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("refid", AttrKind_RefId)
[+] 		AXL_SL_HASH_TABLE_ENTRY("refid", AttrKind_RefId)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("prot",  AttrKind_Prot)
[+] 		AXL_SL_HASH_TABLE_ENTRY("prot",  AttrKind_Prot)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("virt",  AttrKind_Virt)
[+] 		AXL_SL_HASH_TABLE_ENTRY("virt",  AttrKind_Virt)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("ambiguityscope", AttrKind_AmbiguityScope)
[+] 		AXL_SL_HASH_TABLE_ENTRY("ambiguityscope", AttrKind_AmbiguityScope)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("refid", AttrKind_RefId)
[+] 		AXL_SL_HASH_TABLE_ENTRY("refid", AttrKind_RefId)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("prot",  AttrKind_Prot)
[+] 		AXL_SL_HASH_TABLE_ENTRY("prot",  AttrKind_Prot)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("virt",  AttrKind_Virt)
[+] 		AXL_SL_HASH_TABLE_ENTRY("virt",  AttrKind_Virt)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("refid",    AttrKind_RefId)
[+] 		AXL_SL_HASH_TABLE_ENTRY("refid",    AttrKind_RefId)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("importid", AttrKind_ImportId)
[+] 		AXL_SL_HASH_TABLE_ENTRY("importid", AttrKind_ImportId)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("prot",     AttrKind_Prot)
[+] 		AXL_SL_HASH_TABLE_ENTRY("prot",     AttrKind_Prot)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("virt",     AttrKind_Virt)
[+] 		AXL_SL_HASH_TABLE_ENTRY("virt",     AttrKind_Virt)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	RefType ()
[+] 	RefType()
[-] 	create (
[+] 	create(
[-] 		sl::List <Ref>* list,
[+] 		sl::List<Ref>* list,
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 		m_ref->m_text.append (string, length);
[+] 		m_ref->m_text.append(string, length);
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("header",      ElemKind_Header)
[+] 		AXL_SL_HASH_TABLE_ENTRY("header",      ElemKind_Header)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("description", ElemKind_Description)
[+] 		AXL_SL_HASH_TABLE_ENTRY("description", ElemKind_Description)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("memberdef",   ElemKind_MemberDef)
[+] 		AXL_SL_HASH_TABLE_ENTRY("memberdef",   ElemKind_MemberDef)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("kind", AttrKind_Kind)
[+] 		AXL_SL_HASH_TABLE_ENTRY("kind", AttrKind_Kind)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	SectionDefType ()
[+] 	SectionDefType()
[-] 	create (
[+] 	create(
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("templateparamlist",    ElemKind_TemplateParamList)
[+] 		AXL_SL_HASH_TABLE_ENTRY("templateparamlist",    ElemKind_TemplateParamList)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("type",                 ElemKind_Type)
[+] 		AXL_SL_HASH_TABLE_ENTRY("type",                 ElemKind_Type)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("definition",           ElemKind_Definition)
[+] 		AXL_SL_HASH_TABLE_ENTRY("definition",           ElemKind_Definition)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("argsstring",           ElemKind_ArgString)
[+] 		AXL_SL_HASH_TABLE_ENTRY("argsstring",           ElemKind_ArgString)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("name",                 ElemKind_Name)
[+] 		AXL_SL_HASH_TABLE_ENTRY("name",                 ElemKind_Name)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("read",                 ElemKind_Read)
[+] 		AXL_SL_HASH_TABLE_ENTRY("read",                 ElemKind_Read)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("write",                ElemKind_Write)
[+] 		AXL_SL_HASH_TABLE_ENTRY("write",                ElemKind_Write)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("bitfield",             ElemKind_BitField)
[+] 		AXL_SL_HASH_TABLE_ENTRY("bitfield",             ElemKind_BitField)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("reimplements",         ElemKind_Reimplements)
[+] 		AXL_SL_HASH_TABLE_ENTRY("reimplements",         ElemKind_Reimplements)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("reimplementedby",      ElemKind_ReimplementedBy)
[+] 		AXL_SL_HASH_TABLE_ENTRY("reimplementedby",      ElemKind_ReimplementedBy)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("param",                ElemKind_Param)
[+] 		AXL_SL_HASH_TABLE_ENTRY("param",                ElemKind_Param)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("enumvalue",            ElemKind_EnumValue)
[+] 		AXL_SL_HASH_TABLE_ENTRY("enumvalue",            ElemKind_EnumValue)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("initializer",          ElemKind_Initializer)
[+] 		AXL_SL_HASH_TABLE_ENTRY("initializer",          ElemKind_Initializer)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("exceptions",           ElemKind_Exceptions)
[+] 		AXL_SL_HASH_TABLE_ENTRY("exceptions",           ElemKind_Exceptions)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("briefdescription",     ElemKind_BriefDescription)
[+] 		AXL_SL_HASH_TABLE_ENTRY("briefdescription",     ElemKind_BriefDescription)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("detaileddescription",  ElemKind_DetailedDescription)
[+] 		AXL_SL_HASH_TABLE_ENTRY("detaileddescription",  ElemKind_DetailedDescription)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("inbodydescription",    ElemKind_InBodyDescription)
[+] 		AXL_SL_HASH_TABLE_ENTRY("inbodydescription",    ElemKind_InBodyDescription)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("location",             ElemKind_Location)
[+] 		AXL_SL_HASH_TABLE_ENTRY("location",             ElemKind_Location)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("references",           ElemKind_References)
[+] 		AXL_SL_HASH_TABLE_ENTRY("references",           ElemKind_References)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("referencedby",         ElemKind_ReferencedBy)
[+] 		AXL_SL_HASH_TABLE_ENTRY("referencedby",         ElemKind_ReferencedBy)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("modifiers",            ElemKind_Modifiers)
[+] 		AXL_SL_HASH_TABLE_ENTRY("modifiers",            ElemKind_Modifiers)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("includes",             ElemKind_Includes)
[+] 		AXL_SL_HASH_TABLE_ENTRY("includes",             ElemKind_Includes)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("kind",           AttrKind_Kind)
[+] 		AXL_SL_HASH_TABLE_ENTRY("kind",           AttrKind_Kind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("id",             AttrKind_Id)
[+] 		AXL_SL_HASH_TABLE_ENTRY("id",             AttrKind_Id)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("prot",           AttrKind_Prot)
[+] 		AXL_SL_HASH_TABLE_ENTRY("prot",           AttrKind_Prot)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("static",         AttrKind_Static)
[+] 		AXL_SL_HASH_TABLE_ENTRY("static",         AttrKind_Static)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("const",          AttrKind_Const)
[+] 		AXL_SL_HASH_TABLE_ENTRY("const",          AttrKind_Const)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("explicit",       AttrKind_Explicit)
[+] 		AXL_SL_HASH_TABLE_ENTRY("explicit",       AttrKind_Explicit)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("inline",         AttrKind_Inline)
[+] 		AXL_SL_HASH_TABLE_ENTRY("inline",         AttrKind_Inline)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("virt",           AttrKind_Virtual)
[+] 		AXL_SL_HASH_TABLE_ENTRY("virt",           AttrKind_Virtual)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("volatile",       AttrKind_Volatile)
[+] 		AXL_SL_HASH_TABLE_ENTRY("volatile",       AttrKind_Volatile)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("mutable",        AttrKind_Mutable)
[+] 		AXL_SL_HASH_TABLE_ENTRY("mutable",        AttrKind_Mutable)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("readable",       AttrKind_Readable)
[+] 		AXL_SL_HASH_TABLE_ENTRY("readable",       AttrKind_Readable)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("writable",       AttrKind_Writeable)
[+] 		AXL_SL_HASH_TABLE_ENTRY("writable",       AttrKind_Writeable)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("initonly",       AttrKind_InitOnly)
[+] 		AXL_SL_HASH_TABLE_ENTRY("initonly",       AttrKind_InitOnly)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("settable",       AttrKind_Settable)
[+] 		AXL_SL_HASH_TABLE_ENTRY("settable",       AttrKind_Settable)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("gettable",       AttrKind_Gettable)
[+] 		AXL_SL_HASH_TABLE_ENTRY("gettable",       AttrKind_Gettable)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("final",          AttrKind_Final)
[+] 		AXL_SL_HASH_TABLE_ENTRY("final",          AttrKind_Final)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("sealed",         AttrKind_Sealed)
[+] 		AXL_SL_HASH_TABLE_ENTRY("sealed",         AttrKind_Sealed)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("new",            AttrKind_New)
[+] 		AXL_SL_HASH_TABLE_ENTRY("new",            AttrKind_New)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("add",            AttrKind_Add)
[+] 		AXL_SL_HASH_TABLE_ENTRY("add",            AttrKind_Add)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("remove",         AttrKind_Remove)
[+] 		AXL_SL_HASH_TABLE_ENTRY("remove",         AttrKind_Remove)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("raise",          AttrKind_Raise)
[+] 		AXL_SL_HASH_TABLE_ENTRY("raise",          AttrKind_Raise)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("optional",       AttrKind_Optional)
[+] 		AXL_SL_HASH_TABLE_ENTRY("optional",       AttrKind_Optional)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("required",       AttrKind_Required)
[+] 		AXL_SL_HASH_TABLE_ENTRY("required",       AttrKind_Required)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("accessor",       AttrKind_Accessor)
[+] 		AXL_SL_HASH_TABLE_ENTRY("accessor",       AttrKind_Accessor)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("attribute",      AttrKind_Attribute)
[+] 		AXL_SL_HASH_TABLE_ENTRY("attribute",      AttrKind_Attribute)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("property",       AttrKind_Property)
[+] 		AXL_SL_HASH_TABLE_ENTRY("property",       AttrKind_Property)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("readonly",       AttrKind_ReadOnly)
[+] 		AXL_SL_HASH_TABLE_ENTRY("readonly",       AttrKind_ReadOnly)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("bound",          AttrKind_Bound)
[+] 		AXL_SL_HASH_TABLE_ENTRY("bound",          AttrKind_Bound)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("removable",      AttrKind_Removable)
[+] 		AXL_SL_HASH_TABLE_ENTRY("removable",      AttrKind_Removable)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("contrained",     AttrKind_Contrained)
[+] 		AXL_SL_HASH_TABLE_ENTRY("contrained",     AttrKind_Contrained)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("transient",      AttrKind_Transient)
[+] 		AXL_SL_HASH_TABLE_ENTRY("transient",      AttrKind_Transient)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("maybevoid",      AttrKind_MaybeVoid)
[+] 		AXL_SL_HASH_TABLE_ENTRY("maybevoid",      AttrKind_MaybeVoid)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("maybedefault",   AttrKind_MaybeDefault)
[+] 		AXL_SL_HASH_TABLE_ENTRY("maybedefault",   AttrKind_MaybeDefault)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("maybeambiguous", AttrKind_MaybeAmbiguos)
[+] 		AXL_SL_HASH_TABLE_ENTRY("maybeambiguous", AttrKind_MaybeAmbiguos)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	MemberDefType ()
[+] 	MemberDefType()
[-] 	create (
[+] 	create(
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("file",      AttrKind_File)
[+] 		AXL_SL_HASH_TABLE_ENTRY("file",      AttrKind_File)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("line",      AttrKind_Line)
[+] 		AXL_SL_HASH_TABLE_ENTRY("line",      AttrKind_Line)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("column",    AttrKind_Column)
[+] 		AXL_SL_HASH_TABLE_ENTRY("column",    AttrKind_Column)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("bodyfile",  AttrKind_BodyFile)
[+] 		AXL_SL_HASH_TABLE_ENTRY("bodyfile",  AttrKind_BodyFile)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("bodystart", AttrKind_BodyStart)
[+] 		AXL_SL_HASH_TABLE_ENTRY("bodystart", AttrKind_BodyStart)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("bodyend",   AttrKind_BodyEnd)
[+] 		AXL_SL_HASH_TABLE_ENTRY("bodyend",   AttrKind_BodyEnd)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	create (
[+] 	create(
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("title",    ElemKind_Title)
[+] 		AXL_SL_HASH_TABLE_ENTRY("title",    ElemKind_Title)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("para",     ElemKind_Para)
[+] 		AXL_SL_HASH_TABLE_ENTRY("para",     ElemKind_Para)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("sect1",    ElemKind_Sect1)
[+] 		AXL_SL_HASH_TABLE_ENTRY("sect1",    ElemKind_Sect1)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("internal", ElemKind_Internal)
[+] 		AXL_SL_HASH_TABLE_ENTRY("internal", ElemKind_Internal)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	create (
[+] 	create(
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("title",    ElemKind_Title)
[+] 		AXL_SL_HASH_TABLE_ENTRY("title",    ElemKind_Title)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("para",     ElemKind_Para)
[+] 		AXL_SL_HASH_TABLE_ENTRY("para",     ElemKind_Para)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("sect1",    ElemKind_Sect1)
[+] 		AXL_SL_HASH_TABLE_ENTRY("sect1",    ElemKind_Sect1)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("sect2",    ElemKind_Sect2)
[+] 		AXL_SL_HASH_TABLE_ENTRY("sect2",    ElemKind_Sect2)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("sect3",    ElemKind_Sect3)
[+] 		AXL_SL_HASH_TABLE_ENTRY("sect3",    ElemKind_Sect3)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("sect4",    ElemKind_Sect4)
[+] 		AXL_SL_HASH_TABLE_ENTRY("sect4",    ElemKind_Sect4)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("internal", ElemKind_Internal)
[+] 		AXL_SL_HASH_TABLE_ENTRY("internal", ElemKind_Internal)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("id", AttrKind_Id)
[+] 		AXL_SL_HASH_TABLE_ENTRY("id", AttrKind_Id)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	create (
[+] 	create(
[-] 		sl::List <DocBlock>* list,
[+] 		sl::List<DocBlock>* list,
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("name",                ElemKind_Name)
[+] 		AXL_SL_HASH_TABLE_ENTRY("name",                ElemKind_Name)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("initializer",         ElemKind_Initializer)
[+] 		AXL_SL_HASH_TABLE_ENTRY("initializer",         ElemKind_Initializer)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("briefdescription",    ElemKind_BriefDescription)
[+] 		AXL_SL_HASH_TABLE_ENTRY("briefdescription",    ElemKind_BriefDescription)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("detaileddescription", ElemKind_DetailedDescription)
[+] 		AXL_SL_HASH_TABLE_ENTRY("detaileddescription", ElemKind_DetailedDescription)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("id",   AttrKind_Id)
[+] 		AXL_SL_HASH_TABLE_ENTRY("id",   AttrKind_Id)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("prot", AttrKind_Prot)
[+] 		AXL_SL_HASH_TABLE_ENTRY("prot", AttrKind_Prot)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	EnumValueType ()
[+] 	EnumValueType()
[-] 	create (
[+] 	create(
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("param", ElemKind_Param)
[+] 		AXL_SL_HASH_TABLE_ENTRY("param", ElemKind_Param)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	sl::List <Param>* m_list;
[+] 	sl::List<Param>* m_list;
[-] 	TemplateParamListType ()
[+] 	TemplateParamListType()
[-] 	create (
[+] 	create(
[-] 		sl::List <Param>* list,
[+] 		sl::List<Param>* list,
[-] 	create (
[+] 	create(
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("type",             ElemKind_Type)
[+] 		AXL_SL_HASH_TABLE_ENTRY("type",             ElemKind_Type)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("declname",         ElemKind_DeclName)
[+] 		AXL_SL_HASH_TABLE_ENTRY("declname",         ElemKind_DeclName)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("defname",          ElemKind_DefName)
[+] 		AXL_SL_HASH_TABLE_ENTRY("defname",          ElemKind_DefName)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("array",            ElemKind_Array)
[+] 		AXL_SL_HASH_TABLE_ENTRY("array",            ElemKind_Array)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("defval",           ElemKind_DefVal)
[+] 		AXL_SL_HASH_TABLE_ENTRY("defval",           ElemKind_DefVal)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("typeconstraint",   ElemKind_TypeConstraint)
[+] 		AXL_SL_HASH_TABLE_ENTRY("typeconstraint",   ElemKind_TypeConstraint)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("briefdescription", ElemKind_BriefDescription)
[+] 		AXL_SL_HASH_TABLE_ENTRY("briefdescription", ElemKind_BriefDescription)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	ParamType ()
[+] 	ParamType()
[-] 	create (
[+] 	create(
[-] 		sl::List <Param>* list,
[+] 		sl::List<Param>* list,
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("ref", ElemKind_Ref)
[+] 		AXL_SL_HASH_TABLE_ENTRY("ref", ElemKind_Ref)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	LinkedTextType ()
[+] 	LinkedTextType()
[-] 	create (
[+] 	create(
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 		m_refText->m_text.append (string, length);
[+] 		m_refText->m_text.append(string, length);
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("refid",    AttrKind_RefId)
[+] 		AXL_SL_HASH_TABLE_ENTRY("refid",    AttrKind_RefId)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("kindref",  AttrKind_KindRef)
[+] 		AXL_SL_HASH_TABLE_ENTRY("kindref",  AttrKind_KindRef)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("external", AttrKind_External)
[+] 		AXL_SL_HASH_TABLE_ENTRY("external", AttrKind_External)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("tooltip",  AttrKind_Tooltip)
[+] 		AXL_SL_HASH_TABLE_ENTRY("tooltip",  AttrKind_Tooltip)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	RefTextType ()
[+] 	RefTextType()
[-] 	create (
[+] 	create(
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 		m_refText->m_text.append (string, length);
[+] 		m_refText->m_text.append(string, length);
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("ref",        ElemKind_Ref)
[+] 		AXL_SL_HASH_TABLE_ENTRY("ref",        ElemKind_Ref)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("anchor",     ElemKind_Anchor)
[+] 		AXL_SL_HASH_TABLE_ENTRY("anchor",     ElemKind_Anchor)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("image",      ElemKind_Image)
[+] 		AXL_SL_HASH_TABLE_ENTRY("image",      ElemKind_Image)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("simplesect", ElemKind_SimpleSect)
[+] 		AXL_SL_HASH_TABLE_ENTRY("simplesect", ElemKind_SimpleSect)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	DocParaType ()
[+] 	DocParaType()
[-] 	create (
[+] 	create(
[-] 		sl::List <DocBlock>* blockList,
[+] 		sl::List<DocBlock>* blockList,
[-] 	onStartElement (
[+] 	onStartElement(
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 		m_textBlock->m_text.append (string, length);
[+] 		m_textBlock->m_text.append(string, length);
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("refid",    AttrKind_RefId)
[+] 		AXL_SL_HASH_TABLE_ENTRY("refid",    AttrKind_RefId)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("kindref",  AttrKind_KindRef)
[+] 		AXL_SL_HASH_TABLE_ENTRY("kindref",  AttrKind_KindRef)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("external", AttrKind_External)
[+] 		AXL_SL_HASH_TABLE_ENTRY("external", AttrKind_External)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	DocRefTextType ()
[+] 	DocRefTextType()
[-] 	create (
[+] 	create(
[-] 		sl::List <DocBlock>* list,
[+] 		sl::List<DocBlock>* list,
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 		m_refBlock->m_text.append (string, length);
[+] 		m_refBlock->m_text.append(string, length);
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("id",    AttrKind_Id)
[+] 		AXL_SL_HASH_TABLE_ENTRY("id",    AttrKind_Id)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	DocAnchorType ()
[+] 	DocAnchorType()
[-] 	create (
[+] 	create(
[-] 		sl::List <DocBlock>* list,
[+] 		sl::List<DocBlock>* list,
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 		m_anchorBlock->m_text.append (string, length);
[+] 		m_anchorBlock->m_text.append(string, length);
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("type",    AttrKind_Type)
[+] 		AXL_SL_HASH_TABLE_ENTRY("type",    AttrKind_Type)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("name",    AttrKind_Name)
[+] 		AXL_SL_HASH_TABLE_ENTRY("name",    AttrKind_Name)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("width",   AttrKind_Width)
[+] 		AXL_SL_HASH_TABLE_ENTRY("width",   AttrKind_Width)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("height",  AttrKind_Height)
[+] 		AXL_SL_HASH_TABLE_ENTRY("height",  AttrKind_Height)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	DocImageType ()
[+] 	DocImageType()
[-] 	create (
[+] 	create(
[-] 		sl::List <DocBlock>* list,
[+] 		sl::List<DocBlock>* list,
[-] 	onCharacterData (
[+] 	onCharacterData(
[-] 		m_imageBlock->m_text.append (string, length);
[+] 		m_imageBlock->m_text.append(string, length);
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (ElemKindMap, ElemKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(ElemKindMap, ElemKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("para", ElemKind_Para)
[+] 		AXL_SL_HASH_TABLE_ENTRY("para", ElemKind_Para)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	AXL_SL_BEGIN_STRING_HASH_TABLE (AttrKindMap, AttrKind)
[+] 	AXL_SL_BEGIN_STRING_HASH_TABLE(AttrKindMap, AttrKind)
[-] 		AXL_SL_HASH_TABLE_ENTRY ("kind", AttrKind_Kind)
[+] 		AXL_SL_HASH_TABLE_ENTRY("kind", AttrKind_Kind)
[-] 	AXL_SL_END_HASH_TABLE ()
[+] 	AXL_SL_END_HASH_TABLE()
[-] 	create (
[+] 	create(
[-] 		sl::List <DocBlock>* list,
[+] 		sl::List<DocBlock>* list,
[-] 	onStartElement (
[+] 	onStartElement(
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\Generator.h
----------------------
[-] 	Generator (const CmdLine* cmdLine)
[+] 	Generator(const CmdLine* cmdLine)
[-] 	prepare (
[+] 	prepare(
[-] 	generate (
[+] 	generate(
[-] 	generate (
[+] 	generate(
[-] 		prepare (module, globalNamespace);
[+] 		prepare(module, globalNamespace);
[-] 		return generate (targetFileName, frameFileName);
[+] 		return generate(targetFileName, frameFileName);
[-] 	includeFile_lua (lua_State* h);
[+] 	includeFile_lua(lua_State* h);
[-] 	generateFile_lua (lua_State* h);
[+] 	generateFile_lua(lua_State* h);
[-] 	processFile (
[+] 	processFile(
----------------------
27/02/2019 18:01:53 - C:\Projects\repos\ioninja\doxyrest\src\Module.h
----------------------
[-] createPath (
[+] createPath(
[-] 	RefText ()
[+] 	RefText()
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	sl::List <RefText> m_refTextList;
[+] 	sl::List<RefText> m_refTextList;
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	normalize ();
[+] 	normalize();
[-] 	sl::List <DocBlock> m_childBlockList;
[+] 	sl::List<DocBlock> m_childBlockList;
[-] 	virtual ~DocBlock ()
[+] 	virtual ~DocBlock()
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	luaExportMembers (lua::LuaState* luaState);
[+] 	luaExportMembers(lua::LuaState* luaState);
[-] 	DocRefBlock ()
[+] 	DocRefBlock()
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	sl::List <DocBlock> m_docBlockList;
[+] 	sl::List<DocBlock> m_docBlockList;
[-] 	bool isEmpty ()
[+] 	bool isEmpty()
[-] 		return m_title.isEmpty () && m_docBlockList.isEmpty ();
[+] 		return m_title.isEmpty() && m_docBlockList.isEmpty();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	bool isEmpty ()
[+] 	bool isEmpty()
[-] 		return m_file.isEmpty ();
[+] 		return m_file.isEmpty();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	EnumValue ()
[+] 	EnumValue()
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] getMemberFlagString (MemberFlag flag);
[+] getMemberFlagString(MemberFlag flag);
[-] getMemberFlagString (uint_t flags);
[+] getMemberFlagString(uint_t flags);
[-] 	sl::BoxList <sl::String> m_importList;
[+] 	sl::BoxList<sl::String> m_importList;
[-] 	sl::List <Param> m_paramList;
[+] 	sl::List<Param> m_paramList;
[-] 	sl::List <Param> m_templateParamList;
[+] 	sl::List<Param> m_templateParamList;
[-] 	sl::List <Param> m_templateSpecParamList;
[+] 	sl::List<Param> m_templateSpecParamList;
[-] 	sl::List <EnumValue> m_enumValueList;
[+] 	sl::List<EnumValue> m_enumValueList;
[-] 	Member ();
[+] 	Member();
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	preparePath ()
[+] 	preparePath()
[-] 		if (m_path.isEmpty ())
[+] 		if (m_path.isEmpty())
[-] 			m_path = createPath (m_name, m_parentNamespace);
[+] 			m_path = createPath(m_name, m_parentNamespace);
[-] 	Ref ()
[+] 	Ref()
[-] 	hash () const
[+] 	hash() const
[-] 		size_t hash0 = sl::djb2 (m_id, m_id.getLength ());
[+] 		size_t hash0 = sl::djb2(m_id, m_id.getLength());
[-] 		return sl::djb2 (hash0, m_text, m_text.getLength ());
[+] 		return sl::djb2(hash0, m_text, m_text.getLength());
[-] 	isEqual (const Ref& ref) const
[+] 	isEqual(const Ref& ref) const
[-] 	sl::BoxList <sl::String> m_importList;
[+] 	sl::BoxList<sl::String> m_importList;
[-] 	sl::List <Param> m_templateParamList;
[+] 	sl::List<Param> m_templateParamList;
[-] 	sl::List <Param> m_templateSpecParamList;
[+] 	sl::List<Param> m_templateSpecParamList;
[-] 	sl::List <Member> m_memberList;
[+] 	sl::List<Member> m_memberList;
[-] 	sl::Array <Member*> m_groupFootnoteArray;
[+] 	sl::Array<Member*> m_groupFootnoteArray;
[-] 	sl::List <Ref> m_baseRefList;
[+] 	sl::List<Ref> m_baseRefList;
[-] 	sl::List <Ref> m_derivedRefList;
[+] 	sl::List<Ref> m_derivedRefList;
[-] 	sl::List <Ref> m_innerRefList;
[+] 	sl::List<Ref> m_innerRefList;
[-] 	sl::Array <Compound*> m_baseTypeArray;
[+] 	sl::Array<Compound*> m_baseTypeArray;
[-] 	sl::Array <Compound*> m_derivedTypeArray_doxy; // explicitly specified in doxy
[+] 	sl::Array<Compound*> m_derivedTypeArray_doxy; // explicitly specified in doxy
[-] 	sl::Array <Compound*> m_derivedTypeArray_auto; // auto-generated
[+] 	sl::Array<Compound*> m_derivedTypeArray_auto; // auto-generated
[-] 	sl::Array <ProtectionKind> m_baseTypeProtectionArray;
[+] 	sl::Array<ProtectionKind> m_baseTypeProtectionArray;
[-] 	sl::Array <Compound*> m_subPageArray;
[+] 	sl::Array<Compound*> m_subPageArray;
[-] 	Compound ();
[+] 	Compound();
[-] 	isMemberGroupAllowed ()
[+] 	isMemberGroupAllowed()
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	unqualifyName ();
[+] 	unqualifyName();
[-] 	unspecializeName ();
[+] 	unspecializeName();
[-] 	createTemplateSpecParam (const sl::StringRef& name);
[+] 	createTemplateSpecParam(const sl::StringRef& name);
[-] 	preparePath ()
[+] 	preparePath()
[-] 		if (m_path.isEmpty ())
[+] 		if (m_path.isEmpty())
[-] 			m_path = createPath (m_name, m_parentNamespace);
[+] 			m_path = createPath(m_name, m_parentNamespace);
[-] 	sl::List <Compound> m_compoundList;
[+] 	sl::List<Compound> m_compoundList;
[-] 	sl::Array <Compound*> m_namespaceArray;
[+] 	sl::Array<Compound*> m_namespaceArray;
[-] 	sl::Array <Compound*> m_groupArray;
[+] 	sl::Array<Compound*> m_groupArray;
[-] 	sl::Array <Compound*> m_pageArray;
[+] 	sl::Array<Compound*> m_pageArray;
[-] 	sl::Array <Compound*> m_exampleArray;
[+] 	sl::Array<Compound*> m_exampleArray;
[-] 	sl::StringHashTable <Compound*> m_compoundMap;
[+] 	sl::StringHashTable<Compound*> m_compoundMap;
[-] 	sl::StringHashTable <Member*> m_memberMap;
[+] 	sl::StringHashTable<Member*> m_memberMap;
[-] 	sl::StringHashTable <EnumValue*> m_enumValueMap;
[+] 	sl::StringHashTable<EnumValue*> m_enumValueMap;
[-] 	sl::Array <Namespace*> m_groupArray;
[+] 	sl::Array<Namespace*> m_groupArray;
[-] 	sl::Array <Namespace*> m_namespaceArray;
[+] 	sl::Array<Namespace*> m_namespaceArray;
[-] 	sl::Array <Member*> m_enumArray;
[+] 	sl::Array<Member*> m_enumArray;
[-] 	sl::Array <Namespace*> m_structArray;
[+] 	sl::Array<Namespace*> m_structArray;
[-] 	sl::Array <Namespace*> m_unionArray;
[+] 	sl::Array<Namespace*> m_unionArray;
[-] 	sl::Array <Namespace*> m_classArray;
[+] 	sl::Array<Namespace*> m_classArray;
[-] 	sl::Array <Namespace*> m_interfaceArray;
[+] 	sl::Array<Namespace*> m_interfaceArray;
[-] 	sl::Array <Namespace*> m_protocolArray;
[+] 	sl::Array<Namespace*> m_protocolArray;
[-] 	sl::Array <Namespace*> m_exceptionArray;
[+] 	sl::Array<Namespace*> m_exceptionArray;
[-] 	sl::Array <Namespace*> m_serviceArray;
[+] 	sl::Array<Namespace*> m_serviceArray;
[-] 	sl::Array <Namespace*> m_singletonArray;
[+] 	sl::Array<Namespace*> m_singletonArray;
[-] 	sl::Array <Member*> m_typedefArray;
[+] 	sl::Array<Member*> m_typedefArray;
[-] 	sl::Array <Member*> m_variableArray;
[+] 	sl::Array<Member*> m_variableArray;
[-] 	sl::Array <Member*> m_functionArray;
[+] 	sl::Array<Member*> m_functionArray;
[-] 	sl::Array <Member*> m_propertyArray;
[+] 	sl::Array<Member*> m_propertyArray;
[-] 	sl::Array <Member*> m_eventArray;
[+] 	sl::Array<Member*> m_eventArray;
[-] 	sl::Array <Member*> m_aliasArray;
[+] 	sl::Array<Member*> m_aliasArray;
[-] 	sl::Array <Member*> m_defineArray;
[+] 	sl::Array<Member*> m_defineArray;
[-] 	sl::Array <Member*> m_footnoteArray;
[+] 	sl::Array<Member*> m_footnoteArray;
[-] 	sl::Array <Member*> m_constructorArray;
[+] 	sl::Array<Member*> m_constructorArray;
[-] 	NamespaceContents ()
[+] 	NamespaceContents()
[-] 	add (Compound* compound);
[+] 	add(Compound* compound);
[-] 	add (
[+] 	add(
[-] 	luaExportMembers (lua::LuaState* luaState);
[+] 	luaExportMembers(lua::LuaState* luaState);
[-] 	Namespace ()
[+] 	Namespace()
[-] 	luaExport (lua::LuaState* luaState)
[+] 	luaExport(lua::LuaState* luaState)
[-] 		ASSERT (m_compound);
[+] 		ASSERT(m_compound);
[-] 		m_compound->luaExport (luaState);
[+] 		m_compound->luaExport(luaState);
[-] 	sl::List <Namespace> m_namespaceList;
[+] 	sl::List<Namespace> m_namespaceList;
[-] 	clear ();
[+] 	clear();
[-] 	build (
[+] 	build(
[-] 	luaExport (lua::LuaState* luaState);
[+] 	luaExport(lua::LuaState* luaState);
[-] 	getGroupNamespace (
[+] 	getGroupNamespace(
[-] 	createMemberCompound (
[+] 	createMemberCompound(
[-] luaExportArray (
[+] luaExportArray(
[-] 	luaState->createTable (count);
[+] 	luaState->createTable(count);
[-] 		a [i]->luaExport (luaState);
[+] 		a[i]->luaExport(luaState);
[-] 		luaState->setArrayElement (i + 1); // lua arrays are 1-based
[+] 		luaState->setArrayElement(i + 1); // lua arrays are 1-based
[-] luaExportArray (
[+] luaExportArray(
[-] 	sl::Array <T*>& array
[+] 	sl::Array<T*>& array
[-] 	luaExportArray (luaState, array.cp (), array.getCount ());
[+] 	luaExportArray(luaState, array.cp(), array.getCount());
[-] luaExportList (
[+] luaExportList(
[-] 	sl::List <T>& list
[+] 	sl::List<T>& list
[-] 	luaState->createTable (list.getCount ());
[+] 	luaState->createTable(list.getCount());
[-] 	sl::Iterator <T> it = list.getHead ();
[+] 	sl::Iterator<T> it = list.getHead();
[-] 		it->luaExport (luaState);
[+] 		it->luaExport(luaState);
[-] 		luaState->setArrayElement (i);
[+] 		luaState->setArrayElement(i);
[-] luaExportStringList (
[+] luaExportStringList(
[-] 	sl::BoxList <sl::String>& list
[+] 	sl::BoxList<sl::String>& list
[-] 	luaState->createTable (list.getCount ());
[+] 	luaState->createTable(list.getCount());
[-] 	sl::BoxIterator <sl::String> it = list.getHead ();
[+] 	sl::BoxIterator<sl::String> it = list.getHead();
[-] 		luaState->setArrayElementString (i, *it);
[+] 		luaState->setArrayElementString(i, *it);
