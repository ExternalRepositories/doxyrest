<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='class' id='type_io_socketaddressresolver' language='Jancy'>
<compoundname>SocketAddressResolver</compoundname>

<sectiondef>
<memberdef kind='function' id='function_io_socketaddressresolver_construct'>
<functionkind>construct</functionkind>
<name>construct</name>
<type>void</type>
<argsstring>(io.SocketAddressResolver safe* this)</argsstring>
<location file='io_SocketAddressResolver.jnc' line='192' col='2'/>
</memberdef>
<memberdef kind='function' id='function_io_socketaddressresolver_destruct'>
<functionkind>destruct</functionkind>
<name>destruct</name>
<type>void</type>
<argsstring>(io.SocketAddressResolver safe* this)</argsstring>
<location file='io_SocketAddressResolver.jnc' line='193' col='2'/>
</memberdef>
</sectiondef>

<sectiondef>
<memberdef kind='variable' id='struct_member_io_socketaddressresolver_iface_m_syncid'>
<name>m_syncId</name>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<detaileddescription>
<para>Holds the synchronization ID for the socket address resolver [#f3]_.</para>
</detaileddescription>
<location file='io_SocketAddressResolver.jnc' line='190' col='9'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddressresolver_resolve'>
<functionkind>named-function</functionkind>
<name>resolve</name>
<type>bool errorcode</type>
<argsstring>(io.SocketAddressResolver safe* this, char const* name, io.AddressFamily family AddressFamily . Undefined)</argsstring>
<param>
<declname>name</declname>
<type>char const*</type>
<array></array>
</param>
<param>
<declname>family</declname>
<type><ref refid="type_io_addressfamily">io.AddressFamily</ref></type>
<array></array>
<defval>AddressFamily . Undefined</defval>
</param>
<detaileddescription>
<para>Starts a new resolve request, bumps ``m_syncId`` and assigns it to the new request.

Returns ``true`` on success. If a resolve request could not be started, IO error supplied by operating system is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_SocketAddressResolver.jnc' line='201' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddressresolver_cancel'>
<functionkind>named-function</functionkind>
<name>cancel</name>
<type>bool</type>
<argsstring>(io.SocketAddressResolver safe* this, uint_t syncId)</argsstring>
<param>
<declname>syncId</declname>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<array></array>
</param>
<detaileddescription>
<para>Cancels an on-going resolve requests identified by ``syncId``, does nothing is ``syncId`` request is not found.</para>
</detaileddescription>
<location file='io_SocketAddressResolver.jnc' line='210' col='7'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddressresolver_cancelall'>
<functionkind>named-function</functionkind>
<name>cancelAll</name>
<type>void</type>
<argsstring>(io.SocketAddressResolver safe* this)</argsstring>
<detaileddescription>
<para>Cancels all on-going resolve requests.

Sometimes it may be convenient to use *disposable* pattern to ensure timely invokation of ``cancelAll`` [#f2]_.</para>
</detaileddescription>
<location file='io_SocketAddressResolver.jnc' line='218' col='7'/>
</memberdef>

<memberdef kind='alias' id='alias_io_socketaddressresolver_dispose'>
<name>dispose</name>
<initializer>= cancelAll</initializer>
<detaileddescription>
<para>Effectively makes ``io.SocketAddressResolver`` a *disposable* class [#f2]_.</para>
</detaileddescription>
<location file='io_SocketAddressResolver.jnc' line='224' col='8'/>
</memberdef>

<memberdef kind='event' id='struct_member_io_socketaddressresolver_iface_m_onresolverevent'>
<name>m_onResolverEvent</name>
<type>multicast</type>
<argsstring>(io.SocketAddressResolverEventParams const* params)</argsstring>
<param>
<declname>params</declname>
<type><ref refid="type_io_socketaddressresolvereventparams">io.SocketAddressResolverEventParams</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>This event is fired whenever an event occurs on the socket address resolver.

For the list of possible events, refer to `io.SocketAddressResolverEventCode` enumeration.

Event handler receives a single argument of type `io.SocketAddressResolverEventParams` which holds parameters of the particular event [#f3]_.</para>
</detaileddescription>
<location file='io_SocketAddressResolver.jnc' line='234' col='8'/>
</memberdef>

</sectiondef>
<sectiondef>
<memberdef kind='footnote'>
<name>f1</name>
<detaileddescription>
<para>|footnote-errorcode|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f2</name>
<detaileddescription>
<para>|footnote-disposable|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f3</name>
<detaileddescription>
<para>|footnote-sync-id|</para>
</detaileddescription>
</memberdef>
</sectiondef>
<includes>io_base.jncx</includes>
<includes>io_SocketAddressResolver.jncx</includes>
<briefdescription><para>This class provides an asynchrounous interface for resolving host names into socket addresses.</para></briefdescription>
<detaileddescription>
<para>In the most general case conversion of a host name such as ``tibbo.com`` into an ``IP`` requires sending and receiving network packets and, therefore, may take substantial time. Doing this operation synchronoulsy, while acceptable in many cases, is not really optimal for interactive GUI applications where we do not want to have moments of *non-responsiveness*. For such cases using ``io.SocketAddressResolver`` may be a better approach.

A typical sequence of steps when resolving a host address looks like this:

* Assign your event handler using ``m_onResolverEvent`` (you would probably also want to *schedule* your event handler to be run in particular environment, e.g. in specific thread)
* Start one or more resolve requests with ``resolve`` method;
* Wait until ``ResolveCompleted`` or ``ResolveError`` event;
* Cancel all pending resolve requests with ``cancelAll`` method.

.. rubric:: Sample code:

.. ref-code-block::

	class MyDialog
	{
		// ...

		io.SocketAddressResolver m_resolver;

		construct ();

		resolve (char const* hostName);
		onResolverEvent (`io.SocketAddressResolverEventParams` const* params);
	}

	MyDialog.construct ()
	{
		// ...
		m_socket.m_onSocketEvent += onSocketEvent @ g_mainThreadScheduler;
	}

	MyDialog.resolve (char const* hostName)
	{
		bool result = try m_resolver.resolve (hostName);

		if (!result)
		{
			// handle the error...
		}
	}

	MyDialog.onResolverEvent (`io.SocketAddressResolverEventParams` const* params)
	{
		if (params.m_syncId != m_resolver.m_syncId) // late event
			return;

		switch (params.m_code)
		{
		case `io.SocketAddressResolverEventCode.ResolveError`:
			// handle error (extended info is at: params.m_error)...
			break;

		case `io.SocketAddressResolverEventCode.ResolveCompleted`:
			// hostname successfully resolved (result is at: params.m_addressTable)...
			break;
		}
	}</para>
<para><simplesect kind='see'><para>`io.SocketAddressResolverEventParams`, `io.SocketAddressResolverEventCode`, `io.SocketAddress`</para></simplesect></para>
</detaileddescription>
<location file='io_SocketAddressResolver.jnc' line='184' col='14'/>
</compounddef>
</doxygen>
