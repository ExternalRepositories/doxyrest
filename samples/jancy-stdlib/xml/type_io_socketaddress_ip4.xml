<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='struct' id='type_io_socketaddress_ip4' language='Jancy'>
<compoundname>SocketAddress_ip4</compoundname>

<sectiondef>
<memberdef kind='variable' id='struct_member_io_socketaddress_ip4_m_family'>
<name>m_family</name>
<type><ref refid="type_io_addressfamily">io.AddressFamily</ref></type>
<detaileddescription>
<para>Holds the address family of the socket address; should be set to `io.AddressFamily.Ip4`.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='190' col='16'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_socketaddress_ip4_m_port'>
<name>m_port</name>
<type>bigendian unsigned short</type>
<detaileddescription>
<para>Holds the number of ``TCP`` or ``UDP`` port. There is no need to change the byte order of the port before assignment -- this field is already declared as ``bigendian`` so all the necessary conversions will happen automatically.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='196' col='21'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_socketaddress_ip4_m_address'>
<name>m_address</name>
<type><ref refid="type_io_address_ip4">io.Address_ip4</ref></type>
<detaileddescription>
<para>Holds ``IP4`` address as `io.Address_ip4`.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='202' col='14'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_socketaddress_ip4_m_padding'>
<name>m_padding</name>
<type>char</type>
<argsstring>[]</argsstring>
<detaileddescription>
<para>Extra padding to ensure binary compatibility wiht ``sockaddr_in``.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='208' col='7'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddress_ip4_isequal'>
<functionkind>named-function</functionkind>
<name>isEqual</name>
<type>bool</type>
<argsstring>(io.SocketAddress_ip4 safe* this, io.SocketAddress_ip4 const* address)</argsstring>
<param>
<declname>address</declname>
<type><ref refid="type_io_socketaddress_ip4">io.SocketAddress_ip4</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>Checks two ``IP4`` socket addresses for *equality*; returns ``true`` if addresses are equal and ``false`` otherwise.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='214' col='7'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddress_ip4_ismatch'>
<functionkind>named-function</functionkind>
<name>isMatch</name>
<type>bool</type>
<argsstring>(io.SocketAddress_ip4 safe* this, io.SocketAddress_ip4 const* filterAddress)</argsstring>
<param>
<declname>filterAddress</declname>
<type><ref refid="type_io_socketaddress_ip4">io.SocketAddress_ip4</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>Checks two ``IP4`` socket addresses for *matching*. The term matching requires some explanation.

Matching could be described as a non-strict equality check. We may decide to only check *port* for equality and ignore the address. To do so, set ``m_address`` field of ``filter`` argument to ``0``.

Or the other way around -- only check *address* and ignore port -- set ``m_port`` field of ``filter`` argument to ``0``.

Returns ``true`` if addresses *match* and ``false`` otherwise.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='226' col='7'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddress_ip4_parse'>
<functionkind>named-function</functionkind>
<name>parse</name>
<type>bool errorcode</type>
<argsstring>(io.SocketAddress_ip4 safe* this, char const* string)</argsstring>
<param>
<declname>string</declname>
<type>char const*</type>
<array></array>
</param>
<detaileddescription>
<para>Constructs the address from a string representation in ``string`` argument.

Returns ``true`` if address string was parsed successfully. Otherwise, sets the description of parsing error and returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='234' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddress_ip4_getstring' const='yes'>
<functionkind>named-function</functionkind>
<name>getString</name>
<type>char const*</type>
<argsstring>(io.SocketAddress_ip4 safe const* this)</argsstring>
<detaileddescription>
<para>Creates and returns a string representation of the address.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='240' col='14'/>
</memberdef>

</sectiondef>
<sectiondef>
<memberdef kind='footnote'>
<name>f1</name>
<detaileddescription>
<para>|footnote-errorcode|</para>
</detaileddescription>
</memberdef>
</sectiondef>
<includes>io_base.jncx</includes>
<includes>io_SocketAddress.jnc</includes>
<briefdescription><para>This struct holds information about ``IP4`` address in the form suitable for socket communications.</para></briefdescription>
<detaileddescription>
<para>On the binary level this structure directly maps to ``sockaddr_in``.</para>
<para><simplesect kind='see'><para>`io.Address_ip4`, `io.Socket`, `io.SocketAddressResolver`</para></simplesect></para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='184' col='8'/>
</compounddef>
</doxygen>
