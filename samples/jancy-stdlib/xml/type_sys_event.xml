<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='class' id='type_sys_event' language='Jancy'>
<compoundname>Event</compoundname>

<sectiondef>
<memberdef kind='function' id='function_sys_event_construct'>
<functionkind>construct</functionkind>
<name>construct</name>
<type>void</type>
<argsstring>(sys.Event safe* this)</argsstring>
<location file='sys_Event.jnc' line='57' col='2'/>
</memberdef>
<memberdef kind='function' id='function_sys_event_destruct'>
<functionkind>destruct</functionkind>
<name>destruct</name>
<type>void</type>
<argsstring>(sys.Event safe* this)</argsstring>
<location file='sys_Event.jnc' line='58' col='2'/>
</memberdef>
</sectiondef>

<sectiondef>
<memberdef kind='function' id='function_sys_event_signal'>
<functionkind>named-function</functionkind>
<name>signal</name>
<type>void</type>
<argsstring>(sys.Event safe* this)</argsstring>
<detaileddescription>
<para>Sets event to *signalled* state. When the first waiting thread in the queue wakes up, the event goes back to *idle* state.</para>
</detaileddescription>
<location file='sys_Event.jnc' line='64' col='2'/>
</memberdef>

<memberdef kind='function' id='function_sys_event_reset'>
<functionkind>named-function</functionkind>
<name>reset</name>
<type>void</type>
<argsstring>(sys.Event safe* this)</argsstring>
<detaileddescription>
<para>Forcefully returns event to *idle* state.</para>
</detaileddescription>
<location file='sys_Event.jnc' line='70' col='2'/>
</memberdef>

<memberdef kind='function' id='function_sys_event_wait'>
<functionkind>named-function</functionkind>
<name>wait</name>
<type>bool</type>
<argsstring>(sys.Event safe* this, uint_t timeout - 1)</argsstring>
<param>
<declname>timeout</declname>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<array></array>
<defval>- 1</defval>
</param>
<detaileddescription>
<para>Waits until event goes to *signalled* state. When it happens, ``wait`` returns ``true`` and the event goes back to *idle* state.

If ``timeout`` parameter is not ``-1`` then it's a wait with a *time limit*. If the event does not get signalled until timeout expires, ``wait`` return ``false``. Timeout is expressed in *milliseconds*.</para>
</detaileddescription>
<location file='sys_Event.jnc' line='78' col='7'/>
</memberdef>

</sectiondef>
<includes>sys_Event.jnc</includes>
<briefdescription><para>This class provides standard means of synchronization between threads.</para></briefdescription>
<detaileddescription>
<para>``sys.Event`` can be in one of the following two states: *idle* or *signalled*. One or more threads can wait until the event becomes signalled by invoking ``wait`` method. When some other thread signals the event by invoking ``signal`` method, the first thread in the queue of waiting threads wakes up, ``wait`` call finishes, and the event goes back to *idle* state.

Code sample::

	import "sys_Event.jnc"

	sys.Event g_event;

	thread1 ()
	{
		// ...

		g_event.wait (); // thread sleeps here until event is signalled

		// continue...
	}

	thread2 ()
	{
		// ...

		g_event.signal (); // thread1 wakes up and continues, g_event goes back to idle
	}</para>
<para><simplesect kind='see'><para>`sys.NotificationEvent`, `sys.Lock`, `sys.Thread`</para></simplesect></para>
</detaileddescription>
<location file='sys_Event.jnc' line='55' col='14'/>
</compounddef>
</doxygen>
