<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='struct' id='type_io_socketaddress_ip6' language='Jancy'>
<compoundname>SocketAddress_ip6</compoundname>

<sectiondef>
<memberdef kind='variable' id='struct_member_io_socketaddress_ip6_m_family'>
<name>m_family</name>
<type><ref refid="type_io_addressfamily">io.AddressFamily</ref></type>
<detaileddescription>
<para>Holds the address family of the socket address; should be set to `io.AddressFamily.Ip6`.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='266' col='16'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_socketaddress_ip6_m_port'>
<name>m_port</name>
<type>bigendian unsigned short</type>
<detaileddescription>
<para>Holds the number of ``TCP`` or ``UDP`` port. There is no need to change the byte order of the port before assignment -- this field is already declared as ``bigendian`` so all the necessary conversions will happen automatically.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='272' col='21'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_socketaddress_ip6_m_flow'>
<name>m_flow</name>
<type><ref refid="typedef_uint32_t">uint32_t</ref></type>
<detaileddescription>
<para>Holds ``IP6`` flow information.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='278' col='11'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_socketaddress_ip6_m_address'>
<name>m_address</name>
<type><ref refid="type_io_address_ip6">io.Address_ip6</ref></type>
<detaileddescription>
<para>Holds ``IP6`` address as `io.Address_ip6`.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='284' col='14'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_socketaddress_ip6_m_scope'>
<name>m_scope</name>
<type><ref refid="typedef_uint32_t">uint32_t</ref></type>
<detaileddescription>
<para>Holds 32-bit ``IP6`` scope identifier.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='290' col='11'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddress_ip6_isequal'>
<functionkind>named-function</functionkind>
<name>isEqual</name>
<type>bool</type>
<argsstring>(io.SocketAddress_ip6 safe* this, io.SocketAddress_ip6 const* address)</argsstring>
<param>
<declname>address</declname>
<type><ref refid="type_io_socketaddress_ip6">io.SocketAddress_ip6</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>Checks two ``IP6`` socket addresses for *equality*; returns ``true`` if addresses are equal and ``false`` otherwise.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='296' col='7'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddress_ip6_ismatch'>
<functionkind>named-function</functionkind>
<name>isMatch</name>
<type>bool</type>
<argsstring>(io.SocketAddress_ip6 safe* this, io.SocketAddress_ip6 const* filterAddress)</argsstring>
<param>
<declname>filterAddress</declname>
<type><ref refid="type_io_socketaddress_ip6">io.SocketAddress_ip6</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>Checks two ``IP6`` socket addresses for *matching*. The term *matching* requires some explanation.

Matching could be described as a non-strict equality check. We may decide to only check *port* for equality and ignore the address. To do so, set ``m_address`` field of ``filter`` argument to ``0``.

Or the other way around -- only check *address* and ignore port -- set ``m_port`` field of ``filter`` argument to ``0``.

Returns ``true`` if addresses *match* and ``false`` otherwise.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='308' col='7'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddress_ip6_parse'>
<functionkind>named-function</functionkind>
<name>parse</name>
<type>bool errorcode</type>
<argsstring>(io.SocketAddress_ip6 safe* this, char const* string)</argsstring>
<param>
<declname>string</declname>
<type>char const*</type>
<array></array>
</param>
<detaileddescription>
<para>Constructs the address from a string representation in ``string`` argument.

Returns ``true`` if address string was parsed successfully. Otherwise, sets the description of parsing error and returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='316' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_socketaddress_ip6_getstring' const='yes'>
<functionkind>named-function</functionkind>
<name>getString</name>
<type>char const*</type>
<argsstring>(io.SocketAddress_ip6 safe const* this)</argsstring>
<detaileddescription>
<para>Creates and returns a string representation of the address.</para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='322' col='14'/>
</memberdef>

</sectiondef>
<sectiondef>
<memberdef kind='footnote'>
<name>f1</name>
<detaileddescription>
<para>|footnote-errorcode|</para>
</detaileddescription>
</memberdef>
</sectiondef>
<includes>io_base.jncx</includes>
<includes>io_SocketAddress.jnc</includes>
<briefdescription><para>This struct holds information about ``IP6`` address in the form suitable for socket communications.</para></briefdescription>
<detaileddescription>
<para>On the binary level this structure directly maps to ``sockaddr_in6``.</para>
<para><simplesect kind='see'><para>`io.Socket`, `io.SocketAddressResolver`</para></simplesect></para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='260' col='8'/>
</compounddef>
</doxygen>
