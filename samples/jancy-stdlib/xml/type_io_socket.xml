<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='class' id='type_io_socket' language='Jancy'>
<compoundname>Socket</compoundname>

<sectiondef>
<memberdef kind='function' id='function_io_socket_construct'>
<functionkind>construct</functionkind>
<name>construct</name>
<type>void</type>
<argsstring>(io.Socket safe* this)</argsstring>
<location file='io_Socket.jnc' line='356' col='2'/>
</memberdef>
<memberdef kind='function' id='function_io_socket_destruct'>
<functionkind>destruct</functionkind>
<name>destruct</name>
<type>void</type>
<argsstring>(io.Socket safe* this)</argsstring>
<location file='io_Socket.jnc' line='357' col='2'/>
</memberdef>
</sectiondef>

<sectiondef>
<memberdef kind='property' id='property_io_socket_m_address'>
<name>m_address</name>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref> const property</type>
<argsstring>(io.Socket safe const* this)</argsstring>
<detaileddescription>
<para>This property is used for getting the local address assigned to this socket. If the address has not been assigned yet, returns empty address.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='308' col='31'/>
</memberdef>

<memberdef kind='property' id='property_io_socket_m_peeraddress'>
<name>m_peerAddress</name>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref> const property</type>
<argsstring>(io.Socket safe const* this)</argsstring>
<detaileddescription>
<para>This property is used for getting the remote address of the peer this socket is connected to. If the connection has not been established yet, returns empty address.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='314' col='31'/>
</memberdef>

<memberdef kind='property' id='property_io_socket_m_isbroadcastenabled'>
<name>m_isBroadcastEnabled</name>
<type>bool property</type>
<argsstring>(io.Socket safe const* this)</argsstring>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ the *broadcast* flag for datagram-oriented protocols (such as ``UDP``). When this property is set to ``true``, the socket is allowed to send broadcast packets into the network.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='320' col='16'/>
</memberdef>

<memberdef kind='property' id='property_io_socket_m_isnagleenabled'>
<name>m_isNagleEnabled</name>
<type>bool property</type>
<argsstring>(io.Socket safe const* this)</argsstring>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ the Nagle algorithm flag for ``TCP`` sockets. When this property is set to ``true``, the socket attempts to delay the transmission of TCP data segments in order to reduce the overall number of transmitted packets.

For detailed description of Nagle algorithm refer to: http://en.wikipedia.org/wiki/Nagle's_algorithm</para>
</detaileddescription>
<location file='io_Socket.jnc' line='328' col='16'/>
</memberdef>

<memberdef kind='property' id='property_io_socket_m_israwhdrincluded'>
<name>m_isRawHdrIncluded</name>
<type>bool property</type>
<argsstring>(io.Socket safe const* this)</argsstring>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ the ``IP_HDRINCL`` flag for ``RAW`` sockets. When this property is set to ``true``, the application must provide ``IP`` header together with the rest of the packet (however, the kernel may still overwrite certain fields, such as ``checksum``).

For detailed description of raw sockets refer to: http://man7.org/linux/man-pages/man7/raw.7.html</para>
</detaileddescription>
<location file='io_Socket.jnc' line='336' col='16'/>
</memberdef>

<memberdef kind='property' id='property_io_socket_m_closekind'>
<name>m_closeKind</name>
<type><ref refid="type_io_socketclosekind">io.SocketCloseKind</ref> property</type>
<argsstring>(io.Socket safe const* this)</argsstring>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ the disconnect type for ``TCP`` sockets -- whether it should be **graceful** (via ``FIN`` sequence) or **reset** (via ``RST`` packet).</para>
</detaileddescription>
<location file='io_Socket.jnc' line='342' col='27'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_socket_iface_m_isopen' readonly='yes'>
<name>m_isOpen</name>
<type>bool</type>
<modifiers>readonly</modifiers>
<detaileddescription>
<para>Holds the open status for the socket, i.e. ``true`` if opened; ``false`` otherwise.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='348' col='16'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_socket_iface_m_syncid'>
<name>m_syncId</name>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<detaileddescription>
<para>Holds the synchronization ID for the socket [#f3]_.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='354' col='9'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_open'>
<functionkind>named-function</functionkind>
<name>open</name>
<type>bool errorcode</type>
<argsstring>(io.Socket safe* this, io.AddressFamily family, io.Protocol protocol, io.SocketOpenFlags flags 0)</argsstring>
<param>
<declname>family</declname>
<type><ref refid="type_io_addressfamily">io.AddressFamily</ref></type>
<array></array>
</param>
<param>
<declname>protocol</declname>
<type><ref refid="type_io_protocol">io.Protocol</ref></type>
<array></array>
</param>
<param>
<declname>flags</declname>
<type><ref refid="type_io_socketopenflags">io.SocketOpenFlags</ref></type>
<array></array>
<defval>0</defval>
</param>
<detaileddescription>
<para>Opens a new unbound socket.

The function accepts three arguments. The first one, ``family``, specifies the address family of the new socket (``IP4`` vs ``IP6``). The second argument, ``protocol``, specifies the protocol of the new socket (datagram-oriented ``UDP`` vs connection-oriented ``TCP``). The third and final argument, ``flags`` can be used to specify additional open options. Check `io.SocketOpenFlags` for the complete list of options.

Returns ``true`` on success. If a new socket could not be opened, IO error supplied by operating system is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='367' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_open_2'>
<functionkind>named-function</functionkind>
<name>open</name>
<type>bool errorcode</type>
<argsstring>(io.Socket safe* this, io.Protocol protocol, io.SocketAddress const* address, io.SocketOpenFlags flags 0)</argsstring>
<param>
<declname>protocol</declname>
<type><ref refid="type_io_protocol">io.Protocol</ref></type>
<array></array>
</param>
<param>
<declname>address</declname>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref> const*</type>
<array></array>
</param>
<param>
<declname>flags</declname>
<type><ref refid="type_io_socketopenflags">io.SocketOpenFlags</ref></type>
<array></array>
<defval>0</defval>
</param>
<detaileddescription>
<para>Opens a new socket and binds it to the specified local address.

The function accepts three arguments. The first one, ``protocol``, specifies the protocol of the new socket (datagram-oriented ``UDP`` vs connection-oriented ``TCP``). The second argument, ``address``, specifies the local address to bind the new socket to. The third and final argument, ``flags`` can be used to specify additional open options. Check `io.SocketOpenFlags` for the complete list of options.

Returns ``true`` on success. If a new socket could not be opened, IO error supplied by operating system is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='381' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_open_3'>
<functionkind>named-function</functionkind>
<name>open</name>
<type>bool errorcode</type>
<argsstring>(io.Socket safe* this, io.Protocol protocol, io.SocketOpenFlags flags 0)</argsstring>
<param>
<declname>protocol</declname>
<type><ref refid="type_io_protocol">io.Protocol</ref></type>
<array></array>
</param>
<param>
<declname>flags</declname>
<type><ref refid="type_io_socketopenflags">io.SocketOpenFlags</ref></type>
<array></array>
<defval>0</defval>
</param>
<detaileddescription>
<para>Opens a new unbound socket.

The function is equivalent to the very first overload of ``open`` method with ``family`` argument set to `io.AddressFamily.Ip4`.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='393' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_close'>
<functionkind>named-function</functionkind>
<name>close</name>
<type>void</type>
<argsstring>(io.Socket safe* this)</argsstring>
<detaileddescription>
<para>Closes a previously opened socket, does nothing if the file is not opened. This function always succeeds.

Sometimes it may be convenient to use *disposable* pattern to ensure timely invokation of ``close`` [#f2]_.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='407' col='7'/>
</memberdef>

<memberdef kind='alias' id='alias_io_socket_dispose'>
<name>dispose</name>
<initializer>= close</initializer>
<detaileddescription>
<para>Effectively makes ``io.Socket`` a *disposable* class [#f2]_.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='413' col='8'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_connect'>
<functionkind>named-function</functionkind>
<name>connect</name>
<type>bool errorcode</type>
<argsstring>(io.Socket safe* this, io.SocketAddress const* address)</argsstring>
<param>
<declname>address</declname>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>Initiates a connection request to ``address``. This function is only valid for ``TCP`` sockets.

If this socket was opened with `io.SocketOpenFlags.Asynchronous` flag, this method merely initiates a connection request and returns immediatly. After connection request completes, an event `io.SocketEventCode.ConnectCompleted` (on success) or `io.SocketEventCode.ConnectError` (on failure) gets fired.

If, however, this socket was opened without `io.SocketOpenFlags.Asynchronous` flag, this method waits until connection request completes (successfully or unsuccessfully) and only then returns.

Returns ``true`` on success. If a connection could not be established, IO error supplied by operating system is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='425' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_listen'>
<functionkind>named-function</functionkind>
<name>listen</name>
<type>bool errorcode</type>
<argsstring>(io.Socket safe* this, size_t backlog 0)</argsstring>
<param>
<declname>backlog</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
<defval>0</defval>
</param>
<detaileddescription>
<para>Places a server socket into ``listen`` state. This function is only valid for ``TCP`` sockets.

The only argument of the method, ``backlog``, specifies the maximum length of the queue of *pending* client-side connections, i.e. connections which has not been accepted via ``accept`` method yet.

Returns ``true`` on success. If the socket could not be placed into ``listen`` state, IO error supplied by operating system is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='435' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_accept'>
<functionkind>named-function</functionkind>
<name>accept</name>
<type><ref refid="type_io_socket">io.Socket</ref>* errorcode</type>
<argsstring>(io.Socket safe* this, io.SocketAddress* address null)</argsstring>
<param>
<declname>address</declname>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref>*</type>
<array></array>
<defval>null</defval>
</param>
<detaileddescription>
<para>Accepts a client connection and returns a resulting ``io.Socket`` object to communicate with this particular client. To terminate a client connection, issue ``close`` method on the client file stream object.

The new ``io.Socket`` is created with events disabled. Turn events back on after assigning an event handler using ``m_isSocketEventEnabled`` property.

If method fails, ``null`` value is returned [#f1]_.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='445' col='20'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_send'>
<functionkind>named-function</functionkind>
<name>send</name>
<type><ref refid="typedef_size_t">size_t</ref> errorcode</type>
<argsstring>(io.Socket safe* this, void const* p, size_t size)</argsstring>
<param>
<declname>p</declname>
<type>void const*</type>
<array></array>
</param>
<param>
<declname>size</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<detaileddescription>
<para>Attempts to send ``size`` bytes from the buffer pointed to by ``p`` over the connected socket.

Returns the actual amount of bytes written on success. If write operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

If the return value shows *less* bytes than specified by ``size`` argument, you should suspend further transmission until the file stream is ready to accept more data. When this happens, ``TransmitBufferReady`` event is fired and transmission could be resumed.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='455' col='19'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_recv'>
<functionkind>named-function</functionkind>
<name>recv</name>
<type><ref refid="typedef_size_t">size_t</ref> errorcode</type>
<argsstring>(io.Socket safe* this, void* p, size_t size)</argsstring>
<param>
<declname>p</declname>
<type>void*</type>
<array></array>
</param>
<param>
<declname>size</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<detaileddescription>
<para>Attempts to receive up to ``size`` bytes from the socket into the buffer pointed to by ``p``.

Returns the actual amount of bytes read on success. If read operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

Normally you would call this function from within your event handler for ``IncomingData`` event. If this function is called when there is no incoming data, it blocks until either the data arrives, or the socket is closed.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='468' col='19'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_sendto'>
<functionkind>named-function</functionkind>
<name>sendTo</name>
<type><ref refid="typedef_size_t">size_t</ref> errorcode</type>
<argsstring>(io.Socket safe* this, void const* p, size_t size, io.SocketAddress const* address)</argsstring>
<param>
<declname>p</declname>
<type>void const*</type>
<array></array>
</param>
<param>
<declname>size</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<param>
<declname>address</declname>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>Attempts to send ``size`` bytes from the buffer pointed to by ``p`` to the remote node pointed to by ``address``.

Returns the actual amount of bytes written on success. If write operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

If the return value shows *less* bytes than specified by ``size`` argument, you should suspend further transmission until the file stream is ready to accept more data. When this happens, ``TransmitBufferReady`` event is fired and transmission could be resumed.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='481' col='19'/>
</memberdef>

<memberdef kind='function' id='function_io_socket_recvfrom'>
<functionkind>named-function</functionkind>
<name>recvFrom</name>
<type><ref refid="typedef_size_t">size_t</ref> errorcode</type>
<argsstring>(io.Socket safe* this, void* p, size_t size, io.SocketAddress* address)</argsstring>
<param>
<declname>p</declname>
<type>void*</type>
<array></array>
</param>
<param>
<declname>size</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<param>
<declname>address</declname>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref>*</type>
<array></array>
</param>
<detaileddescription>
<para>Attempts to read up to ``size`` bytes from the socket into the buffer pointed to by ``p``; stores the address of the sender into the ``address``.

Returns the actual amount of bytes read on success. If read operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

Normally you would call this function from within your event handler for ``IncomingData`` event. If this function is called when there is no incoming data, it blocks until either the data arrives, or the serial port is closed.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='495' col='19'/>
</memberdef>

<memberdef kind='event' id='struct_member_io_socket_iface_m_onsocketevent'>
<name>m_onSocketEvent</name>
<type>multicast</type>
<argsstring>(io.SocketEventParams const* params)</argsstring>
<param>
<declname>params</declname>
<type><ref refid="type_io_socketeventparams">io.SocketEventParams</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>This event is fired whenever an event occurs on the socket.

For the list of possible events, refer to `io.SocketEventCode` enumeration.

Event handler receives a single argument of type `io.SocketEventParams` which holds parameters of the particular event [#f3]_.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='509' col='8'/>
</memberdef>

<memberdef kind='property' id='property_io_socket_m_issocketeventenabled'>
<name>m_isSocketEventEnabled</name>
<type>bool property</type>
<argsstring>(io.Socket safe const* this)</argsstring>
<detaileddescription>
<para>When ``Socket`` object is created as a result of ``accept`` method, events of the new socket are initially disabled -- otherwise, how could you handle the events occurred right after ``accept`` but before you have a chance to assign a new event handler?

Once you have assigned an event handler for the new file stream, you can re-enable its events by setting ``m_isSocketEventEnabled`` to ``true``. All the pending events will be replayed so your new handler has a chance to process them in the same order they originally occurred.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='517' col='16'/>
</memberdef>

</sectiondef>
<sectiondef>
<memberdef kind='footnote'>
<name>f1</name>
<detaileddescription>
<para>|footnote-errorcode|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f2</name>
<detaileddescription>
<para>|footnote-disposable|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f3</name>
<detaileddescription>
<para>|footnote-sync-id|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f4</name>
<detaileddescription>
<para>|footnote-set-property-fail|</para>
</detaileddescription>
</memberdef>
</sectiondef>
<includes>io_base.jncx</includes>
<includes>io_Socket.jnc</includes>
<briefdescription><para>This class provides high-level asynchronous interface for accessing all kinds of sockets.</para></briefdescription>
<detaileddescription>
<para>Sockets represent endpoints of network communications. Sockets are subdivided into two large subclassess: **datagram-oriented** and **connection-oriented**. Furthermore, connection-oriented sockets can operate in one of the two modes: **client** and **server**. And even though these interfaces don't share that many commonalities, it so historically happened that they are usually blended into a single *socket API*.

Jancy follows this traditional approach.

Sample code (client connection-oriented TCP socket):

.. ref-code-block::

	class MyDialog
	{
		// ...

		io.Socket m_socket;

		construct ();

		open (
			char const* portName,
			uint_t baudRate
			);

		onWriteButtonClicked ();
		onSocketEvent (`io.SocketEventParams` const* params);
	}

	MyDialog.construct ()
	{
		// ...
		m_socket.m_onSocketEvent += onSocketEvent @ g_mainThreadScheduler;
	}

	MyDialog.connect (char const* addrString)
	{
		`io.SocketAddress` sockAddr;
		sockAddr.parse (addrString);
		m_socket.open (`io.Protocol.Tcp`, `io.SocketOpenFlags.Asynchronous`);
		m_socket.connect (sockAddr);

	catch:
		// handle the error...
	}

	MyDialog.onSendButtonClicked ()
	{
		static char data [] = "a quick brown fox jumps over the lazy dog";
		m_socket.send (data, sizeof (data));
	}

	MyDialog.onSocketEvent (`io.SocketEventParams` const* params)
	{
		if (params.m_syncId != m_socket.m_syncId) // late event
			return;

		switch (params.m_code)
		{
		case `io.SocketEventCode.ConnectError`:
			// handle error (extended info is at: params.m_error)...
			break;

		case `io.SocketEventCode.ConnectCompleted`:
			// handle successfull connection...
			break;

		case `io.SocketEventCode.IncomingData`:
			char buffer [256];
			size_t size = m_socket.recv (buffer, sizeof (buffer));
			// ...
			break;
		}
	}</para>
<para><simplesect kind='see'><para>`io.SocketOpenFlags`, `io.SocketEventParams`, `io.SocketEventCode`, `io.SocketAddress`</para></simplesect></para>
</detaileddescription>
<location file='io_Socket.jnc' line='302' col='14'/>
</compounddef>
</doxygen>
