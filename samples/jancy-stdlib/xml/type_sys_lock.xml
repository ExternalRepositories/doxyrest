<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='class' id='type_sys_lock' language='Jancy'>
<compoundname>Lock</compoundname>

<sectiondef>
<memberdef kind='function' id='function_sys_lock_construct'>
<functionkind>construct</functionkind>
<name>construct</name>
<type>void</type>
<argsstring>(sys.Lock safe* this)</argsstring>
<location file='sys_Lock.jnc' line='66' col='2'/>
</memberdef>
<memberdef kind='function' id='function_sys_lock_destruct'>
<functionkind>destruct</functionkind>
<name>destruct</name>
<type>void</type>
<argsstring>(sys.Lock safe* this)</argsstring>
<location file='sys_Lock.jnc' line='67' col='2'/>
</memberdef>
</sectiondef>

<sectiondef>
<memberdef kind='function' id='function_sys_lock_lock'>
<functionkind>named-function</functionkind>
<name>lock</name>
<type>void</type>
<argsstring>(sys.Lock safe* this)</argsstring>
<detaileddescription>
<para>*Acquires* the lock. If the lock is already acquired by another thread, the current thread enters the wait queue for the lock. When the lock is released by other thread(s), the current thread acquires it.</para>
</detaileddescription>
<location file='sys_Lock.jnc' line='73' col='2'/>
</memberdef>

<memberdef kind='function' id='function_sys_lock_unlock'>
<functionkind>named-function</functionkind>
<name>unlock</name>
<type>void</type>
<argsstring>(sys.Lock safe* this)</argsstring>
<detaileddescription>
<para>*Releases* the lock. If other threads are waiting for the lock at the moment, the first one in the wait queue *acquires* the lock.</para>
</detaileddescription>
<location file='sys_Lock.jnc' line='79' col='2'/>
</memberdef>

</sectiondef>
<includes>sys_Lock.jnc</includes>
<briefdescription><para>This class is used to ensure exclusive access to some shared resource.</para></briefdescription>
<detaileddescription>
<para>Only one thread at a time can *acquire* the ``sys.Lock`` object and hence, get exclusive access to some resource this ``sys.Lock`` object is being a guardian of. To do that, a thread calls ``lock`` method. Once it returns, the ``sys.Lock`` object is in *locked* state and this thread can exclusively access the associated resource.

Any other thread trying to *acquire* it will wait until the original thread *releases* the lock with ``unlock`` method.

Code sample::

	import "sys_Lock.jnc"

	sys.Lock g_event;
	int g_resource;

	thread1 ()
	{
		// ...

		g_lock.lock ();   // acquire the lock
		g_resource++;     // we can safely access the resource now
		g_lock.unlock (); // let others get access, too

		// continue...
	}

	thread2 ()
	{
		// ...

		g_lock.lock ();   // acquire the lock
		g_resource--;     // we can safely access the resource now
		g_lock.unlock (); // let others get access, too

		// continue...
	}</para>
<para><simplesect kind='see'><para>`sys.Thread`</para></simplesect></para>
</detaileddescription>
<location file='sys_Lock.jnc' line='64' col='14'/>
</compounddef>
</doxygen>
