<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='class' id='type_jnc_regexstate' language='Jancy'>
<compoundname>RegexState</compoundname>

<sectiondef>
<memberdef kind='function' id='function_jnc_regexstate_construct'>
<functionkind>construct</functionkind>
<name>construct</name>
<type>void</type>
<argsstring>(jnc.RegexState safe* this, bool isIncremental false)</argsstring>
<param>
<declname>isIncremental</declname>
<type>bool</type>
<array></array>
<defval>false</defval>
</param>
<detaileddescription>
<para>Constructor of ``jnc.Recognizer`` class. Accepts a single optional argument ``automatonFunc`` which, if supplied, will be written to ``m_automatonFunc`` and used for subsequent scanning.</para>
</detaileddescription>
<location file='jnc_Regex.jnc' line='196' col='2'/>
</memberdef>
</sectiondef>

<sectiondef>
<memberdef kind='variable' id='struct_member_jnc_regexstate_iface_m_isincremental'>
<name>m_isIncremental</name>
<type>bool</type>
<location file='jnc_Regex.jnc' line='153' col='7'/>
</memberdef>

<memberdef kind='property' id='property_jnc_regexstate_m_matchlengthlimit'>
<name>m_matchLengthLimit</name>
<type><ref refid="typedef_size_t">size_t</ref> property</type>
<argsstring>(jnc.RegexState safe const* this)</argsstring>
<modifiers>autoget</modifiers>
<detaileddescription>
<para>Holds the maximum buffer size for lexemes. Set before starting recognition.

What happends when lexeme in the input stream does not fit inside the buffer, depends on the whether the captured part of lexeme *already* matches some rule. If yes, recognizer will execute corresponding action and then reset its state to initial value.

If captured part of lexeme does not match any rules, ``write`` or ``recognize`` will return error.</para>
</detaileddescription>
<location file='jnc_Regex.jnc' line='163' col='26'/>
</memberdef>

<memberdef kind='property' id='property_jnc_regexstate_m_currentoffset'>
<name>m_currentOffset</name>
<type><ref refid="typedef_size_t">size_t</ref> property</type>
<argsstring>(jnc.RegexState safe const* this)</argsstring>
<modifiers>autoget</modifiers>
<detaileddescription>
<para>Holds the current offset of recognizer.

Could be adjusted manually. For example, you can adjust ``m_currentOffset`` before starting recognition; when a lexeme is found, ``m_lexemeOffset`` will account for the initial offset (offset relative the beginning of the stream plus initial offset set before starting recognition).</para>
</detaileddescription>
<location file='jnc_Regex.jnc' line='171' col='26'/>
</memberdef>

<memberdef kind='variable' id='struct_member_jnc_regexstate_iface_m_consumedlength' readonly='yes'>
<name>m_consumedLength</name>
<type><ref refid="typedef_size_t">size_t</ref></type>
<modifiers>readonly</modifiers>
<detaileddescription>
<para>Holds the actual length of data consumed during the last invokation of the DFA. When non-incremental recognizer discovers a match, ``m_consumedLength`` will always be the same as ``m_match.m_length``. In case of a incremental recognizer, ``m_consumedLength`` may be smaller than ``m_match.m_length`` (the match may be spread across multiple blocks of input data).</para>
</detaileddescription>
<location file='jnc_Regex.jnc' line='177' col='18'/>
</memberdef>

<memberdef kind='variable' id='struct_member_jnc_regexstate_iface_m_match' readonly='yes'>
<name>m_match</name>
<type><ref refid="type_jnc_regexmatch">jnc.RegexMatch</ref></type>
<modifiers>readonly</modifiers>
<detaileddescription>
<para>These fields hold information about the matched lexeme and, possibly, sub-lexemes (if capturing regular expressions groups were used).

These fields should only be accessed from within **action** inside ``automaton`` function.</para>
<internal><para>:subgroup:</para></internal>
</detaileddescription>
<location file='jnc_Regex.jnc' line='187' col='22'/>
</memberdef>

<memberdef kind='variable' id='struct_member_jnc_regexstate_iface_m_submatcharray' readonly='yes'>
<name>m_subMatchArray</name>
<type><ref refid="type_jnc_regexmatch">jnc.RegexMatch</ref> const*</type>
<modifiers>readonly</modifiers>
<location file='jnc_Regex.jnc' line='188' col='29'/>
</memberdef>

<memberdef kind='variable' id='struct_member_jnc_regexstate_iface_m_submatchcount' readonly='yes'>
<name>m_subMatchCount</name>
<type><ref refid="typedef_size_t">size_t</ref></type>
<modifiers>readonly</modifiers>
<location file='jnc_Regex.jnc' line='189' col='18'/>
</memberdef>

<memberdef kind='function' id='function_jnc_regexstate_reset'>
<functionkind>named-function</functionkind>
<name>reset</name>
<type>void</type>
<argsstring>(jnc.RegexState safe* this)</argsstring>
<detaileddescription>
<para>Resets state of recognizer including all offsets and captured lexeme bytes.</para>
</detaileddescription>
<location file='jnc_Regex.jnc' line='202' col='2'/>
</memberdef>

<memberdef kind='function' id='function_jnc_regexstate_exec' prot='protected'>
<functionkind>named-function</functionkind>
<name>exec</name>
<type><ref refid="typedef_size_t">size_t</ref></type>
<argsstring>(jnc.RegexState safe* this, void thin* dfa, char const* p, size_t length)</argsstring>
<param>
<declname>dfa</declname>
<type>void thin*</type>
<array></array>
</param>
<param>
<declname>p</declname>
<type>char const*</type>
<array></array>
</param>
<param>
<declname>length</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<location file='jnc_Regex.jnc' line='205' col='9'/>
</memberdef>

</sectiondef>
<briefdescription><para>This class holds the lexeme buffer and the state of DFA constructed from an ``reswitch`` statement.</para></briefdescription>
<detaileddescription>
<para><![CDATA[Jancy ``reswitch`` statements allow for convenient creation of lexers/scanners.

The idea is taken from well-known tools like *Lex*, *Flex*, *Ragel* etc.

1. Define a list of recognized lexemes in the form of regular expressions.
2. Specify which actions to execute when these lexemes are found in the input stream.
3. Jancy compiler automatically builds a DFA to recognize your language and perform correspondig actions.

To *execute* the resulting DFA you need a ``jnc.RegexState`` object -- it will hold the state of DFA and buffer matched lexemes. In its simplest form recognizer looks like this:

.. ref-code-block::

	jnc.RegexState state;
	reswitch (state, p, length)
	{
	case "foo":
		// ...
		break;

	case r"bar\(d+)":
		print ($"bar id: $(state.m_subMatchArray [0].m_text)\n");
		break;

	case r"\s+":
		// ignore whitespace
		break;

	// ...
	}

To employ incremental recognition, you would want to create some kind of a *match* function and call it each time the next chunk of data becomes available:

.. ref-code-block::

	bool errorcode match (
		jnc.RegexState* state,
		const char* p,
		size_t length
		)
	{
		const char* end = p + length;

		// post-condition loop allows passing 'null' as eof
		do
		{
			reswitch (state, p, end - p)
			{
			case "foo":
				// ...
				break;

			case r"bar\(d+)":
				print ($"bar id: $(state.m_subMatchArray [0].m_text)\n");
				break;

			case r"\s+":
				// ignore whitespace
				break;

			// ...

			default:
				// we can get here for two reasons only:
				//   1) mismatch
				//   2) incremental recognition

				if (!state.m_consumedLength)
					return false;

				assert (state.m_isIncremental && state.m_consumedLength == end - p);
			}

			p += state.m_consumedLength; // advance to the next lexeme
		} while (p < end)

		return true;
	}

Recognizer must be aware of the fact it is being fed the date chunk-by-chunk (and not as the whole). You do so by setting ``m_isIncremental`` field to ``true``:

.. ref-code-block::

	jnc.RegexState state (true);  // turn on incremental matching

	// alternatively, assign:
	// state.m_isIncremental = true;

Now, whenever the next portion of data becomes available, simply call:

.. ref-code-block::

	size_t length = getNextPortionOfData (buffer);

	match (state, buffer, length);

Pass zero-sized buffer to trigger ``eof`` processing:

.. ref-code-block::

	match (state, null, 0);]]></para>
</detaileddescription>
<location file='jnc_Regex.jnc' line='151' col='14'/>
</compounddef>
</doxygen>
