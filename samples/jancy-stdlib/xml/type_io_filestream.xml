<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='class' id='type_io_filestream' language='Jancy'>
<compoundname>FileStream</compoundname>

<sectiondef>
<memberdef kind='function' id='function_io_filestream_construct'>
<functionkind>construct</functionkind>
<name>construct</name>
<type>void</type>
<argsstring>(io.FileStream safe* this)</argsstring>
<location file='io_FileStream.jnc' line='258' col='2'/>
</memberdef>
<memberdef kind='function' id='function_io_filestream_destruct'>
<functionkind>destruct</functionkind>
<name>destruct</name>
<type>void</type>
<argsstring>(io.FileStream safe* this)</argsstring>
<location file='io_FileStream.jnc' line='259' col='2'/>
</memberdef>
</sectiondef>

<sectiondef>
<memberdef kind='variable' id='struct_member_io_filestream_iface_m_isopen' readonly='yes'>
<name>m_isOpen</name>
<type>bool</type>
<modifiers>readonly</modifiers>
<detaileddescription>
<para>Holds the open status for the file, i.e. ``true`` if opened; ``false`` otherwise.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='242' col='16'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_filestream_iface_m_syncid'>
<name>m_syncId</name>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<detaileddescription>
<para>Holds the synchronization ID for the file stream [#f3]_.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='248' col='9'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_filestream_iface_m_kind' readonly='yes'>
<name>m_kind</name>
<type><ref refid="type_io_filestreamkind">io.FileStreamKind</ref></type>
<modifiers>readonly</modifiers>
<detaileddescription>
<para>Specifies the type of the file stream (regular disk file, serial port etc). For the full list of supported file stream types, refer to `io.FileStreamKind`.

This field is currently only initialized on Windows. To to detect the type ``io.FileStream`` uses WinAPI function ``GetFileType``.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='256' col='26'/>
</memberdef>

<memberdef kind='function' id='function_io_filestream_open'>
<functionkind>named-function</functionkind>
<name>open</name>
<type>bool errorcode</type>
<argsstring>(io.FileStream safe* this, char const* name, io.FileOpenFlags flags 0)</argsstring>
<param>
<declname>name</declname>
<type>char const*</type>
<array></array>
</param>
<param>
<declname>flags</declname>
<type><ref refid="type_io_fileopenflags">io.FileOpenFlags</ref></type>
<array></array>
<defval>0</defval>
</param>
<detaileddescription>
<para>Opens or creates a file stream.

The function accepts two arguments. The first one, ``name`` specifies the name of the file/device. The second one, ``flags``, can be used to specify open options. Check `io.FileOpenFlags` for the complete list of options.

Returns ``true`` on success. If the file stream could not be opened, IO error supplied by operating system is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='269' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_filestream_close'>
<functionkind>named-function</functionkind>
<name>close</name>
<type>void</type>
<argsstring>(io.FileStream safe* this)</argsstring>
<detaileddescription>
<para>Closes a previously opened file stream, does nothing if the file stream is not opened. This function always succeeds.

Sometimes it may be convenient to use *disposable* pattern to ensure timely invokation of ``close`` [#f2]_.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='280' col='7'/>
</memberdef>

<memberdef kind='alias' id='alias_io_filestream_dispose'>
<name>dispose</name>
<initializer>= close</initializer>
<detaileddescription>
<para>Effectively makes ``io.FileStream`` a *disposable* class [#f2]_.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='286' col='8'/>
</memberdef>

<memberdef kind='function' id='function_io_filestream_clear'>
<functionkind>named-function</functionkind>
<name>clear</name>
<type>bool errorcode</type>
<argsstring>(io.FileStream safe* this)</argsstring>
<detaileddescription>
<para>Clears the file, destroying all its contents. This function is only applicable to regular disk file streams.

Returns ``true`` on success. If clear operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='294' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_filestream_read'>
<functionkind>named-function</functionkind>
<name>read</name>
<type><ref refid="typedef_size_t">size_t</ref> errorcode</type>
<argsstring>(io.FileStream safe* this, void* p, size_t size)</argsstring>
<param>
<declname>p</declname>
<type>void*</type>
<array></array>
</param>
<param>
<declname>size</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<detaileddescription>
<para>Attempts to read up to ``size`` bytes from the file strean into the buffer pointed to by ``p``.

Returns the actual amount of bytes read on success. If read operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

Normally you would call this function from within your event handler for ``IncomingData`` event. If this function is called when there is no incoming data, it blocks until either the data arrives, or the file is closed, so its behavior resembles ``io.File.read``</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='304' col='19'/>
</memberdef>

<memberdef kind='function' id='function_io_filestream_write'>
<functionkind>named-function</functionkind>
<name>write</name>
<type><ref refid="typedef_size_t">size_t</ref> errorcode</type>
<argsstring>(io.FileStream safe* this, void const* p, size_t size)</argsstring>
<param>
<declname>p</declname>
<type>void const*</type>
<array></array>
</param>
<param>
<declname>size</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<detaileddescription>
<para>Attempts to write ``size`` bytes from the buffer pointed to by ``p`` into the file stream.

Returns the actual amount of bytes written on success. If write operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

If the return value shows *less* bytes than specified by ``size`` argument, you should suspend further transmission until the file stream is ready to accept more data. When this happens, ``TransmitBufferReady`` event is fired and transmission could be resumed.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='317' col='19'/>
</memberdef>

<memberdef kind='event' id='struct_member_io_filestream_iface_m_onfilestreamevent'>
<name>m_onFileStreamEvent</name>
<type>multicast</type>
<argsstring>(io.FileStreamEventParams const* params)</argsstring>
<param>
<declname>params</declname>
<type><ref refid="type_io_filestreameventparams">io.FileStreamEventParams</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>This event is fired whenever an event occurs on the file stream.

For the list of possible events, refer to `io.FileStreamEventCode` enumeration.

Event handler receives a single argument of type `io.FileStreamEventParams` which holds parameters of the particular event [#f3]_.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='330' col='8'/>
</memberdef>

<memberdef kind='property' id='property_io_filestream_m_isfilestreameventenabled'>
<name>m_isFileStreamEventEnabled</name>
<type>bool property</type>
<argsstring>(io.FileStream safe const* this)</argsstring>
<detaileddescription>
<para>When ``FileStream`` object is created as a result of `io.NamedPipe.accept` method, events of the new file stream are initially disabled -- otherwise, how could you handle the events occurred right after ``accept`` but before you have a chance to assign a new event handler?

Once you have assigned an event handler for the new file stream, you can re-enable its events by setting ``m_isFileStreamEventEnabled`` to ``true``. All the pending events will be replayed so your new handler has a chance to process them in the same order they originally occurred.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='338' col='16'/>
</memberdef>

</sectiondef>
<sectiondef>
<memberdef kind='footnote'>
<name>f1</name>
<detaileddescription>
<para>|footnote-errorcode|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f2</name>
<detaileddescription>
<para>|footnote-disposable|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f3</name>
<detaileddescription>
<para>|footnote-sync-id|</para>
</detaileddescription>
</memberdef>
</sectiondef>
<includes>io_base.jncx</includes>
<includes>io_FileStream.jnc</includes>
<briefdescription><para>This class provides high-level asynchronous streaming interface for reading from and writing to files or devices.</para></briefdescription>
<detaileddescription>
<para>Besides all the standard methods of ``io.File`` (like ``open``, ``read``, ``write`` etc) ``io.FileStream`` also notifies its clients of events occured on this file stream such as when data has arrived and could be read or when IO error occured. This allows for clean and convenient asynchronous event-driven IO programming.

A typical sequence of steps when working with a file stream looks something like this:

* Assign your event handler using ``m_onFileStreamEvent`` (you would probably also want to *schedule* your event handler to be run in particular environment, e.g. in specific thread)
* Open a file stream with ``open`` method;
* When ``IncomingData`` event is fired, read from the file using ``read`` method;
* Write to the file stream using ``write`` method;
* Suspend writing if the return value of ``write`` is less than requested;
* Resume writing on ``TransmitBufferReady`` event;
* Close the file stream when no longer needed with ``close`` method.

.. rubric:: Sample code:

.. ref-code-block::

	class MyDialog
	{
		// ...

		io.FileStream m_fileStream;

		construct ();
		open (char const* fileName);
		onWriteButtonClicked ();
		onFileStreamEvent (`io.FileStreamEventParams` const* params);
	}

	MyDialog.construct ()
	{
		// ...
		m_fileStream.m_onFileStreamEvent += onFileStreamEvent @ g_mainThreadScheduler;
	}

	MyDialog.open (char const* fileName)
	{
		bool result = try m_fileStream.open (fileName);
		if (!result)
		{
			// handle the error...
		}
	}

	MyDialog.onWriteButtonClicked ()
	{
		static char data [] = "a quick brown fox jumps over the lazy dog";
		m_fileStream.write (data, sizeof (data));
	}

	MyDialog.onFileStreamEvent (`io.FileStreamEventParams` const* params)
	{
		if (params.m_syncId != m_fileStream.m_syncId) // late event
			return;

		switch (params.m_code)
		{
		case `io.FileStreamEventCode.IncomingData`:
			char buffer [256];
			size_t size = m_fileStream.read (buffer, sizeof (buffer));
			// ...
			break;
		}
	}</para>
<para><simplesect kind='see'><para>`io.FileStreamEventParams`, `io.FileStreamEventCode`, `io.File`, `io.NamedPipe`, `io.Mailslot`</para></simplesect></para>
</detaileddescription>
<location file='io_FileStream.jnc' line='236' col='14'/>
</compounddef>
</doxygen>
