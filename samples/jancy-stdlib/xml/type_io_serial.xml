<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='class' id='type_io_serial' language='Jancy'>
<compoundname>Serial</compoundname>

<sectiondef>
<memberdef kind='function' id='function_io_serial_construct'>
<functionkind>construct</functionkind>
<name>construct</name>
<type>void</type>
<argsstring>(io.Serial safe* this)</argsstring>
<location file='io_Serial.jnc' line='430' col='2'/>
</memberdef>
<memberdef kind='function' id='function_io_serial_destruct'>
<functionkind>destruct</functionkind>
<name>destruct</name>
<type>void</type>
<argsstring>(io.Serial safe* this)</argsstring>
<location file='io_Serial.jnc' line='431' col='2'/>
</memberdef>
</sectiondef>

<sectiondef>
<memberdef kind='property' id='property_io_serial_m_baudrate'>
<name>m_baudRate</name>
<type><ref refid="typedef_uint_t">uint_t</ref> property</type>
<argsstring>(io.Serial safe const* this)</argsstring>
<modifiers>autoget</modifiers>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ baud rate, i.e. the number of signal changes per second, which directly affects the speed of data transmission.

Different hardware serial ports may or may not support some particular baud rates. Unfortunately, there is no reliable cross-platform method of building a list of supported baud rates, so the only way is to probe.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='364' col='26'/>
</memberdef>

<memberdef kind='property' id='property_io_serial_m_flowcontrol'>
<name>m_flowControl</name>
<type><ref refid="type_io_serialflowcontrol">io.SerialFlowControl</ref> property</type>
<argsstring>(io.Serial safe const* this)</argsstring>
<modifiers>autoget</modifiers>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ flow control, i.e. the protocol of attempted prevention of data loss during serial transmission which may happen when transmission side sends data faster than the receiving side is able to process it.

See `io.SerialFlowControl` enumeration for the list of valid values.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='372' col='37'/>
</memberdef>

<memberdef kind='property' id='property_io_serial_m_databits'>
<name>m_dataBits</name>
<type><ref refid="typedef_uint_t">uint_t</ref> property</type>
<argsstring>(io.Serial safe const* this)</argsstring>
<modifiers>autoget</modifiers>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ byte size, i.e. the number of bits in each character transmitted over the serial line. Valid values range from ``5`` to ``8``; normally ``8`` data bits are used.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='378' col='26'/>
</memberdef>

<memberdef kind='property' id='property_io_serial_m_stopbits'>
<name>m_stopBits</name>
<type><ref refid="type_io_serialstopbits">io.SerialStopBits</ref> property</type>
<argsstring>(io.Serial safe const* this)</argsstring>
<modifiers>autoget</modifiers>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ the number of serial stop bits, i.e. auxillary (non-data) bits sent at the end of each character to re-synchronize the receiver; normally 1 stop bit is used (designated by `io.SerialStopBits._1`)

See `io.SerialStopBits` enumeration for the list of valid values.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='386' col='34'/>
</memberdef>

<memberdef kind='property' id='property_io_serial_m_parity'>
<name>m_parity</name>
<type><ref refid="type_io_serialparity">io.SerialParity</ref> property</type>
<argsstring>(io.Serial safe const* this)</argsstring>
<modifiers>autoget</modifiers>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ serial parity control, i.e. the protocol of attempted error detection during serial transmission. The idea is to send an extra *parity* bit so that the total number of one's including data bits *and* this parity bit is always *odd* or always *even*.

This, however, is a rather weak error detection method; usually it's much better to employ other checksums/hash checks after the data has been transmitted.

See `io.SerialParity` for the list of valid values.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='396' col='32'/>
</memberdef>

<memberdef kind='property' id='property_io_serial_m_statuslines'>
<name>m_statusLines</name>
<type><ref refid="type_io_serialstatuslines">io.SerialStatusLines</ref> const property</type>
<argsstring>(io.Serial safe const* this)</argsstring>
<detaileddescription>
<para>This property is used for getting the values of serial status lines (``DSR``, ``CTS``, ``DCD``, ``RING``).

The returned value is a combination of `io.SerialStatusLines` enumeration members, showing which status lines are high (or ``0`` if all are low).</para>
</detaileddescription>
<location file='io_Serial.jnc' line='404' col='35'/>
</memberdef>

<memberdef kind='property' id='property_io_serial_m_dtr'>
<name>m_dtr</name>
<type>bool property</type>
<argsstring>(io.Serial safe const* this)</argsstring>
<modifiers>autoget</modifiers>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ ``DTR`` (data-terminal-ready) serial control line.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='410' col='24'/>
</memberdef>

<memberdef kind='property' id='property_io_serial_m_rts'>
<name>m_rts</name>
<type>bool property</type>
<argsstring>(io.Serial safe const* this)</argsstring>
<modifiers>autoget</modifiers>
<detaileddescription>
<para>This property is used for getting and setting [#f4]_ ``RTS`` (ready-to-send) serial control line.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='416' col='24'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_serial_iface_m_isopen' readonly='yes'>
<name>m_isOpen</name>
<type>bool</type>
<modifiers>readonly</modifiers>
<detaileddescription>
<para>Holds the open status for the serial port, i.e. ``true`` if opened; ``false`` otherwise.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='422' col='16'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_serial_iface_m_syncid'>
<name>m_syncId</name>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<detaileddescription>
<para>Holds the synchronization ID for the serial port [#f3]_.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='428' col='9'/>
</memberdef>

<memberdef kind='function' id='function_io_serial_open'>
<functionkind>named-function</functionkind>
<name>open</name>
<type>bool errorcode</type>
<argsstring>(io.Serial safe* this, char const* name)</argsstring>
<param>
<declname>name</declname>
<type>char const*</type>
<array></array>
</param>
<detaileddescription>
<para>Opens a serial port.

The function accepts a single ``name`` argument, which specifies the name of the serial port device.

Returns ``true`` on success. If serial port could not be opened, IO error supplied by operating system is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='441' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_serial_close'>
<functionkind>named-function</functionkind>
<name>close</name>
<type>void</type>
<argsstring>(io.Serial safe* this)</argsstring>
<detaileddescription>
<para>Closes a previously opened serial port, does nothing if the port is not opened. This function always succeeds.

Sometimes it may be convenient to use *disposable* pattern to ensure timely invokation of ``close`` [#f2]_.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='449' col='7'/>
</memberdef>

<memberdef kind='alias' id='alias_io_serial_dispose'>
<name>dispose</name>
<initializer>= close</initializer>
<detaileddescription>
<para>Effectively makes ``io.Serial`` a *disposable* class [#f2]_.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='455' col='8'/>
</memberdef>

<memberdef kind='function' id='function_io_serial_read'>
<functionkind>named-function</functionkind>
<name>read</name>
<type><ref refid="typedef_size_t">size_t</ref> errorcode</type>
<argsstring>(io.Serial safe* this, void* p, size_t size)</argsstring>
<param>
<declname>p</declname>
<type>void*</type>
<array></array>
</param>
<param>
<declname>size</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<detaileddescription>
<para>Attempts to read up to ``size`` bytes from the serial port into the buffer pointed to by ``p``.

Returns the actual amount of bytes read on success. If read operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

Normally you would call this function from within your event handler for ``IncomingData`` event. If this function is called when there is no incoming data, it blocks until either the data arrives, or the serial port is closed.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='465' col='19'/>
</memberdef>

<memberdef kind='function' id='function_io_serial_write'>
<functionkind>named-function</functionkind>
<name>write</name>
<type><ref refid="typedef_size_t">size_t</ref> errorcode</type>
<argsstring>(io.Serial safe* this, void const* p, size_t size)</argsstring>
<param>
<declname>p</declname>
<type>void const*</type>
<array></array>
</param>
<param>
<declname>size</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<detaileddescription>
<para>Attempts to write ``size`` bytes from the buffer pointed to by ``p`` to the serial port.

Returns the actual amount of bytes written on success. If write operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

If the return value shows *less* bytes than specified by ``size`` argument, you should suspend further transmission until the file stream is ready to accept more data. When this happens, ``TransmitBufferReady`` event is fired and transmission could be resumed.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='478' col='19'/>
</memberdef>

<memberdef kind='event' id='struct_member_io_serial_iface_m_onserialevent'>
<name>m_onSerialEvent</name>
<type>multicast</type>
<argsstring>(io.SerialEventParams const* params)</argsstring>
<param>
<declname>params</declname>
<type><ref refid="type_io_serialeventparams">io.SerialEventParams</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>This event is fired whenever an event occurs on the serial port.

For the list of possible events, refer to `io.SerialEventCode` enumeration.

Event handler receives a single argument of type `io.SerialEventParams` which holds parameters of the particular event [#f3]_.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='491' col='8'/>
</memberdef>

</sectiondef>
<sectiondef>
<memberdef kind='footnote'>
<name>f3</name>
<detaileddescription>
<para>|footnote-sync-id|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f4</name>
<detaileddescription>
<para>|footnote-set-property-fail|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f1</name>
<detaileddescription>
<para>|footnote-errorcode|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f2</name>
<detaileddescription>
<para>|footnote-disposable|</para>
</detaileddescription>
</memberdef>
</sectiondef>
<includes>io_base.jncx</includes>
<includes>io_Serial.jnc</includes>
<briefdescription><para>This class provides high-level asynchronous interface for accessing hardware or virtual serial ports.</para></briefdescription>
<detaileddescription>
<para>Serial ports are represented as *files* in most operating systems, so working with serial port looks pretty much the same as working with any other file stream. However, besides ``read`` and ``write`` operations serial port files also expose a set of serial-specific properties such as baud rate, status and control lines and so on.

A typical sequence of steps when working with a serial port usually looks like this:

* Assign your event handler using ``m_onSerialEvent`` (you would probably also want to *schedule* your event handler to be run in particular environment, e.g. in specific thread)
* Open a serial port with ``open`` method;
* Configure serial port settings (``m_baudRate``, ``m_dataBits`` etc)
* When ``IncomingData`` event is fired, read from the serial port using ``read`` method;
* Write to the serial port stream using ``write`` method;
* Suspend writing if the return value of ``write`` is less than requested;
* Resume writing on ``TransmitBufferReady`` event;
* Close the serial port when no longer needed with ``close`` method.

.. rubric:: Sample code:

.. ref-code-block::

	class MyDialog
	{
		// ...

		io.Serial m_serial;

		construct ();

		open (
			char const* portName,
			uint_t baudRate
			);

		onWriteButtonClicked ();
		onSerialEvent (`io.SerialEventParams` const* params);
	}

	MyDialog.construct ()
	{
		// ...
		m_serial.m_onSerialEvent += onSerialEvent @ g_mainThreadScheduler;
	}

	MyDialog.open (
		char const* portName,
		uint_t baudRate
		)
	{
		m_serial.open (portName);
		m_serial.m_baudRate = baudRate;
		m_serial.m_dataBits = 8;
		m_serial.m_stopBits = `io.SerialStopBits._1`;
		// ...

	catch:
		// handle the error...
	}

	MyDialog.onWriteButtonClicked ()
	{
		static char data [] = "a quick brown fox jumps over the lazy dog";
		m_serial.write (data, sizeof (data));
	}

	MyDialog.onSerialEvent (`io.SerialEventParams` const* params)
	{
		if (params.m_syncId != m_serial.m_syncId) // late event
			return;

		switch (params.m_code)
		{
		case `io.SerialEventCode.IncomingData`:
			char buffer [256];
			size_t size = m_serial.read (buffer, sizeof (buffer));
			// ...
			break;
		}
	}</para>
<para><simplesect kind='see'><para>`io.SerialEventParams`, `io.SerialEventCode`, `io.File`, `io.FileStream`</para></simplesect></para>
</detaileddescription>
<location file='io_Serial.jnc' line='356' col='14'/>
</compounddef>
</doxygen>
