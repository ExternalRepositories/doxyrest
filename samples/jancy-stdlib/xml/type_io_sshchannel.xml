<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='class' id='type_io_sshchannel' language='Jancy'>
<compoundname>SshChannel</compoundname>

<sectiondef>
<memberdef kind='function' id='function_io_sshchannel_construct'>
<functionkind>construct</functionkind>
<name>construct</name>
<type>void</type>
<argsstring>(io.SshChannel safe* this)</argsstring>
<location file='io_Ssh.jnc' line='302' col='2'/>
</memberdef>
<memberdef kind='function' id='function_io_sshchannel_destruct'>
<functionkind>destruct</functionkind>
<name>destruct</name>
<type>void</type>
<argsstring>(io.SshChannel safe* this)</argsstring>
<location file='io_Ssh.jnc' line='303' col='2'/>
</memberdef>
</sectiondef>

<sectiondef>
<memberdef kind='property' id='property_io_sshchannel_m_address'>
<name>m_address</name>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref> const property</type>
<argsstring>(io.SshChannel safe const* this)</argsstring>
<detaileddescription>
<para>This property is used for getting the local address assigned to this socket. If the address has not been assigned yet, returns empty address.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='282' col='31'/>
</memberdef>

<memberdef kind='property' id='property_io_sshchannel_m_peeraddress'>
<name>m_peerAddress</name>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref> const property</type>
<argsstring>(io.SshChannel safe const* this)</argsstring>
<detaileddescription>
<para>This property is used for getting the remote address of the peer this socket is connected to. If the connection has not been established yet, returns empty address.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='288' col='31'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_sshchannel_iface_m_isopen' readonly='yes'>
<name>m_isOpen</name>
<type>bool</type>
<modifiers>readonly</modifiers>
<detaileddescription>
<para>Holds the open status for the SSH channel, i.e. ``true`` if opened; ``false`` otherwise.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='294' col='16'/>
</memberdef>

<memberdef kind='variable' id='struct_member_io_sshchannel_iface_m_syncid'>
<name>m_syncId</name>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<detaileddescription>
<para>Holds the synchronization ID for the SSH channel [#f3]_.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='300' col='9'/>
</memberdef>

<memberdef kind='function' id='function_io_sshchannel_open'>
<functionkind>named-function</functionkind>
<name>open</name>
<type>bool errorcode</type>
<argsstring>(io.SshChannel safe* this, io.SocketAddress const* address null)</argsstring>
<param>
<declname>address</declname>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref> const*</type>
<array></array>
<defval>null</defval>
</param>
<detaileddescription>
<para>Opens a ``TCP`` socket this connection will use for transport.

Returns ``true`` on success. If a new socket could not be opened, IO error supplied by operating system is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='311' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_sshchannel_close'>
<functionkind>named-function</functionkind>
<name>close</name>
<type>void</type>
<argsstring>(io.SshChannel safe* this)</argsstring>
<detaileddescription>
<para>Closes ``SSH`` channel and underlying ``TCP`` socket; does nothing if connection is not and not being established.

Sometimes it may be convenient to use *disposable* pattern to ensure timely invokation of ``close`` [#f2]_.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='319' col='7'/>
</memberdef>

<memberdef kind='alias' id='alias_io_sshchannel_dispose'>
<name>dispose</name>
<initializer>= close</initializer>
<detaileddescription>
<para>Effectively makes ``io.SshChannel`` a *disposable* class [#f2]_.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='325' col='8'/>
</memberdef>

<memberdef kind='function' id='function_io_sshchannel_connect'>
<functionkind>named-function</functionkind>
<name>connect</name>
<type>bool errorcode</type>
<argsstring>(io.SshChannel safe* this, io.SocketAddress const* address, char const* userName, char const* password, char const* channelType "session", char const* processType "shell", char const* ptyType "ansi", uint_t ptyWidth 80, uint_t ptyHeight 24, bool isSync false)</argsstring>
<param>
<declname>address</declname>
<type><ref refid="type_io_socketaddress">io.SocketAddress</ref> const*</type>
<array></array>
</param>
<param>
<declname>userName</declname>
<type>char const*</type>
<array></array>
</param>
<param>
<declname>password</declname>
<type>char const*</type>
<array></array>
</param>
<param>
<declname>channelType</declname>
<type>char const*</type>
<array></array>
<defval>"session"</defval>
</param>
<param>
<declname>processType</declname>
<type>char const*</type>
<array></array>
<defval>"shell"</defval>
</param>
<param>
<declname>ptyType</declname>
<type>char const*</type>
<array></array>
<defval>"ansi"</defval>
</param>
<param>
<declname>ptyWidth</declname>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<array></array>
<defval>80</defval>
</param>
<param>
<declname>ptyHeight</declname>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<array></array>
<defval>24</defval>
</param>
<param>
<declname>isSync</declname>
<type>bool</type>
<array></array>
<defval>false</defval>
</param>
<detaileddescription>
<para>Initiates a connection request to ``address``.

The meanings of the arguments for this function are as follows:

* ``address`` specifes the remote ``SSH`` server to connect to;
* ``userName`` and ``password`` specify user credential used to login to this SSH server;
* ``channelType`` specifies the type of the channel to establish (typically, ``session``; can also be ``direct-tcpip``, ``tcpip-forward`` etc);
* ``processType`` specifies what kind of process to run on the server side of this ``SSH`` channel (typically, ``shell``; can also be ``exec``, ``subsystem`` etc);
* ``ptyType`` specifies what type of pseudo terminal kind of process to run on the server side of this ``SSH`` channel (typically, ``xterm``; can also be ``ansi``, ``vanilla`` etc);
* ``ptyWidth`` and ``ptyHeight`` specify the size of the pseudo-terminal;
* ``isSync`` specifies whether this is a synchronous connect.

Returns ``true`` on success. If a connection could not be initiated, corresponding error is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='343' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_sshchannel_authenticate'>
<functionkind>named-function</functionkind>
<name>authenticate</name>
<type>bool errorcode</type>
<argsstring>(io.SshChannel safe* this, char const* userName, char const* password)</argsstring>
<param>
<declname>userName</declname>
<type>char const*</type>
<array></array>
</param>
<param>
<declname>password</declname>
<type>char const*</type>
<array></array>
</param>
<detaileddescription>
<para>Sends a request to SSH server to re-authenticate on ``AuthError`` event.

Returns ``true`` on success. If re-authenticate request could not be sent, returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='361' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_sshchannel_resizepty'>
<functionkind>named-function</functionkind>
<name>resizePty</name>
<type>bool errorcode</type>
<argsstring>(io.SshChannel safe* this, uint_t width, uint_t height, bool isSync false)</argsstring>
<param>
<declname>width</declname>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<array></array>
</param>
<param>
<declname>height</declname>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<array></array>
</param>
<param>
<declname>isSync</declname>
<type>bool</type>
<array></array>
<defval>false</defval>
</param>
<detaileddescription>
<para>Sends a request to SSH server to resize pseudo-terminal to ``width`` x ``height``. If ``isSync`` is ``true`` then this method does not return until the remote server completes the request.

Returns ``true`` on success. If pseudo-terminal could not be resized, error returned by the remote server is set and then the function returns ``false`` [#f1]_.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='372' col='17'/>
</memberdef>

<memberdef kind='function' id='function_io_sshchannel_read'>
<functionkind>named-function</functionkind>
<name>read</name>
<type><ref refid="typedef_size_t">size_t</ref> errorcode</type>
<argsstring>(io.SshChannel safe* this, void* p, size_t size)</argsstring>
<param>
<declname>p</declname>
<type>void*</type>
<array></array>
</param>
<param>
<declname>size</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<detaileddescription>
<para>Attempts to receive up to ``size`` bytes from the SSH socket into the buffer pointed to by ``p``.

Returns the actual amount of bytes read on success. If read operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

Normally you would call this function from within your event handler for ``IncomingData`` event. If this function is called when there is no incoming data, it blocks until either the data arrives, or the socket is closed.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='386' col='19'/>
</memberdef>

<memberdef kind='function' id='function_io_sshchannel_write'>
<functionkind>named-function</functionkind>
<name>write</name>
<type><ref refid="typedef_size_t">size_t</ref> errorcode</type>
<argsstring>(io.SshChannel safe* this, void const* p, size_t size)</argsstring>
<param>
<declname>p</declname>
<type>void const*</type>
<array></array>
</param>
<param>
<declname>size</declname>
<type><ref refid="typedef_size_t">size_t</ref></type>
<array></array>
</param>
<detaileddescription>
<para>Attempts to send ``size`` bytes from the buffer pointed to by ``p`` over the established SSH channel.

Returns the actual amount of bytes written on success. If write operation is unsuccessful, IO error supplied by the operating system is set and then the function returns ``-1`` [#f1]_.

If the return value shows *less* bytes than specified by ``size`` argument, you should suspend further transmission until the file stream is ready to accept more data. When this happens, ``TransmitBufferReady`` event is fired and transmission could be resumed.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='399' col='19'/>
</memberdef>

<memberdef kind='event' id='struct_member_io_sshchannel_iface_m_onsshevent'>
<name>m_onSshEvent</name>
<type>multicast</type>
<argsstring>(io.SshEventParams const* params)</argsstring>
<param>
<declname>params</declname>
<type><ref refid="type_io_ssheventparams">io.SshEventParams</ref> const*</type>
<array></array>
</param>
<detaileddescription>
<para>This event is fired whenever an event occurs on the SSH socket.

For the list of possible events, refer to `io.SshEventCode` enumeration.

Event handler receives a single argument of type `io.SshEventParams` which holds parameters of the particular event [#f3]_.</para>
</detaileddescription>
<location file='io_Ssh.jnc' line='412' col='8'/>
</memberdef>

</sectiondef>
<sectiondef>
<memberdef kind='footnote'>
<name>f1</name>
<detaileddescription>
<para>|footnote-errorcode|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f2</name>
<detaileddescription>
<para>|footnote-disposable|</para>
</detaileddescription>
</memberdef>
<memberdef kind='footnote'>
<name>f3</name>
<detaileddescription>
<para>|footnote-sync-id|</para>
</detaileddescription>
</memberdef>
</sectiondef>
<includes>io_ssh.jncx</includes>
<briefdescription><para>This class provides high-level asynchronous interface for client-side SSH connections.</para></briefdescription>
<detaileddescription>
<para>Under the hood ``io.SshChannel`` uses libssh2 library.

A typical sequence of steps when establishing an SSH connection looks like this:

* Assign your event handler using ``m_onSshEvent`` (you would probably also want to *schedule* your event handler to be run in particular environment, e.g. in specific thread);
* Call ``open`` method to open underlying socket;
* Call ``connect`` method to initate connection to ``SSH`` server;
* If ``SshAuthError`` event is fired, you can re-authenticate using ``authenticate`` method;
* Wait until ``ConnectCompleted`` or ``ConnectError`` event;
* When ``IncomingData`` event is fired, read from the file using ``read`` method;
* Write to the file stream using ``write`` method;
* Suspend writing if the return value of ``write`` is less than requested;
* Resume writing on ``TransmitBufferReady`` event;
* Close the SSH channel when no longer needed with ``close`` method.

.. rubric:: Sample code:

.. ref-code-block::

	class MyDialog
	{
		// ...

		io.SshChannel m_ssh;

		construct ();

		open (
			char const* portName,
			uint_t baudRate
			);

		onWriteButtonClicked ();
		onSshEvent (`io.SshEventParams` const* params);
	}

	MyDialog.construct ()
	{
		// ...
		m_ssh.m_onSshEvent += onSshEvent @ g_mainThreadScheduler;
	}

	MyDialog.connect (
		char const* addrString,
		char const* userName,
		char const* password
		)
	{
		`io.SocketAddress` sockAddr;
		sockAddr.parse (addrString);

		m_ssh.open ();
		m_ssh.connect (sockAddr, userName, password);

	catch:
		// handle the error...
	}

	MyDialog.onSendButtonClicked ()
	{
		static char data [] = "a quick brown fox jumps over the lazy dog";
		m_ssh.send (data, sizeof (data));
	}

	MyDialog.onSshEvent (`io.SshEventParams` const* params)
	{
		if (params.m_syncId != m_ssh.m_syncId) // late event
			return;

		switch (params.m_code)
		{
		case `io.SshEventCode.SshAuthError`:
			// show some kind of login dialog...
			// ... then re-authenticate:
			m_ssh.authenticate (userName, password);
			break;

		case `io.SshEventCode.ConnectError`:
			// handle error (extended info is at: params.m_error)...
			break;

		case `io.SshEventCode.ConnectCompleted`:
			// handle successfull connection...
			break;

		case `io.SshEventCode.IncomingData`:
			char buffer [256];
			size_t size = m_ssh.recv (buffer, sizeof (buffer));
			// ...
			break;
		}
	}</para>
<para><simplesect kind='see'><para>`io.Socket`, `io.SocketAddress`, `io.SocketAddressResolver`</para></simplesect></para>
</detaileddescription>
<location file='io_Ssh.jnc' line='276' col='14'/>
</compounddef>
</doxygen>
