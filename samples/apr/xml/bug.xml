<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="bug" kind="page">
    <compoundname>bug</compoundname>
    <title>Bug List</title>
    <detaileddescription>
<para><variablelist>
<varlistentry><term><anchor id="bug_1_bug000001"/>Global <ref refid="group__apr__dso_1gaedc8609c2bb76e5c43f2df2281a9d8b6" kindref="member">apr_dso_load</ref>  (apr_dso_handle_t **res_handle, const char *path, apr_pool_t *ctx)</term></varlistentry>
<listitem><para>We aught to provide an alternative to RTLD_GLOBAL, which is the only supported method of loading DSOs today.  </para></listitem>
<varlistentry><term><anchor id="bug_1_bug000003"/>Global <ref refid="group__apr__file__io_1gaae3b81342d239c58c351cf11190740ed" kindref="member">apr_file_pipe_create</ref>  (apr_file_t **in, apr_file_t **out, apr_pool_t *pool)</term></varlistentry>
<listitem><para>Some platforms cannot toggle between blocking and nonblocking, and when passing a pipe as a standard handle to an application which does not expect it, a non-blocking stream will fluxor the client app.  </para></listitem>
<varlistentry><term><anchor id="bug_1_bug000002"/>Global <ref refid="group__apr__filepath_1gabb57ce7b23caf512d7f64b92a662ab3d" kindref="member">APR_FILEPATH_NOTABOVEROOT</ref>  </term></varlistentry>
<listitem><para>in APR 0.9 and 1.x, this flag&apos;s behavior is undefined if the rootpath is NULL or empty. In APR 2.0 this should be changed to imply NOTABSOLUTE if the rootpath is NULL or empty.  </para></listitem>
<varlistentry><term><anchor id="bug_1_bug000010"/>Global <ref refid="group__apr__thread__proc_1gaf8d2be452a819161aa4cd6205a17761e" kindref="member">apr_proc_other_child_register</ref>  (<ref refid="structapr__proc__t" kindref="compound">apr_proc_t</ref> *proc, void(*maintenance)(int reason, void *, int status), void *data, apr_file_t *write_fd, apr_pool_t *p)</term></varlistentry>
<listitem><para>write_fd duplicates the proc-&gt;out stream, it&apos;s really redundant and should be replaced in the APR 1.0 API with a bitflag of which proc-&gt;in/out/err handles should be health checked. </para><para>no platform currently tests the pipes health.  </para></listitem>
<varlistentry><term><anchor id="bug_1_bug000011"/>Global <ref refid="structapr__proc__t_1a72ed1c58c3f08ffa7202fa80e870cd54" kindref="member">apr_proc_t::invoked</ref>  </term></varlistentry>
<listitem><para>This should either always or never be present in release builds - since it breaks binary compatibility. We may enable it always in APR 1.0 yet leave it undefined in most cases.  </para></listitem>
<varlistentry><term><anchor id="bug_1_bug000009"/>Global <ref refid="group__apr__thread__proc_1ga506183074e8413c3ff597539e4768ea4" kindref="member">apr_proc_wait_all_procs</ref>  (<ref refid="structapr__proc__t" kindref="compound">apr_proc_t</ref> *proc, int *exitcode, apr_exit_why_e *exitwhy, apr_wait_how_e waithow, apr_pool_t *p)</term></varlistentry>
<listitem><para>Passing proc as a *proc rather than **proc was an odd choice for some platforms... this should be revisited in 1.0  </para></listitem>
<varlistentry><term><anchor id="bug_1_bug000008"/>Global <ref refid="group__apr__thread__proc_1ga6fad364c6c820e37c0915435cfb3921f" kindref="member">apr_procattr_child_err_set</ref>  (struct apr_procattr_t *attr, apr_file_t *child_err, apr_file_t *parent_err)</term></varlistentry>
<listitem><para>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported. </para></listitem>
<varlistentry><term><anchor id="bug_1_bug000006"/>Global <ref refid="group__apr__thread__proc_1ga24f40119b1aa07dd45a681a44915cb1b" kindref="member">apr_procattr_child_in_set</ref>  (struct apr_procattr_t *attr, apr_file_t *child_in, apr_file_t *parent_in)</term></varlistentry>
<listitem><para>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported. </para></listitem>
<varlistentry><term><anchor id="bug_1_bug000007"/>Global <ref refid="group__apr__thread__proc_1gabb97e9a49021ab4452ae3f1a281c977f" kindref="member">apr_procattr_child_out_set</ref>  (struct apr_procattr_t *attr, apr_file_t *child_out, apr_file_t *parent_out)</term></varlistentry>
<listitem><para>Note that calling this function with two NULL files on some platforms creates an APR_FULL_BLOCK pipe, but this behavior is neither portable nor is it supported. </para></listitem>
<varlistentry><term><anchor id="bug_1_bug000004"/>Global <ref refid="group__apr__network__io_1ga270b7c0835283fa2b85a05d295dd7ee5" kindref="member">apr_socket_accept_filter</ref>  (apr_socket_t *sock, char *name, char *args)</term></varlistentry>
<listitem><para>name and args should have been declared as const char *, as they are in APR 2.0  </para></listitem>
<varlistentry><term><anchor id="bug_1_bug000005"/>Global <ref refid="group__apr__strings_1ga1583688e0777398174f62e46a522ae8f" kindref="member">apr_strtoff</ref>  (apr_off_t *offset, const char *buf, char **end, int base)</term></varlistentry>
<listitem><para>*end breaks type safety; where *buf is const, *end needs to be declared as const in APR 2.0 </para></listitem>
</variablelist>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
