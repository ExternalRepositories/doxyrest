<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="apr__thread__cond_8h" kind="file" language="C++">
    <compoundname>apr_thread_cond.h</compoundname>
    <includes refid="apr_8h" local="yes">apr.h</includes>
    <includes refid="apr__pools_8h" local="yes">apr_pools.h</includes>
    <includes refid="apr__errno_8h" local="yes">apr_errno.h</includes>
    <includes refid="apr__time_8h" local="yes">apr_time.h</includes>
    <includes refid="apr__thread__mutex_8h" local="yes">apr_thread_mutex.h</includes>
    <incdepgraph>
      <node id="796">
        <label>stdint.h</label>
      </node>
      <node id="801">
        <label>errno.h</label>
      </node>
      <node id="808">
        <label>apr_time.h</label>
        <link refid="apr__time_8h"/>
        <childnode refid="793" relation="include">
        </childnode>
        <childnode refid="799" relation="include">
        </childnode>
        <childnode refid="800" relation="include">
        </childnode>
      </node>
      <node id="802">
        <label>apr_general.h</label>
        <link refid="apr__general_8h"/>
        <childnode refid="793" relation="include">
        </childnode>
        <childnode refid="799" relation="include">
        </childnode>
        <childnode refid="800" relation="include">
        </childnode>
        <childnode refid="803" relation="include">
        </childnode>
      </node>
      <node id="798">
        <label>limits.h</label>
      </node>
      <node id="794">
        <label>sys/types.h</label>
      </node>
      <node id="805">
        <label>string.h</label>
      </node>
      <node id="807">
        <label>apr_thread_mutex.h</label>
        <link refid="apr__thread__mutex_8h"/>
        <childnode refid="793" relation="include">
        </childnode>
        <childnode refid="800" relation="include">
        </childnode>
        <childnode refid="799" relation="include">
        </childnode>
      </node>
      <node id="799">
        <label>apr_pools.h</label>
        <link refid="apr__pools_8h"/>
        <childnode refid="793" relation="include">
        </childnode>
        <childnode refid="800" relation="include">
        </childnode>
        <childnode refid="802" relation="include">
        </childnode>
        <childnode refid="804" relation="include">
        </childnode>
        <childnode refid="806" relation="include">
        </childnode>
      </node>
      <node id="806">
        <label>apr_allocator.h</label>
        <link refid="apr__allocator_8h"/>
        <childnode refid="793" relation="include">
        </childnode>
        <childnode refid="800" relation="include">
        </childnode>
        <childnode refid="804" relation="include">
        </childnode>
        <childnode refid="799" relation="include">
        </childnode>
        <childnode refid="807" relation="include">
        </childnode>
      </node>
      <node id="803">
        <label>signal.h</label>
      </node>
      <node id="800">
        <label>apr_errno.h</label>
        <link refid="apr__errno_8h"/>
        <childnode refid="793" relation="include">
        </childnode>
        <childnode refid="801" relation="include">
        </childnode>
      </node>
      <node id="797">
        <label>sys/wait.h</label>
      </node>
      <node id="793">
        <label>apr.h</label>
        <link refid="apr_8h"/>
        <childnode refid="794" relation="include">
        </childnode>
        <childnode refid="795" relation="include">
        </childnode>
        <childnode refid="796" relation="include">
        </childnode>
        <childnode refid="797" relation="include">
        </childnode>
        <childnode refid="798" relation="include">
        </childnode>
      </node>
      <node id="795">
        <label>sys/socket.h</label>
      </node>
      <node id="804">
        <label>apr_want.h</label>
        <link refid="apr__want_8h"/>
        <childnode refid="793" relation="include">
        </childnode>
        <childnode refid="805" relation="include">
        </childnode>
      </node>
      <node id="792">
        <label>apr_thread_cond.h</label>
        <link refid="apr__thread__cond_8h"/>
        <childnode refid="793" relation="include">
        </childnode>
        <childnode refid="799" relation="include">
        </childnode>
        <childnode refid="800" relation="include">
        </childnode>
        <childnode refid="808" relation="include">
        </childnode>
        <childnode refid="807" relation="include">
        </childnode>
      </node>
    </incdepgraph>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__apr__thread__cond_1gae8f918d38bf1c58bc09670eee456ae5e" prot="public" static="no">
        <type>struct <ref refid="group__apr__thread__cond_1gae8f918d38bf1c58bc09670eee456ae5e" kindref="member">apr_thread_cond_t</ref></type>
        <definition>typedef struct apr_thread_cond_t apr_thread_cond_t</definition>
        <argsstring></argsstring>
        <name>apr_thread_cond_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Opaque structure for thread condition variables </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/apr_thread_cond.h" line="90" column="1" bodyfile="include/apr_thread_cond.h" bodystart="44" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__apr__thread__cond_1gab39e8b722d46d23466e9e346ada85a7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__apr__errno_1gaf76ee4543247e9fb3f3546203e590a6c" kindref="member">apr_status_t</ref></type>
        <definition>apr_status_t apr_thread_cond_create</definition>
        <argsstring>(apr_thread_cond_t **cond, apr_pool_t *pool)</argsstring>
        <name>apr_thread_cond_create</name>
        <param>
          <type><ref refid="group__apr__thread__cond_1gae8f918d38bf1c58bc09670eee456ae5e" kindref="member">apr_thread_cond_t</ref> **</type>
          <declname>cond</declname>
        </param>
        <param>
          <type><ref refid="group__apr__pools_1gaf137f28edcf9a086cd6bc36c20d7cdfb" kindref="member">apr_pool_t</ref> *</type>
          <declname>pool</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Note: destroying a condition variable (or likewise, destroying or clearing the pool from which a condition variable was allocated) if any threads are blocked waiting on it gives undefined results. Create and initialize a condition variable that can be used to signal and schedule threads in a single process. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cond</parametername>
</parameternamelist>
<parameterdescription>
<para>the memory address where the newly created condition variable will be stored. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pool</parametername>
</parameternamelist>
<parameterdescription>
<para>the pool from which to allocate the condition. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/apr_thread_cond.h" line="59" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__apr__thread__cond_1ga789719a5f02bdab8b8abbc8bddd0406b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__apr__errno_1gaf76ee4543247e9fb3f3546203e590a6c" kindref="member">apr_status_t</ref></type>
        <definition>apr_status_t apr_thread_cond_wait</definition>
        <argsstring>(apr_thread_cond_t *cond, apr_thread_mutex_t *mutex)</argsstring>
        <name>apr_thread_cond_wait</name>
        <param>
          <type><ref refid="group__apr__thread__cond_1gae8f918d38bf1c58bc09670eee456ae5e" kindref="member">apr_thread_cond_t</ref> *</type>
          <declname>cond</declname>
        </param>
        <param>
          <type><ref refid="group__apr__thread__mutex_1ga95712060ba3a192036416e1ccef1db75" kindref="member">apr_thread_mutex_t</ref> *</type>
          <declname>mutex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Put the active calling thread to sleep until signaled to wake up. Each condition variable must be associated with a mutex, and that mutex must be locked before calling this function, or the behavior will be undefined. As the calling thread is put to sleep, the given mutex will be simultaneously released; and as this thread wakes up the lock is again simultaneously acquired. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cond</parametername>
</parameternamelist>
<parameterdescription>
<para>the condition variable on which to block. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mutex</parametername>
</parameternamelist>
<parameterdescription>
<para>the mutex that must be locked upon entering this function, is released while the thread is asleep, and is again acquired before returning from this function. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="remark"><para>Spurious wakeups may occur. Before and after every call to wait on a condition variable, the caller should test whether the condition is already met. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/apr_thread_cond.h" line="77" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__apr__thread__cond_1ga67f2feecb7fa1929cc9b354dafd00306" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__apr__errno_1gaf76ee4543247e9fb3f3546203e590a6c" kindref="member">apr_status_t</ref></type>
        <definition>apr_status_t apr_thread_cond_timedwait</definition>
        <argsstring>(apr_thread_cond_t *cond, apr_thread_mutex_t *mutex, apr_interval_time_t timeout)</argsstring>
        <name>apr_thread_cond_timedwait</name>
        <param>
          <type><ref refid="group__apr__thread__cond_1gae8f918d38bf1c58bc09670eee456ae5e" kindref="member">apr_thread_cond_t</ref> *</type>
          <declname>cond</declname>
        </param>
        <param>
          <type><ref refid="group__apr__thread__mutex_1ga95712060ba3a192036416e1ccef1db75" kindref="member">apr_thread_mutex_t</ref> *</type>
          <declname>mutex</declname>
        </param>
        <param>
          <type><ref refid="group__apr__time_1gaae2129185a395cc393f76fabf4f43e47" kindref="member">apr_interval_time_t</ref></type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Put the active calling thread to sleep until signaled to wake up or the timeout is reached. Each condition variable must be associated with a mutex, and that mutex must be locked before calling this function, or the behavior will be undefined. As the calling thread is put to sleep, the given mutex will be simultaneously released; and as this thread wakes up the lock is again simultaneously acquired. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cond</parametername>
</parameternamelist>
<parameterdescription>
<para>the condition variable on which to block. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mutex</parametername>
</parameternamelist>
<parameterdescription>
<para>the mutex that must be locked upon entering this function, is released while the thread is asleep, and is again acquired before returning from this function. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>The amount of time in microseconds to wait. This is a maximum, not a minimum. If the condition is signaled, we will wake up before this time, otherwise the error APR_TIMEUP is returned. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/apr_thread_cond.h" line="96" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__apr__thread__cond_1gadf7ad6c2731bc6128f969d3efc7ff5eb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__apr__errno_1gaf76ee4543247e9fb3f3546203e590a6c" kindref="member">apr_status_t</ref></type>
        <definition>apr_status_t apr_thread_cond_signal</definition>
        <argsstring>(apr_thread_cond_t *cond)</argsstring>
        <name>apr_thread_cond_signal</name>
        <param>
          <type><ref refid="group__apr__thread__cond_1gae8f918d38bf1c58bc09670eee456ae5e" kindref="member">apr_thread_cond_t</ref> *</type>
          <declname>cond</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Signals a single thread, if one exists, that is blocking on the given condition variable. That thread is then scheduled to wake up and acquire the associated mutex. Although it is not required, if predictable scheduling is desired, that mutex must be locked while calling this function. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cond</parametername>
</parameternamelist>
<parameterdescription>
<para>the condition variable on which to produce the signal. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="remark"><para>If no threads are waiting on the condition variable, nothing happens. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/apr_thread_cond.h" line="108" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__apr__thread__cond_1gafbbedd2a07629fe3186343035ae83152" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__apr__errno_1gaf76ee4543247e9fb3f3546203e590a6c" kindref="member">apr_status_t</ref></type>
        <definition>apr_status_t apr_thread_cond_broadcast</definition>
        <argsstring>(apr_thread_cond_t *cond)</argsstring>
        <name>apr_thread_cond_broadcast</name>
        <param>
          <type><ref refid="group__apr__thread__cond_1gae8f918d38bf1c58bc09670eee456ae5e" kindref="member">apr_thread_cond_t</ref> *</type>
          <declname>cond</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Signals all threads blocking on the given condition variable. Each thread that was signaled is then scheduled to wake up and acquire the associated mutex. This will happen in a serialized manner. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cond</parametername>
</parameternamelist>
<parameterdescription>
<para>the condition variable on which to produce the broadcast. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="remark"><para>If no threads are waiting on the condition variable, nothing happens. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/apr_thread_cond.h" line="117" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__apr__thread__cond_1ga049e646e23c670f3a79fe25401b9c1b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__apr__errno_1gaf76ee4543247e9fb3f3546203e590a6c" kindref="member">apr_status_t</ref></type>
        <definition>apr_status_t apr_thread_cond_destroy</definition>
        <argsstring>(apr_thread_cond_t *cond)</argsstring>
        <name>apr_thread_cond_destroy</name>
        <param>
          <type><ref refid="group__apr__thread__cond_1gae8f918d38bf1c58bc09670eee456ae5e" kindref="member">apr_thread_cond_t</ref> *</type>
          <declname>cond</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Destroy the condition variable and free the associated memory. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>cond</parametername>
</parameternamelist>
<parameterdescription>
<para>the condition variable to destroy. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/apr_thread_cond.h" line="123" column="1"/>
      </memberdef>
      <memberdef kind="function" id="group__apr__thread__cond_1gafc2d7f2907eb12e5543c971a4c0140ee" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__apr__pools_1gaf137f28edcf9a086cd6bc36c20d7cdfb" kindref="member">apr_pool_t</ref> *</type>
        <definition>apr_pool_t* apr_thread_cond_pool_get</definition>
        <argsstring>(const apr_thread_cond_t *thethread_cond)</argsstring>
        <name>apr_thread_cond_pool_get</name>
        <param>
          <type>const <ref refid="group__apr__thread__cond_1gae8f918d38bf1c58bc09670eee456ae5e" kindref="member">apr_thread_cond_t</ref> *</type>
          <declname>thethread_cond</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get the pool used by this thread_cond. <simplesect kind="return"><para>apr_pool_t the pool </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/apr_thread_cond.h" line="129" column="1"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>APR Condition Variable Routines. </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="include/apr_thread_cond.h"/>
  </compounddef>
</doxygen>
