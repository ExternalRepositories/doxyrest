<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="pcm" kind="page">
    <compoundname>pcm</compoundname>
    <title>PCM (digital audio) interface</title>
    <detaileddescription>
<para>Although abbreviation PCM stands for Pulse Code Modulation, we are understanding it as general digital audio processing with volume samples generated in continuous time periods.</para><para>The analog signal is recorded via analog to digital converters (ADC). The digital value (de-facto a volume at a specific time) obtained from ADC can be further processed. The following picture shows a perfect sinus waveform:</para><para><linebreak/>
 <image type="html" name="wave1.gif"></image>
</para><para>Next image shows digitized representation:</para><para><linebreak/>
 <image type="html" name="wave2.gif"></image>
</para><para>As you may see, the quality of digital audio signal depends on the time (recording rate) and voltage resolution (usually in an linear integer representation with basic unit one bit).</para><para>The stored digital signal can be converted back to voltage (analog) representation via digital to analog converters (DAC).</para><para>One digital value is called sample. More samples are collected to frames (frame is terminology for ALSA) depending on count of converters used at one specific time. One frame might contain one sample (when only one converter is used - mono) or more samples (for example: stereo has signals from two converters recorded at same time). Digital audio stream contains collection of frames recorded at boundaries of continuous time periods.</para><sect1 id="pcm_1pcm_general_overview">
<title>General overview</title>
<para>ALSA uses the ring buffer to store outgoing (playback) and incoming (capture, record) samples. There are two pointers being maintained to allow a precise communication between application and device pointing to current processed sample by hardware and last processed sample by application. The modern audio chips allow to program the transfer time periods. It means that the stream of samples is divided to small chunks. Device acknowledges to application when the transfer of a chunk is complete.</para></sect1>
<sect1 id="pcm_1pcm_transfer">
<title>Transfer methods in UNIX environments</title>
<para>In the UNIX environment, data chunk acknowledges are received via standard I/O calls or event waiting routines (poll or select function). To accomplish this list, the asynchronous notification of acknowledges should be listed here. The ALSA implementation for these methods is described in the <ref refid="pcm_1alsa_transfers" kindref="member">ALSA transfers</ref> section.</para><sect2 id="pcm_1pcm_transfer_io">
<title>Standard I/O transfers</title>
<para>The standard I/O transfers are using the read (see &apos;man 2 read&apos;) and write (see &apos;man 2 write&apos;) C functions. There are two basic behaviours of these functions - blocked and non-blocked (see the O_NONBLOCK flag for the standard C open function - see &apos;man 2 open&apos;). In non-blocked behaviour, these I/O functions never stops, they return -EAGAIN error code, when no data can be transferred (the ring buffer is full in our case). In blocked behaviour, these I/O functions stop and wait until there is a room in the ring buffer (playback) or until there are a new samples (capture). The ALSA implementation can be found in the <ref refid="pcm_1alsa_pcm_rw" kindref="member">Read / Write transfer</ref> section.</para></sect2>
<sect2 id="pcm_1pcm_transfer_event">
<title>Event waiting routines</title>
<para>The poll or select functions (see &apos;man 2 poll&apos; or &apos;man 2 select&apos; for further details) allows to receive requests/events from the device while an application is waiting on events from other sources (like keyboard, screen, network etc.), too. <ref refid="group___p_c_m_1ga742e8705f6992fd0e36efc868e574f01" kindref="member">snd_pcm_poll_descriptors</ref> can be used to get file descriptors to poll or select on (note that wait direction might be different than expected - do not use only returned file descriptors, but handle events member as well - see <ref refid="group___p_c_m_1ga742e8705f6992fd0e36efc868e574f01" kindref="member">snd_pcm_poll_descriptors</ref> function description for more details and <ref refid="group___p_c_m_1ga7e561f305702c6f52dab49b6c84f7df7" kindref="member">snd_pcm_poll_descriptors_revents</ref> for events demangling). The implemented transfer routines can be found in the <ref refid="pcm_1alsa_transfers" kindref="member">ALSA transfers</ref> section.</para></sect2>
<sect2 id="pcm_1pcm_transfer_async">
<title>Asynchronous notification</title>
<para>ALSA driver and library knows to handle the asynchronous notifications over the SIGIO signal. This signal allows to interrupt application and transfer data in the signal handler. For further details see the sigaction function (&apos;man 2 sigaction&apos;). The section <ref refid="pcm_1pcm_async" kindref="member">Asynchronous mode</ref> describes the ALSA API for this extension. The implemented transfer routines can be found in the <ref refid="pcm_1alsa_transfers" kindref="member">ALSA transfers</ref> section.</para></sect2>
</sect1>
<sect1 id="pcm_1pcm_open_behaviour">
<title>Blocked and non-blocked open</title>
<para>The ALSA PCM API uses a different behaviour when the device is opened with blocked or non-blocked mode. The mode can be specified with <emphasis>mode</emphasis> argument in <ref refid="group___p_c_m_1ga8340c7dc0ac37f37afe5e7c21d6c528b" kindref="member">snd_pcm_open()</ref> function. The blocked mode is the default (without <ref refid="group___p_c_m_1ga6bd90de1d1527b5804090dcce51079ad" kindref="member">SND_PCM_NONBLOCK</ref> mode). In this mode, the behaviour is that if the resources have already used with another application, then it blocks the caller, until resources are free. The non-blocked behaviour (with <ref refid="group___p_c_m_1ga6bd90de1d1527b5804090dcce51079ad" kindref="member">SND_PCM_NONBLOCK</ref>) doesn&apos;t block the caller in any way and returns -EBUSY error when the resources are not available. Note that the mode also determines the behaviour of standard I/O calls, returning -EAGAIN when non-blocked mode is used and the ring buffer is full (playback) or empty (capture). The operation mode for I/O calls can be changed later with the <ref refid="group___p_c_m_1ga8d9ed4a62c17402de0389fd31fc7dc1f" kindref="member">snd_pcm_nonblock()</ref> function.</para></sect1>
<sect1 id="pcm_1pcm_async">
<title>Asynchronous mode</title>
<para>There is also possibility to receive asynchronous notification after specified time periods. You may see the <ref refid="group___p_c_m_1ga9b22351abf6c85ced128e2088f6f6a5c" kindref="member">SND_PCM_ASYNC</ref> mode for <ref refid="group___p_c_m_1ga8340c7dc0ac37f37afe5e7c21d6c528b" kindref="member">snd_pcm_open()</ref> function and <ref refid="group___p_c_m_1ga5a0c0da6d0d35a3ac9f6a97567ac3b63" kindref="member">snd_async_add_pcm_handler()</ref> function for further details.</para></sect1>
<sect1 id="pcm_1pcm_handshake">
<title>Handshake between application and library</title>
<para>The ALSA PCM API design uses the states to determine the communication phase between application and library. The actual state can be determined using <ref refid="group___p_c_m_1ga87896f6f17020fc19835790369e7ce75" kindref="member">snd_pcm_state()</ref> call. There are these states:</para><para><simplesect kind="par"><title>SND_PCM_STATE_OPEN</title><para>The PCM device is in the open state. After the <ref refid="group___p_c_m_1ga8340c7dc0ac37f37afe5e7c21d6c528b" kindref="member">snd_pcm_open()</ref> open call, the device is in this state. Also, when <ref refid="group___p_c_m_1ga1ca0dc120a484965e26cabf966502330" kindref="member">snd_pcm_hw_params()</ref> call fails, then this state is entered to force application calling <ref refid="group___p_c_m_1ga1ca0dc120a484965e26cabf966502330" kindref="member">snd_pcm_hw_params()</ref> function to set right communication parameters.</para></simplesect>
<simplesect kind="par"><title>SND_PCM_STATE_SETUP</title><para>The PCM device has accepted communication parameters and it is waiting for <ref refid="group___p_c_m_1ga788d05de75f2d536f8443cb0306754d0" kindref="member">snd_pcm_prepare()</ref> call to prepare the hardware for selected operation (playback or capture).</para></simplesect>
<simplesect kind="par"><title>SND_PCM_STATE_PREPARED</title><para>The PCM device is prepared for operation. Application can use <ref refid="group___p_c_m_1ga6bdb88b68a9d9e66015d770f600c6aea" kindref="member">snd_pcm_start()</ref> call, write or read data to start the operation.</para></simplesect>
<simplesect kind="par"><title>SND_PCM_STATE_RUNNING</title><para>The PCM device has been started and is running. It processes the samples. The stream can be stopped using the <ref refid="group___p_c_m_1ga7000ca6010a1a2739daddff8e2fbb440" kindref="member">snd_pcm_drop()</ref> or <ref refid="group___p_c_m_1ga49afc5b8527f30c33fafa476533c9f86" kindref="member">snd_pcm_drain()</ref> calls.</para></simplesect>
<simplesect kind="par"><title>SND_PCM_STATE_XRUN</title><para>The PCM device reached overrun (capture) or underrun (playback). You can use the -EPIPE return code from I/O functions (<ref refid="group___p_c_m_1gabc748a500743713eafa960c7d104ca6f" kindref="member">snd_pcm_writei()</ref>, <ref refid="group___p_c_m_1gae599772ce3d0aa6a70de143abcf145e7" kindref="member">snd_pcm_writen()</ref>, <ref refid="group___p_c_m_1ga4c2c7bd26cf221268d59dc3bbeb9c048" kindref="member">snd_pcm_readi()</ref>, <ref refid="group___p_c_m_1gafea175455f1a405f633a43484ded3d8a" kindref="member">snd_pcm_readn()</ref>) to determine this state without checking the actual state via <ref refid="group___p_c_m_1ga87896f6f17020fc19835790369e7ce75" kindref="member">snd_pcm_state()</ref> call. It is recommended to use the helper function <ref refid="group___p_c_m_1ga2157aaeb6fc14da3f040d76591f9d3b1" kindref="member">snd_pcm_recover()</ref> to recover from this state, but you can also use <ref refid="group___p_c_m_1ga788d05de75f2d536f8443cb0306754d0" kindref="member">snd_pcm_prepare()</ref>, <ref refid="group___p_c_m_1ga7000ca6010a1a2739daddff8e2fbb440" kindref="member">snd_pcm_drop()</ref> or <ref refid="group___p_c_m_1ga49afc5b8527f30c33fafa476533c9f86" kindref="member">snd_pcm_drain()</ref> calls.</para></simplesect>
<simplesect kind="par"><title>SND_PCM_STATE_DRAINING</title><para>The device is in this state when application using the capture mode called <ref refid="group___p_c_m_1ga49afc5b8527f30c33fafa476533c9f86" kindref="member">snd_pcm_drain()</ref> function. Until all data are read from the internal ring buffer using I/O routines (<ref refid="group___p_c_m_1ga4c2c7bd26cf221268d59dc3bbeb9c048" kindref="member">snd_pcm_readi()</ref>, <ref refid="group___p_c_m_1gafea175455f1a405f633a43484ded3d8a" kindref="member">snd_pcm_readn()</ref>), then the device stays in this state.</para></simplesect>
<simplesect kind="par"><title>SND_PCM_STATE_PAUSED</title><para>The device is in this state when application called the <ref refid="group___p_c_m_1gad711b582c7066bd4fffa1d08a04316b5" kindref="member">snd_pcm_pause()</ref> function until the pause is released. Not all hardware supports this feature. Application should check the capability with the <ref refid="group___p_c_m___h_w___params_1gaad4ba98b2f66baa5360b9a85f064a3e9" kindref="member">snd_pcm_hw_params_can_pause()</ref>.</para></simplesect>
<simplesect kind="par"><title>SND_PCM_STATE_SUSPENDED</title><para>The device is in the suspend state provoked with the power management system. The stream can be resumed using <ref refid="group___p_c_m_1ga13083ce2209aab9ea73831610bc61ab1" kindref="member">snd_pcm_resume()</ref> call, but not all hardware supports this feature. Application should check the capability with the <ref refid="group___p_c_m___h_w___params_1ga6b79539a34e6f51972f4c32b3296585a" kindref="member">snd_pcm_hw_params_can_resume()</ref>. In other case, the calls <ref refid="group___p_c_m_1ga788d05de75f2d536f8443cb0306754d0" kindref="member">snd_pcm_prepare()</ref>, <ref refid="group___p_c_m_1ga7000ca6010a1a2739daddff8e2fbb440" kindref="member">snd_pcm_drop()</ref>, <ref refid="group___p_c_m_1ga49afc5b8527f30c33fafa476533c9f86" kindref="member">snd_pcm_drain()</ref> can be used to leave this state.</para></simplesect>
<simplesect kind="par"><title>SND_PCM_STATE_DISCONNECTED</title><para>The device is physicaly disconnected. It does not accept any I/O calls in this state.</para></simplesect>
</para></sect1>
<sect1 id="pcm_1pcm_formats">
<title>PCM formats</title>
<para>The full list of formats present the <ref refid="group___p_c_m_1gaa14b7f26877a812acbb39811364177f8" kindref="member">snd_pcm_format_t</ref> type. The 24-bit linear samples use 32-bit physical space, but the sample is stored in the lower three bytes. Some hardware does not support processing of full range, thus you may get the significant bits for linear samples via <ref refid="group___p_c_m___h_w___params_1ga8bb1180b62a4225f0e094b95ac5d3674" kindref="member">snd_pcm_hw_params_get_sbits()</ref> function. The example: ICE1712 chips support 32-bit sample processing, but low byte is ignored (playback) or zero (capture). The function <ref refid="group___p_c_m___h_w___params_1ga8bb1180b62a4225f0e094b95ac5d3674" kindref="member">snd_pcm_hw_params_get_sbits()</ref> returns 24 in this case.</para></sect1>
<sect1 id="pcm_1alsa_transfers">
<title>ALSA transfers</title>
<para>There are two methods to transfer samples in application. The first method is the standard read / write one. The second method, uses the direct audio buffer to communicate with the device while ALSA library manages this space itself. You can find examples of all communication schemes for playback in <ref refid="pcm_1example_test_pcm" kindref="member">Sine-wave generator example</ref>. To complete the list, we should note that <ref refid="group___p_c_m_1gad4d53d58b996a7cd9a5cbf1710b90375" kindref="member">snd_pcm_wait()</ref> function contains embedded poll waiting implementation.</para><sect2 id="pcm_1alsa_pcm_rw">
<title>Read / Write transfer</title>
<para>There are two versions of read / write routines. The first expects the interleaved samples at input (<ref refid="group___p_c_m_1gga661221ba5e8f1d6eaf4ab8e2da57cc1aa72a970ed6e676ab0fd9f3c3d36737e0a" kindref="member">SND_PCM_ACCESS_RW_INTERLEAVED</ref> access method), and the second one expects non-interleaved (samples in separated buffers - <ref refid="group___p_c_m_1gga661221ba5e8f1d6eaf4ab8e2da57cc1aae7ab128d10c32667f396933190435071" kindref="member">SND_PCM_ACCESS_RW_NONINTERLEAVED</ref> access method) at input. There are these functions for interleaved transfers: <ref refid="group___p_c_m_1gabc748a500743713eafa960c7d104ca6f" kindref="member">snd_pcm_writei()</ref> <ref refid="group___p_c_m_1ga4c2c7bd26cf221268d59dc3bbeb9c048" kindref="member">snd_pcm_readi()</ref>. For non-interleaved transfers, there are these functions: <ref refid="group___p_c_m_1gae599772ce3d0aa6a70de143abcf145e7" kindref="member">snd_pcm_writen()</ref> and <ref refid="group___p_c_m_1gafea175455f1a405f633a43484ded3d8a" kindref="member">snd_pcm_readn()</ref>.</para></sect2>
<sect2 id="pcm_1alsa_mmap_rw">
<title>Direct Read / Write transfer (via mmap&apos;ed areas)</title>
<para>Three kinds of organization of ring buffer memory areas exist in ALSA API. Access <ref refid="group___p_c_m_1gga661221ba5e8f1d6eaf4ab8e2da57cc1aa90a5dea527c5ae9a53f1448beb2dee6f" kindref="member">SND_PCM_ACCESS_MMAP_INTERLEAVED</ref> has interleaved samples. Access <ref refid="group___p_c_m_1gga661221ba5e8f1d6eaf4ab8e2da57cc1aa7de225785e05dd1d538203c5ece9036e" kindref="member">SND_PCM_ACCESS_MMAP_NONINTERLEAVED</ref> expects continous sample areas for one channel. Access <ref refid="group___p_c_m_1gga661221ba5e8f1d6eaf4ab8e2da57cc1aa26a4f161364cb539df4de5eeb9949121" kindref="member">SND_PCM_ACCESS_MMAP_COMPLEX</ref> does not fit to interleaved and non-interleaved ring buffer organization.</para><para>There are two functions for this kind of transfer. Application can get an access to memory areas via <ref refid="group___p_c_m___direct_1ga6d4acf42de554d4d1177fb035d484ea4" kindref="member">snd_pcm_mmap_begin()</ref> function. This function returns the areas (single area is equal to a channel) containing the direct pointers to memory and sample position description in <ref refid="structsnd__pcm__channel__area__t" kindref="compound">snd_pcm_channel_area_t</ref> structure. After application transfers the data in the memory areas, then it must be acknowledged the end of transfer via <ref refid="group___p_c_m___direct_1gac306bd13c305825aa39dd9180a3ad520" kindref="member">snd_pcm_mmap_commit()</ref> function to allow the ALSA library update the pointers to ring buffer. This kind of communication is also called &quot;zero-copy&quot;, because the device does not require to copy the samples from application to another place in system memory.</para><para>If you like to use the compatibility functions in mmap mode, there are read / write routines equaling to standard read / write transfers. Using these functions discards the benefits of direct access to memory region. See the <ref refid="group___p_c_m___direct_1ga24b6c538c8d7ddd0776ee65f8fb909eb" kindref="member">snd_pcm_mmap_readi()</ref>, <ref refid="group___p_c_m___direct_1ga5a9ee8e1e764b12da6d54dfa195f7c52" kindref="member">snd_pcm_mmap_writei()</ref>, <ref refid="group___p_c_m___direct_1ga29ce9af60eafb67f0303418a176bf3ea" kindref="member">snd_pcm_mmap_readn()</ref> and <ref refid="group___p_c_m___direct_1ga092b1a7f387e9fc2977649bfd43b0958" kindref="member">snd_pcm_mmap_writen()</ref> functions. These functions use <ref refid="group___p_c_m___helpers_1gad57f8921f52ea2ffd870cafb2d076f2c" kindref="member">snd_pcm_areas_copy()</ref> internally.</para></sect2>
</sect1>
<sect1 id="pcm_1pcm_errors">
<title>Error codes</title>
<para><simplesect kind="par"><title>-EPIPE</title><para></para></simplesect>
This error means xrun (underrun for playback or overrun for capture). The underrun can happen when an application does not feed new samples in time to alsa-lib (due CPU usage). The overrun can happen when an application does not take new captured samples in time from alsa-lib.</para><para><simplesect kind="par"><title>-ESTRPIPE</title><para></para></simplesect>
This error means that system has suspended drivers. The application should wait in loop when <ref refid="group___p_c_m_1ga13083ce2209aab9ea73831610bc61ab1" kindref="member">snd_pcm_resume()</ref> != -EAGAIN and then call <ref refid="group___p_c_m_1ga788d05de75f2d536f8443cb0306754d0" kindref="member">snd_pcm_prepare()</ref> when <ref refid="group___p_c_m_1ga13083ce2209aab9ea73831610bc61ab1" kindref="member">snd_pcm_resume()</ref> return an error code. If <ref refid="group___p_c_m_1ga13083ce2209aab9ea73831610bc61ab1" kindref="member">snd_pcm_resume()</ref> does not fail (a zero value is returned), driver supports resume and the <ref refid="group___p_c_m_1ga788d05de75f2d536f8443cb0306754d0" kindref="member">snd_pcm_prepare()</ref> call can be ommited.</para><para><simplesect kind="par"><title>-EBADFD</title><para></para></simplesect>
This error means that the device is in a bad state. It means that the handskahe between application and alsa-lib is corrupted.</para><para><simplesect kind="par"><title>-ENOTTY, -ENODEV</title><para></para></simplesect>
This error can happen when device is physically removed (for example some hotplug devices like USB or PCMCIA, CardBus or ExpressCard can be removed on the fly).</para></sect1>
<sect1 id="pcm_1pcm_params">
<title>Managing parameters</title>
<para>The ALSA PCM device uses two groups of PCM related parameters. The hardware parameters contains the stream description like format, rate, count of channels, ring buffer size etc. The software parameters contains the software (driver) related parameters. The communication behaviour can be controlled via these parameters, like automatic start, automatic stop, interrupting (chunk acknowledge) etc. The software parameters can be modified at any time (when valid hardware parameters are set). It includes the running state as well.</para><sect2 id="pcm_1pcm_hw_params">
<title>Hardware related parameters</title>
<para>The ALSA PCM devices use the parameter refining system for hardware parameters - <ref refid="group___p_c_m_1ga65c737127994f0a980edad744e36dc40" kindref="member">snd_pcm_hw_params_t</ref>. It means, that application choose the full-range of configurations at first and then application sets single parameters until all parameters are elementary (definite).</para><para><simplesect kind="par"><title>Access modes</title><para></para></simplesect>
ALSA knows about five access modes. The first three can be used for direct communication. The access mode <ref refid="group___p_c_m_1gga661221ba5e8f1d6eaf4ab8e2da57cc1aa90a5dea527c5ae9a53f1448beb2dee6f" kindref="member">SND_PCM_ACCESS_MMAP_INTERLEAVED</ref> determines the direct memory area and interleaved sample organization. Interleaved organization means, that samples from channels are mixed together. The access mode <ref refid="group___p_c_m_1gga661221ba5e8f1d6eaf4ab8e2da57cc1aa7de225785e05dd1d538203c5ece9036e" kindref="member">SND_PCM_ACCESS_MMAP_NONINTERLEAVED</ref> determines the direct memory area and non-interleaved sample organization. Each channel has a separate buffer in the case. The complex direct memory organization represents the <ref refid="group___p_c_m_1gga661221ba5e8f1d6eaf4ab8e2da57cc1aa26a4f161364cb539df4de5eeb9949121" kindref="member">SND_PCM_ACCESS_MMAP_COMPLEX</ref> access mode. The sample organization does not fit the interleaved or non-interleaved access modes in the case. The last two access modes describes the read / write access methods. The <ref refid="group___p_c_m_1gga661221ba5e8f1d6eaf4ab8e2da57cc1aa72a970ed6e676ab0fd9f3c3d36737e0a" kindref="member">SND_PCM_ACCESS_RW_INTERLEAVED</ref> access represents the read / write interleaved access and the <ref refid="group___p_c_m_1gga661221ba5e8f1d6eaf4ab8e2da57cc1aae7ab128d10c32667f396933190435071" kindref="member">SND_PCM_ACCESS_RW_NONINTERLEAVED</ref> represents the non-interleaved access.</para><para><simplesect kind="par"><title>Formats</title><para></para></simplesect>
The full list of formats is available in <ref refid="group___p_c_m_1gaa14b7f26877a812acbb39811364177f8" kindref="member">snd_pcm_format_t</ref> enumeration.</para></sect2>
<sect2 id="pcm_1pcm_sw_params">
<title>Software related parameters</title>
<para>These parameters - <ref refid="group___p_c_m_1ga7e082d9ea701709270b0674a0be23b09" kindref="member">snd_pcm_sw_params_t</ref> can be modified at any time including the running state.</para><para><simplesect kind="par"><title>Minimum available count of samples</title><para></para></simplesect>
This parameter controls the wakeup point. If the count of available samples is equal or greater than this value, then application will be activated.</para><para><simplesect kind="par"><title>Timestamp mode</title><para></para></simplesect>
The timestamp mode specifies, if timestamps are activated. Currently, only <ref refid="group___p_c_m_1gga695a9755880cf886c13d07938f92ea77af49a1c378583854b22ed6f6490f3b1ee" kindref="member">SND_PCM_TSTAMP_NONE</ref> and <ref refid="group___p_c_m_1gga695a9755880cf886c13d07938f92ea77ab09196ab367636c4d365b5b6bcd391d8" kindref="member">SND_PCM_TSTAMP_MMAP</ref> modes are known. The mmap mode means that timestamp is taken on every period time boundary. Corresponding position in the ring buffer assigned to timestamp can be obtained using <ref refid="group___p_c_m_1ga3946abd34178b3de60fd5329b71c189b" kindref="member">snd_pcm_htimestamp()</ref> function.</para><para><simplesect kind="par"><title>Transfer align</title><para></para></simplesect>
The read / write transfers can be aligned to this sample count. The modulo is ignored by device. Usually, this value is set to one (no align).</para><para><simplesect kind="par"><title>Start threshold</title><para></para></simplesect>
The start threshold parameter is used to determine the start point in stream. For playback, if samples in ring buffer is equal or greater than the start threshold parameters and the stream is not running, the stream will be started automatically from the device. For capture, if the application wants to read count of samples equal or greater then the stream will be started. If you want to use explicit start (<ref refid="group___p_c_m_1ga6bdb88b68a9d9e66015d770f600c6aea" kindref="member">snd_pcm_start</ref>), you can set this value greater than ring buffer size (in samples), but use the constant MAXINT is not a bad idea.</para><para><simplesect kind="par"><title>Stop threshold</title><para></para></simplesect>
Similarly, the stop threshold parameter is used to automatically stop the running stream, when the available samples crosses this boundary. It means, for playback, the empty samples in ring buffer and for capture, the filled (used) samples in ring buffer.</para><para><simplesect kind="par"><title>Silence threshold</title><para></para></simplesect>
The silence threshold specifies count of samples filled with silence ahead of the current application pointer for playback. It is usable for applications when an overrun is possible (like tasks depending on network I/O etc.). If application wants to manage the ahead samples itself, the <ref refid="group___p_c_m_1ga6c66040dbe01797379436fdf36268fec" kindref="member">snd_pcm_rewind()</ref> function allows to forget the last samples in the stream.</para></sect2>
</sect1>
<sect1 id="pcm_1pcm_status">
<title>Obtaining stream status</title>
<para>The stream status is stored in <ref refid="group___p_c_m_1ga902b87281c46910b469d5f7aaafc1890" kindref="member">snd_pcm_status_t</ref> structure. These parameters can be obtained: the current stream state - <ref refid="group___p_c_m___status_1gabaae998f0d374c50195b3206d1e43659" kindref="member">snd_pcm_status_get_state()</ref>, timestamp of trigger - <ref refid="group___p_c_m___status_1ga5eaeff98814e96c2ffd5f04c95b22c8d" kindref="member">snd_pcm_status_get_trigger_tstamp()</ref>, timestamp of last pointer update <ref refid="group___p_c_m___status_1gaea54e0a110afa01dd42071a1ca43902e" kindref="member">snd_pcm_status_get_tstamp()</ref>, delay in samples - <ref refid="group___p_c_m___status_1ga1fdce3985e64f66385a5805da1110f18" kindref="member">snd_pcm_status_get_delay()</ref>, available count in samples - <ref refid="group___p_c_m___status_1ga91c110525060b925ad4f0c21c205b757" kindref="member">snd_pcm_status_get_avail()</ref>, maximum available samples - <ref refid="group___p_c_m___status_1gac58d13e4d03c9420c57428ddffd94964" kindref="member">snd_pcm_status_get_avail_max()</ref>, ADC over-range count in samples - <ref refid="group___p_c_m___status_1ga3f4bfd0a0327529abaa621b248b6b1aa" kindref="member">snd_pcm_status_get_overrange()</ref>. The last two parameters - avail_max and overrange are reset to zero after the status call.</para><sect2 id="pcm_1pcm_status_fast">
<title>Obtaining stream state fast and update r/w pointer</title>
<para>The function <ref refid="group___p_c_m_1ga8bb836bd0c414b59789d51a5f5379c08" kindref="member">snd_pcm_avail_update()</ref> updates the current available count of samples for writing (playback) or filled samples for reading (capture). This call is mandatory for updating actual r/w pointer. Using standalone, it is a light method to obtain current stream position, because it does not require the user &lt;-&gt; kernel context switch, but the value is less accurate, because ring buffer pointers are updated in kernel drivers only when an interrupt occurs. If you want to get accurate stream state, use functions <ref refid="group___p_c_m_1ga577b4d51e08d94930a05bbe73291ed2a" kindref="member">snd_pcm_avail()</ref>, <ref refid="group___p_c_m_1ga012e8b999070e72ab23514f25e7d6482" kindref="member">snd_pcm_delay()</ref> or <ref refid="group___p_c_m_1ga170bc44da2607b5583cff5ab5a985d98" kindref="member">snd_pcm_avail_delay()</ref>. </para><para>The function <ref refid="group___p_c_m_1ga577b4d51e08d94930a05bbe73291ed2a" kindref="member">snd_pcm_avail()</ref> reads the current hardware pointer in the ring buffer from hardware and calls <ref refid="group___p_c_m_1ga8bb836bd0c414b59789d51a5f5379c08" kindref="member">snd_pcm_avail_update()</ref> then. </para><para>The function <ref refid="group___p_c_m_1ga012e8b999070e72ab23514f25e7d6482" kindref="member">snd_pcm_delay()</ref> returns the delay in samples. For playback, it means count of samples in the ring buffer before the next sample will be sent to DAC. For capture, it means count of samples in the ring buffer before the next sample will be captured from ADC. It works only when the stream is in the running or draining (playback only) state. Note that this function does not update the current r/w pointer for applications, so the function <ref refid="group___p_c_m_1ga8bb836bd0c414b59789d51a5f5379c08" kindref="member">snd_pcm_avail_update()</ref> must be called afterwards before any read/write begin+commit operations. </para><para>The function <ref refid="group___p_c_m_1ga170bc44da2607b5583cff5ab5a985d98" kindref="member">snd_pcm_avail_delay()</ref> combines <ref refid="group___p_c_m_1ga577b4d51e08d94930a05bbe73291ed2a" kindref="member">snd_pcm_avail()</ref> and <ref refid="group___p_c_m_1ga012e8b999070e72ab23514f25e7d6482" kindref="member">snd_pcm_delay()</ref> and returns both values in sync. </para></sect2>
</sect1>
<sect1 id="pcm_1pcm_action">
<title>Managing the stream state</title>
<para>The following functions directly and indirectly affect the stream state:</para><para><simplesect kind="par"><title>snd_pcm_hw_params</title><para>The <ref refid="group___p_c_m_1ga1ca0dc120a484965e26cabf966502330" kindref="member">snd_pcm_hw_params()</ref> function brings the stream state to <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a58d9a0501aa1b2bd2607e1084c335672" kindref="member">SND_PCM_STATE_SETUP</ref> if successfully finishes, otherwise the state <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a56cf8033b50561b57437232e243f3007" kindref="member">SND_PCM_STATE_OPEN</ref> is entered. When it is brought to SETUP state, this function automatically calls <ref refid="group___p_c_m_1ga788d05de75f2d536f8443cb0306754d0" kindref="member">snd_pcm_prepare()</ref> function to bring to the PREPARED state as below.</para></simplesect>
<simplesect kind="par"><title>snd_pcm_prepare</title><para>The <ref refid="group___p_c_m_1ga788d05de75f2d536f8443cb0306754d0" kindref="member">snd_pcm_prepare()</ref> function enters from <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a58d9a0501aa1b2bd2607e1084c335672" kindref="member">SND_PCM_STATE_SETUP</ref> to the <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a3eb4a3b75c7d2adb22f1829f3f738b27" kindref="member">SND_PCM_STATE_PREPARED</ref> after a successful finish.</para></simplesect>
<simplesect kind="par"><title>snd_pcm_start</title><para>The <ref refid="group___p_c_m_1ga6bdb88b68a9d9e66015d770f600c6aea" kindref="member">snd_pcm_start()</ref> function enters the <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147" kindref="member">SND_PCM_STATE_RUNNING</ref> after a successful finish.</para></simplesect>
<simplesect kind="par"><title>snd_pcm_drop</title><para>The <ref refid="group___p_c_m_1ga7000ca6010a1a2739daddff8e2fbb440" kindref="member">snd_pcm_drop()</ref> function enters the <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a58d9a0501aa1b2bd2607e1084c335672" kindref="member">SND_PCM_STATE_SETUP</ref> state.</para></simplesect>
<simplesect kind="par"><title>snd_pcm_drain</title><para>The <ref refid="group___p_c_m_1ga49afc5b8527f30c33fafa476533c9f86" kindref="member">snd_pcm_drain()</ref> function enters the <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a86f88c2a4c8eedb5c91f3b6cb4879cfe" kindref="member">SND_PCM_STATE_DRAINING</ref>, if the capture device has some samples in the ring buffer otherwise <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a58d9a0501aa1b2bd2607e1084c335672" kindref="member">SND_PCM_STATE_SETUP</ref> state is entered.</para></simplesect>
<simplesect kind="par"><title>snd_pcm_pause</title><para>The <ref refid="group___p_c_m_1gad711b582c7066bd4fffa1d08a04316b5" kindref="member">snd_pcm_pause()</ref> function enters the <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a9fa0c5b43e5c924f87b50e22878a8952" kindref="member">SND_PCM_STATE_PAUSED</ref> or <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147" kindref="member">SND_PCM_STATE_RUNNING</ref>.</para></simplesect>
<simplesect kind="par"><title>snd_pcm_writei, snd_pcm_writen</title><para>The <ref refid="group___p_c_m_1gabc748a500743713eafa960c7d104ca6f" kindref="member">snd_pcm_writei()</ref> and <ref refid="group___p_c_m_1gae599772ce3d0aa6a70de143abcf145e7" kindref="member">snd_pcm_writen()</ref> functions can conditionally start the stream - <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147" kindref="member">SND_PCM_STATE_RUNNING</ref>. They depend on the start threshold software parameter.</para></simplesect>
<simplesect kind="par"><title>snd_pcm_readi, snd_pcm_readn</title><para>The <ref refid="group___p_c_m_1ga4c2c7bd26cf221268d59dc3bbeb9c048" kindref="member">snd_pcm_readi()</ref> and <ref refid="group___p_c_m_1gafea175455f1a405f633a43484ded3d8a" kindref="member">snd_pcm_readn()</ref> functions can conditionally start the stream - <ref refid="group___p_c_m_1gga61ac499cb3701ce536d4d83725908860a86f6fbc796881f19fde0e1957f878147" kindref="member">SND_PCM_STATE_RUNNING</ref>. They depend on the start threshold software parameter.</para></simplesect>
</para></sect1>
<sect1 id="pcm_1pcm_sync">
<title>Streams synchronization</title>
<para>There are two functions allowing link multiple streams together. In the case, the linking means that all operations are synchronized. Because the drivers cannot guarantee the synchronization (sample resolution) on hardware lacking this feature, the <ref refid="group___p_c_m___info_1ga4a46693c8a81912de84f814c3eecd06e" kindref="member">snd_pcm_info_get_sync()</ref> function returns synchronization ID - <ref refid="unionsnd__pcm__sync__id__t" kindref="compound">snd_pcm_sync_id_t</ref>, which is equal for hardware synchronized streams. When the <ref refid="group___p_c_m_1gac6c33091b049985baa6466e8fe93917e" kindref="member">snd_pcm_link()</ref> function is called, all operations managing the stream state for these two streams are joined. The opposite function is <ref refid="group___p_c_m_1ga0d3af5e30593dae857b4308aab5035cd" kindref="member">snd_pcm_unlink()</ref>.</para></sect1>
<sect1 id="pcm_1pcm_thread_safety">
<title>Thread-safety</title>
<para>When the library is configured with the proper option, some PCM functions (e.g. <ref refid="group___p_c_m_1ga8bb836bd0c414b59789d51a5f5379c08" kindref="member">snd_pcm_avail_update()</ref>) are thread-safe and can be called concurrently from multiple threads. Meanwhile, some functions (e.g. <ref refid="group___p_c_m_1ga1ca0dc120a484965e26cabf966502330" kindref="member">snd_pcm_hw_params()</ref>) aren&apos;t thread-safe, and application needs to call them carefully when they are called from multiple threads. In general, all the functions that are often called during streaming are covered as thread-safe.</para><para>This thread-safe behavior can be disabled also by passing 0 to the environment variable LIBASOUND_THREAD_SAFE, e.g. <programlisting><codeline><highlight class="normal">LIBASOUND_THREAD_SAFE=0<sp/>aplay<sp/>foo.wav</highlight></codeline>
</programlisting> for making the debugging easier.</para></sect1>
<sect1 id="pcm_1pcm_dev_names">
<title>PCM naming conventions</title>
<para>The ALSA library uses a generic string representation for names of devices. The devices might be virtual, physical or a mix of both. The generic string is passed to <ref refid="group___p_c_m_1ga8340c7dc0ac37f37afe5e7c21d6c528b" kindref="member">snd_pcm_open()</ref> or <ref refid="group___p_c_m_1ga88164d313d8ff9dc33c94815869cb677" kindref="member">snd_pcm_open_lconf()</ref>. It contains two parts: device name and arguments. Devices and arguments are described in configuration files. The usual place for default definitions is at /usr/share/alsa/alsa.conf. For detailed descriptions about integrated PCM plugins look to <ref refid="pcm_plugins" kindref="compound">PCM (digital audio) plugins</ref>.</para><sect2 id="pcm_1pcm_dev_names_default">
<title>Default device</title>
<para>The default device is equal to plug plugin with hw plugin as slave. The defaults are used:</para><para><programlisting><codeline><highlight class="normal">defaults.pcm.card<sp/>0</highlight></codeline>
<codeline><highlight class="normal">defaults.pcm.device<sp/>0</highlight></codeline>
<codeline><highlight class="normal">defaults.pcm.subdevice<sp/>-1</highlight></codeline>
</programlisting></para><para>These defaults can be freely overwritten in local configuration files.</para><para>Example:</para><para><programlisting><codeline><highlight class="normal">default</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="pcm_1pcm_dev_names_hw">
<title>HW device</title>
<para>The hw device description uses the hw plugin. The three arguments (in order: CARD,DEV,SUBDEV) specify card number or identifier, device number and subdevice number (-1 means any).</para><para>Example:</para><para><programlisting><codeline><highlight class="normal">hw</highlight></codeline>
<codeline><highlight class="normal">hw:0</highlight></codeline>
<codeline><highlight class="normal">hw:0,0</highlight></codeline>
<codeline><highlight class="normal">hw:supersonic,1</highlight></codeline>
<codeline><highlight class="normal">hw:soundwave,1,2</highlight></codeline>
<codeline><highlight class="normal">hw:DEV=1,CARD=soundwave,SUBDEV=2</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="pcm_1pcm_dev_names_plughw">
<title>Plug-&gt;HW device</title>
<para>The plughw device description uses the plug plugin and hw plugin as slave. The arguments are same as for hw device.</para><para>Example:</para><para><programlisting><codeline><highlight class="normal">plughw</highlight></codeline>
<codeline><highlight class="normal">plughw:0</highlight></codeline>
<codeline><highlight class="normal">plughw:0,0</highlight></codeline>
<codeline><highlight class="normal">plughw:supersonic,1</highlight></codeline>
<codeline><highlight class="normal">plughw:soundwave,1,2</highlight></codeline>
<codeline><highlight class="normal">plughw:DEV=1,CARD=soundwave,SUBDEV=2</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="pcm_1pcm_dev_names_plug">
<title>Plug device</title>
<para>The plug device uses the plug plugin. The one SLAVE argument specifies the slave plugin.</para><para>Example:</para><para><programlisting><codeline><highlight class="normal">plug:mypcmdef</highlight></codeline>
<codeline><highlight class="normal">plug:hw</highlight></codeline>
<codeline><highlight class="normal">plug:&apos;hw:0,0&apos;</highlight></codeline>
<codeline><highlight class="normal">plug:SLAVE=hw</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="pcm_1pcm_dev_names_shm">
<title>Shared memory device</title>
<para>The shm device uses the shm plugin. The two arguments (in order: SOCKET,PCM) specify UNIX socket name (for example /tmp/alsa.socket) for server communication and server&apos;s PCM name.</para><para>Example:</para><para><programlisting><codeline><highlight class="normal">shm:&apos;/tmp/alsa.sock&apos;,default</highlight></codeline>
<codeline><highlight class="normal">shm:SOCKET=&apos;/tmp/alsa.sock&apos;,PCM=default</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="pcm_1pcm_dev_names_tee">
<title>Tee device</title>
<para>The tee device stores contents of a stream to given file plus transfers it to given slave plugin. The three arguments (in order: SLAVE,FILE,FORMAT) specify slave plugin, filename and file format.</para><para>Example:</para><para><programlisting><codeline><highlight class="normal">tee:hw,&apos;/tmp/out.raw&apos;,raw</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="pcm_1pcm_dev_names_file">
<title>File device</title>
<para>The file device is file plugin with null plugin as slave. The arguments (in order: FILE,FORMAT) specify filename and file format.</para><para>Example:</para><para><programlisting><codeline><highlight class="normal">file:&apos;/tmp/out.raw&apos;,raw</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="pcm_1pcm_dev_names_null">
<title>Null device</title>
<para>The null device is null plugin. This device has not any arguments.</para></sect2>
</sect1>
<sect1 id="pcm_1pcm_examples">
<title>Examples</title>
<para>The full featured examples with cross-links can be found in Examples section (see top of page):</para><para><anchor id="pcm_1example_test_pcm"/><simplesect kind="par"><title>Sine-wave generator</title><para></para></simplesect>
<simplesect kind="par"><title></title><para>alsa-lib/test/pcm.c example shows various transfer methods for the playback direction.</para></simplesect>
<simplesect kind="par"><title>Minimalistic PCM playback code</title><para></para></simplesect>
<simplesect kind="par"><title></title><para>alsa-lib/test/pcm_min.c example shows the minimal code to produce a sound.</para></simplesect>
<simplesect kind="par"><title>Latency measuring tool</title><para></para></simplesect>
<simplesect kind="par"><title></title><para>alsa-lib/test/latency.c example shows the measuring of minimal latency between capture and playback devices. </para></simplesect>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
