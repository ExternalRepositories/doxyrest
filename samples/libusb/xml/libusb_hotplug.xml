<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="libusb_hotplug" kind="page">
    <compoundname>libusb_hotplug</compoundname>
    <title>Device hotplug event notification</title>
    <detaileddescription>
<sect1 id="libusb_hotplug_1hotplug_intro">
<title>Introduction</title>
<para>Version 1.0.16, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000102, has added support for hotplug events on <bold>some</bold> platforms (you should test if your platform supports hotplug notification by calling <ref refid="group__libusb__misc_1ga9b8e324d28c624cd0b8e7ba21607b8db" kindref="member">libusb_has_capability()</ref> with parameter <ref refid="group__libusb__misc_1ggaab1b3fa0728c06fafbee897795889bd5a8b1bbccc648a6677cb9030a6ba827438" kindref="member">LIBUSB_CAP_HAS_HOTPLUG</ref>).</para><para>This interface allows you to request notification for the arrival and departure of matching USB devices.</para><para>To receive hotplug notification you register a callback by calling <ref refid="group__libusb__hotplug_1ga00e0c69ddf1fb1b6774dc918192e8dc7" kindref="member">libusb_hotplug_register_callback()</ref>. This function will optionally return a callback handle that can be passed to <ref refid="group__libusb__hotplug_1ga8110f57eab2064375934f1449b2602bc" kindref="member">libusb_hotplug_deregister_callback()</ref>.</para><para>A callback function must return an int (0 or 1) indicating whether the callback is expecting additional events. Returning 0 will rearm the callback and 1 will cause the callback to be deregistered. Note that when callbacks are called from <ref refid="group__libusb__hotplug_1ga00e0c69ddf1fb1b6774dc918192e8dc7" kindref="member">libusb_hotplug_register_callback()</ref> because of the <ref refid="group__libusb__hotplug_1gga95ce2ec85dec177854c423cea2853c52a01a1c0c9f4e6852cb6df713f2e8a7f6b" kindref="member">LIBUSB_HOTPLUG_ENUMERATE</ref> flag, the callback return value is ignored, iow you cannot cause a callback to be deregistered by returning 1 when it is called from <ref refid="group__libusb__hotplug_1ga00e0c69ddf1fb1b6774dc918192e8dc7" kindref="member">libusb_hotplug_register_callback()</ref>.</para><para>Callbacks for a particular context are automatically deregistered by <ref refid="group__libusb__lib_1ga86532f222d4f1332a5f8f5eef9a92da9" kindref="member">libusb_exit()</ref>.</para><para>As of 1.0.16 there are two supported hotplug events:<itemizedlist>
<listitem><para>LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED: A device has arrived and is ready to use</para></listitem><listitem><para>LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT: A device has left and is no longer available</para></listitem></itemizedlist>
</para><para>A hotplug event can listen for either or both of these events.</para><para>Note: If you receive notification that a device has left and you have any a libusb_device_handles for the device it is up to you to call <ref refid="group__libusb__dev_1ga779bc4f1316bdb0ac383bddbd538620e" kindref="member">libusb_close()</ref> on each device handle to free up any remaining resources associated with the device. Once a device has left any libusb_device_handle associated with the device are invalid and will remain so even if the device comes back.</para><para>When handling a LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED event it is considered safe to call any libusb function that takes a libusb_device. It also safe to open a device and submit asynchronous transfers. However, most other functions that take a libusb_device_handle are <bold>not</bold> safe to call. Examples of such functions are any of the <ref refid="group__libusb__syncio" kindref="compound">synchronous API</ref> functions or the blocking functions that retrieve various <ref refid="group__libusb__desc" kindref="compound">USB descriptors</ref>. These functions must be used outside of the context of the hotplug callback.</para><para>When handling a LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT event the only safe function is <ref refid="group__libusb__desc_1ga5e9ab08d490a7704cf3a9b0439f16f00" kindref="member">libusb_get_device_descriptor()</ref>.</para><para>The following code provides an example of the usage of the hotplug interface: <programlisting><codeline><highlight class="normal">#include<sp/>&lt;stdio.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;stdlib.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;time.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;libusb.h&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static<sp/>int<sp/>count<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>hotplug_callback(struct<sp/>libusb_context<sp/>*ctx,<sp/>struct<sp/>libusb_device<sp/>*dev,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>libusb_hotplug_event<sp/>event,<sp/>void<sp/>*user_data)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>libusb_device_handle<sp/>*dev_handle<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>struct<sp/>libusb_device_descriptor<sp/>desc;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>rc;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>(void)libusb_get_device_descriptor(dev,<sp/>&amp;desc);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED<sp/>==<sp/>event)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rc<sp/>=<sp/>libusb_open(dev,<sp/>&amp;dev_handle);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(LIBUSB_SUCCESS<sp/>!=<sp/>rc)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>printf(&quot;Could<sp/>not<sp/>open<sp/>USB<sp/>device\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>if<sp/>(LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT<sp/>==<sp/>event)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(dev_handle)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>libusb_close(dev_handle);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>dev_handle<sp/>=<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}<sp/>else<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Unhandled<sp/>event<sp/>%d\n&quot;,<sp/>event);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>count++;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main<sp/>(void)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>libusb_hotplug_callback_handle<sp/>callback_handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>int<sp/>rc;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>libusb_init(NULL);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>rc<sp/>=<sp/>libusb_hotplug_register_callback(NULL,<sp/>LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED<sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT,<sp/>0,<sp/>0x045a,<sp/>0x5005,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>LIBUSB_HOTPLUG_MATCH_ANY,<sp/>hotplug_callback,<sp/>NULL,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;callback_handle);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(LIBUSB_SUCCESS<sp/>!=<sp/>rc)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>printf(&quot;Error<sp/>creating<sp/>a<sp/>hotplug<sp/>callback\n&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>libusb_exit(NULL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>while<sp/>(count<sp/>&lt;<sp/>2)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>libusb_handle_events_completed(NULL,<sp/>NULL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>nanosleep(&amp;(struct<sp/>timespec){0,<sp/>10000000UL},<sp/>NULL);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>libusb_hotplug_deregister_callback(NULL,<sp/>callback_handle);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>libusb_exit(NULL);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>return<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
