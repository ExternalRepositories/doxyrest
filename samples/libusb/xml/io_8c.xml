<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="io_8c" kind="file" language="C++">
    <compoundname>io.c</compoundname>
    <includes local="no">config.h</includes>
    <includes local="no">assert.h</includes>
    <includes local="no">errno.h</includes>
    <includes local="no">stdint.h</includes>
    <includes local="no">stdlib.h</includes>
    <includes local="no">string.h</includes>
    <includes local="no">time.h</includes>
    <includes local="yes">libusbi.h</includes>
    <includes local="yes">hotplug.h</includes>
    <incdepgraph>
      <node id="36">
        <label>assert.h</label>
      </node>
      <node id="38">
        <label>stdint.h</label>
      </node>
      <node id="39">
        <label>stdlib.h</label>
      </node>
      <node id="37">
        <label>errno.h</label>
      </node>
      <node id="43">
        <label>hotplug.h</label>
      </node>
      <node id="40">
        <label>string.h</label>
      </node>
      <node id="34">
        <label>io.c</label>
        <link refid="io_8c"/>
        <childnode refid="35" relation="include">
        </childnode>
        <childnode refid="36" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
        <childnode refid="40" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="42" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
      </node>
      <node id="41">
        <label>time.h</label>
      </node>
      <node id="35">
        <label>config.h</label>
      </node>
      <node id="42">
        <label>libusbi.h</label>
      </node>
    </incdepgraph>
      <sectiondef kind="func">
      <memberdef kind="function" id="io_8c_1a32c4d3f939ca0669f390a8dc2e0d2767" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int usbi_io_init</definition>
        <argsstring>(struct libusb_context *ctx)</argsstring>
        <name>usbi_io_init</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1123" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1123" bodyend="1181"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a10a579920582ff5cfcf9b8784fe51169" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void usbi_io_exit</definition>
        <argsstring>(struct libusb_context *ctx)</argsstring>
        <name>usbi_io_exit</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1183" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1183" bodyend="1202"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a46e2979d61ee1ab5af3ff90c5d2f54a0" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int calculate_timeout</definition>
        <argsstring>(struct usbi_transfer *transfer)</argsstring>
        <name>calculate_timeout</name>
        <param>
          <type>struct usbi_transfer *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1204" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1204" bodyend="1231"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga13cc69ea40c702181c430c950121c000" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
        <definition>struct libusb_transfer* libusb_alloc_transfer</definition>
        <argsstring>(int iso_packets)</argsstring>
        <name>libusb_alloc_transfer</name>
        <param>
          <type>int</type>
          <declname>iso_packets</declname>
        </param>
        <briefdescription>
<para>Allocate a libusb transfer with a specified number of isochronous packet descriptors. </para>        </briefdescription>
        <detaileddescription>
<para>The returned transfer is pre-initialized for you. When the new transfer is no longer needed, it should be freed with <ref refid="group__libusb__asyncio_1ga6ab8b2cff4de9091298a06b2f4b86cd6" kindref="member">libusb_free_transfer()</ref>.</para><para>Transfers intended for non-isochronous endpoints (e.g. control, bulk, interrupt) should specify an iso_packets count of zero.</para><para>For transfers intended for isochronous endpoints, specify an appropriate number of packet descriptors to be allocated as part of the transfer. The returned transfer is not specially initialized for isochronous I/O; you are still required to set the <ref refid="structlibusb__transfer_1a87d725a5521c26832fdc13611220014d" kindref="member">num_iso_packets</ref> and <ref refid="structlibusb__transfer_1a7c9fa575986fe9f23bbecb26b766dff1" kindref="member">type</ref> fields accordingly.</para><para>It is safe to allocate a transfer with some isochronous packets and then use it on a non-isochronous endpoint. If you do this, ensure that at time of submission, num_iso_packets is 0 and that type is set appropriately.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iso_packets</parametername>
</parameternamelist>
<parameterdescription>
<para>number of isochronous packet descriptors to allocate </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a newly allocated transfer, or NULL on error </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1257" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1257" bodyend="1275"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga6ab8b2cff4de9091298a06b2f4b86cd6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_free_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
<para>Free a transfer structure. </para>        </briefdescription>
        <detaileddescription>
<para>This should be called for all transfers allocated with <ref refid="group__libusb__asyncio_1ga13cc69ea40c702181c430c950121c000" kindref="member">libusb_alloc_transfer()</ref>.</para><para>If the <ref refid="group__libusb__asyncio_1gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86" kindref="member">LIBUSB_TRANSFER_FREE_BUFFER</ref> flag is set and the transfer buffer is non-NULL, this function will also free the transfer buffer using the standard system memory allocator (e.g. free()).</para><para>It is legal to call this function with a NULL transfer. In this case, the function will simply return safely.</para><para>It is not legal to free an active transfer (one which has been submitted and has not yet completed).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to free </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1294" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1294" bodyend="1307"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a4eb4cbca9b846ac0e52e503e3883f9b2" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int arm_timerfd_for_next_timeout</definition>
        <argsstring>(struct libusb_context *ctx)</argsstring>
        <name>arm_timerfd_for_next_timeout</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1357" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1357" bodyend="1361"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a83f3ad8ebdcae35521ed92c8eb8a7295" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int add_to_flying_list</definition>
        <argsstring>(struct usbi_transfer *transfer)</argsstring>
        <name>add_to_flying_list</name>
        <param>
          <type>struct usbi_transfer *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1367" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1367" bodyend="1432"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1ab817222afa8b51eab6fd1dde4487f2c1" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int remove_from_flying_list</definition>
        <argsstring>(struct usbi_transfer *transfer)</argsstring>
        <name>remove_from_flying_list</name>
        <param>
          <type>struct usbi_transfer *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1438" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1438" bodyend="1453"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gabb0932601f2c7dad2fee4b27962848ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_submit_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_submit_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
<para>Submit a transfer. </para>        </briefdescription>
        <detaileddescription>
<para>This function will fire off the USB transfer and then return immediately.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to submit </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if the transfer has already been submitted. </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_SUPPORTED if the transfer flags are not supported by the operating system. </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_INVALID_PARAM if the transfer size is larger than the operating system and/or hardware can support </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1469" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1469" bodyend="1544"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga685eb7731f9a0593f75beb99727bbe54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_cancel_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_cancel_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
<para>Asynchronously cancel a previously submitted transfer. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns immediately, but this does not indicate cancellation is complete. Your callback function will be invoked at some later time with a transfer status of <ref refid="group__libusb__asyncio_1gga9fcb2aa23d342060ebda1d0cf7478856a8af1f19e46cccafdcf3feadce47e880b" kindref="member">LIBUSB_TRANSFER_CANCELLED.</ref></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to cancel </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the transfer is not in progress, already complete, or already cancelled. </para></simplesect>
<simplesect kind="return"><para>a LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1560" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1560" bodyend="1591"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gaeae2db23b9de811af317483afdeb230f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_transfer_set_stream_id</definition>
        <argsstring>(struct libusb_transfer *transfer, uint32_t stream_id)</argsstring>
        <name>libusb_transfer_set_stream_id</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>stream_id</declname>
        </param>
        <briefdescription>
<para>Set a transfers bulk stream id. </para>        </briefdescription>
        <detaileddescription>
<para>Note users are advised to use <ref refid="group__libusb__asyncio_1gac2e84d8fb9218d3c67e6a4fd4ade5b10" kindref="member">libusb_fill_bulk_stream_transfer()</ref> instead of calling this function directly.</para><para>Since version 1.0.19, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000103</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to set the stream id for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the stream id to set </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="group__libusb__asyncio_1gad7e786c1bedd4a668887564465101981" kindref="member">libusb_alloc_streams()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1604" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1604" bodyend="1611"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga631653487273f3306925131cdc0a3ffc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t libusb_transfer_get_stream_id</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_transfer_get_stream_id</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
<para>Get a transfers bulk stream id. </para>        </briefdescription>
        <detaileddescription>
<para>Since version 1.0.19, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000103</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to get the stream id for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the stream id for the transfer </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1621" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1621" bodyend="1628"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1acb4e928cb8eebaac42bf4e3163c64d96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int usbi_handle_transfer_completion</definition>
        <argsstring>(struct usbi_transfer *itransfer, enum libusb_transfer_status status)</argsstring>
        <name>usbi_handle_transfer_completion</name>
        <param>
          <type>struct usbi_transfer *</type>
          <declname>itransfer</declname>
        </param>
        <param>
          <type>enum <ref refid="group__libusb__asyncio_1ga9fcb2aa23d342060ebda1d0cf7478856" kindref="member">libusb_transfer_status</ref></type>
          <declname>status</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1638" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1638" bodyend="1678"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a7abb1c3fc10076fe3e559379ad6d1da0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int usbi_handle_transfer_cancellation</definition>
        <argsstring>(struct usbi_transfer *transfer)</argsstring>
        <name>usbi_handle_transfer_cancellation</name>
        <param>
          <type>struct usbi_transfer *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1686" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1686" bodyend="1703"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a2927471208704d6598c31a35f6592368" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void usbi_signal_transfer_completion</definition>
        <argsstring>(struct usbi_transfer *transfer)</argsstring>
        <name>usbi_signal_transfer_completion</name>
        <param>
          <type>struct usbi_transfer *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1708" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1708" bodyend="1719"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga6e5a116d5c9498ca4a0e29587fec1a05" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_try_lock_events</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_try_lock_events</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Attempt to acquire the event handling lock. </para>        </briefdescription>
        <detaileddescription>
<para>This lock is used to ensure that only one thread is monitoring libusb event sources at any one time.</para><para>You only need to use this lock if you are developing an application which calls poll() or select() on libusb&apos;s file descriptors directly. If you stick to libusb&apos;s event handling loop functions (e.g. <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref>) then you do not need to be concerned with this locking.</para><para>While holding this lock, you are trusted to actually be handling events. If you are no longer handling events, you must call <ref refid="group__libusb__poll_1gacefbeabdd3409490dc4678f00779c165" kindref="member">libusb_unlock_events()</ref> as soon as possible.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if the lock was obtained successfully </para></simplesect>
<simplesect kind="return"><para>1 if the lock was not obtained (i.e. another thread holds the lock) <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1740" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1740" bodyend="1762"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1gaa72153938dc4f34decfacbc6cc6237ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_lock_events</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_lock_events</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Acquire the event handling lock, blocking until successful acquisition if it is contended. </para>        </briefdescription>
        <detaileddescription>
<para>This lock is used to ensure that only one thread is monitoring libusb event sources at any one time.</para><para>You only need to use this lock if you are developing an application which calls poll() or select() on libusb&apos;s file descriptors directly. If you stick to libusb&apos;s event handling loop functions (e.g. <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref>) then you do not need to be concerned with this locking.</para><para>While holding this lock, you are trusted to actually be handling events. If you are no longer handling events, you must call <ref refid="group__libusb__poll_1gacefbeabdd3409490dc4678f00779c165" kindref="member">libusb_unlock_events()</ref> as soon as possible.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1782" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1782" bodyend="1787"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1gacefbeabdd3409490dc4678f00779c165" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_unlock_events</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_unlock_events</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Release the lock previously acquired with <ref refid="group__libusb__poll_1ga6e5a116d5c9498ca4a0e29587fec1a05" kindref="member">libusb_try_lock_events()</ref> or <ref refid="group__libusb__poll_1gaa72153938dc4f34decfacbc6cc6237ef" kindref="member">libusb_lock_events()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Releasing this lock will wake up any threads blocked on <ref refid="group__libusb__poll_1gae22755d523560be2867be7d09034ca50" kindref="member">libusb_wait_for_event()</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1797" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1797" bodyend="1809"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga63592b28c265185d9469d1e6920d8373" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_event_handling_ok</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_event_handling_ok</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Determine if it is still OK for this thread to be doing event handling. </para>        </briefdescription>
        <detaileddescription>
<para>Sometimes, libusb needs to temporarily pause all event handlers, and this is the function you should use before polling file descriptors to see if this is the case.</para><para>If this function instructs your thread to give up the events lock, you should just continue the usual logic that is documented in <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref>. On the next iteration, your thread will fail to obtain the events lock, and will hence become an event waiter.</para><para>This function should be called while the events lock is held: you don&apos;t need to worry about the results of this function if your thread is not the current event handler.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if event handling can start or continue </para></simplesect>
<simplesect kind="return"><para>0 if this thread must give up the events lock <ref refid="libusb_mtasync_1fullstory" kindref="member">Multi-threaded I/O: the full story</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1832" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1832" bodyend="1848"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga3a0a6e8be310c20f1ca68722149f9dbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_event_handler_active</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_event_handler_active</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Determine if an active thread is handling events (i.e. </para>        </briefdescription>
        <detaileddescription>
<para>if anyone is holding the event handling lock).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if a thread is handling events </para></simplesect>
<simplesect kind="return"><para>0 if there are no threads currently handling events <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1860" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1860" bodyend="1876"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga188b6c50944b49f122ccfd45b93fa9f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_interrupt_event_handler</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_interrupt_event_handler</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Interrupt any active thread that is handling events. </para>        </briefdescription>
        <detaileddescription>
<para>This is mainly useful for interrupting a dedicated event handling thread when an application wishes to call <ref refid="group__libusb__lib_1ga86532f222d4f1332a5f8f5eef9a92da9" kindref="member">libusb_exit()</ref>.</para><para>Since version 1.0.21, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000105</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1888" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1888" bodyend="1899"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga150865a3f35c38173d688efa7ee52929" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_lock_event_waiters</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_lock_event_waiters</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Acquire the event waiters lock. </para>        </briefdescription>
        <detaileddescription>
<para>This lock is designed to be obtained under the situation where you want to be aware when events are completed, but some other thread is event handling so calling <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref> is not allowed.</para><para>You then obtain this lock, re-check that another thread is still handling events, then call <ref refid="group__libusb__poll_1gae22755d523560be2867be7d09034ca50" kindref="member">libusb_wait_for_event()</ref>.</para><para>You only need to use this lock if you are developing an application which calls poll() or select() on libusb&apos;s file descriptors directly, <bold>and</bold> may potentially be handling events from 2 threads simultaenously. If you stick to libusb&apos;s event handling loop functions (e.g. <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref>) then you do not need to be concerned with this locking.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1920" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1920" bodyend="1924"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga41d7716458c11ee02d0deb19a31233ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_unlock_event_waiters</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_unlock_event_waiters</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Release the event waiters lock. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1931" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1931" bodyend="1935"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1gae22755d523560be2867be7d09034ca50" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_wait_for_event</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv)</argsstring>
        <name>libusb_wait_for_event</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <briefdescription>
<para>Wait for another thread to signal completion of an event. </para>        </briefdescription>
        <detaileddescription>
<para>Must be called with the event waiters lock held, see <ref refid="group__libusb__poll_1ga150865a3f35c38173d688efa7ee52929" kindref="member">libusb_lock_event_waiters()</ref>.</para><para>This function will block until any of the following conditions are met:<orderedlist>
<listitem><para>The timeout expires</para></listitem><listitem><para>A transfer completes</para></listitem><listitem><para>A thread releases the event handling lock through <ref refid="group__libusb__poll_1gacefbeabdd3409490dc4678f00779c165" kindref="member">libusb_unlock_events()</ref></para></listitem></orderedlist>
</para><para>Condition 1 is obvious. Condition 2 unblocks your thread <emphasis>after</emphasis> the callback for the transfer has completed. Condition 3 is important because it means that the thread that was previously handling events is no longer doing so, so if any events are to complete, another thread needs to step up and start event handling.</para><para>This function releases the event waiters lock before putting your thread to sleep, and reacquires the lock as it is being woken up.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tv</parametername>
</parameternamelist>
<parameterdescription>
<para>maximum timeout for this blocking function. A NULL value indicates unlimited timeout. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 after a transfer completes or another thread stops event handling </para></simplesect>
<simplesect kind="return"><para>1 if the timeout expired <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1962" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1962" bodyend="1979"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1afb53a04c492ddd60eeb5fcafbc192dbf" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void handle_timeout</definition>
        <argsstring>(struct usbi_transfer *itransfer)</argsstring>
        <name>handle_timeout</name>
        <param>
          <type>struct usbi_transfer *</type>
          <declname>itransfer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1981" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1981" bodyend="1994"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1afb1589a463e1b79f27bdd4a05b040e41" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int handle_timeouts_locked</definition>
        <argsstring>(struct libusb_context *ctx)</argsstring>
        <name>handle_timeouts_locked</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="1996" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1996" bodyend="2036"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1accfa2fa717a7dc838d064b4dbf9f0074" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int handle_timeouts</definition>
        <argsstring>(struct libusb_context *ctx)</argsstring>
        <name>handle_timeouts</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2038" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2038" bodyend="2046"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a0f788ec42692ff6cd8f49e797d2b55f1" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int handle_events</definition>
        <argsstring>(struct libusb_context *ctx, struct timeval *tv)</argsstring>
        <name>handle_events</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2071" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2071" bodyend="2272"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a43681cdc0ef5f431284afbbcc16cecae" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int get_next_timeout</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv, struct timeval *out)</argsstring>
        <name>get_next_timeout</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>out</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2280" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2280" bodyend="2299"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_handle_events_timeout_completed</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv, int *completed)</argsstring>
        <name>libusb_handle_events_timeout_completed</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>completed</declname>
        </param>
        <briefdescription>
<para>Handle any pending events. </para>        </briefdescription>
        <detaileddescription>
<para>libusb determines &quot;pending events&quot; by checking if any timeouts have expired and by checking the set of file descriptors for activity.</para><para>If a zero timeval is passed, this function will handle any already-pending events and then immediately return in non-blocking style.</para><para>If a non-zero timeval is passed and no events are currently pending, this function will block waiting for events to handle up until the specified timeout. If an event arrives or a signal is raised, this function will return early.</para><para>If the parameter completed is not NULL then <emphasis>after obtaining the event handling lock</emphasis> this function will return immediately if the integer pointed to is not 0. This allows for race free waiting for the completion of a specific transfer.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tv</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum time to block waiting for events, or an all zero timeval struct for non-blocking mode </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>completed</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to completion integer to check, or NULL </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2327" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2327" bodyend="2378"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga6deff4c7d3a6c04bb9ec9fd259b48933" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_handle_events_timeout</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv)</argsstring>
        <name>libusb_handle_events_timeout</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <briefdescription>
<para>Handle any pending events. </para>        </briefdescription>
        <detaileddescription>
<para>Like <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref>, but without the completed parameter, calling this function is equivalent to calling <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref> with a NULL completed parameter.</para><para>This function is kept primarily for backwards compatibility. All new code should call <ref refid="group__libusb__poll_1ga0bc99f39e4cf5ad393cd5936c36037d1" kindref="member">libusb_handle_events_completed()</ref> or <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref> to avoid race conditions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tv</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum time to block waiting for events, or an all zero timeval struct for non-blocking mode </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2396" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2396" bodyend="2400"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_handle_events</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_handle_events</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Handle any pending events in blocking mode. </para>        </briefdescription>
        <detaileddescription>
<para>There is currently a timeout hardcoded at 60 seconds but we plan to make it unlimited in future. For finer control over whether this function is blocking or non-blocking, or for control over the timeout, use <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref> instead.</para><para>This function is kept primarily for backwards compatibility. All new code should call <ref refid="group__libusb__poll_1ga0bc99f39e4cf5ad393cd5936c36037d1" kindref="member">libusb_handle_events_completed()</ref> or <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref> to avoid race conditions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2416" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2416" bodyend="2422"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga0bc99f39e4cf5ad393cd5936c36037d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_handle_events_completed</definition>
        <argsstring>(libusb_context *ctx, int *completed)</argsstring>
        <name>libusb_handle_events_completed</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>completed</declname>
        </param>
        <briefdescription>
<para>Handle any pending events in blocking mode. </para>        </briefdescription>
        <detaileddescription>
<para>Like <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref>, with the addition of a completed parameter to allow for race free waiting for the completion of a specific transfer.</para><para>See <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref> for details on the completed parameter.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>completed</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to completion integer to check, or NULL </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2438" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2438" bodyend="2445"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga71da081f97afa3bf68aed8e372254e8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_handle_events_locked</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv)</argsstring>
        <name>libusb_handle_events_locked</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <briefdescription>
<para>Handle any pending events by polling file descriptors, without checking if any other threads are already doing so. </para>        </briefdescription>
        <detaileddescription>
<para>Must be called with the event lock held, see <ref refid="group__libusb__poll_1gaa72153938dc4f34decfacbc6cc6237ef" kindref="member">libusb_lock_events()</ref>.</para><para>This function is designed to be called under the situation where you have taken the event lock and are calling poll()/select() directly on libusb&apos;s file descriptors (as opposed to using <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref> or similar). You detect events on libusb&apos;s descriptors, so you then call this function with a zero timeout value (while still holding the event lock).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tv</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum time to block waiting for events, or zero for non-blocking mode </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2464" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2464" bodyend="2478"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1gae7a654315636bebf404c1784429f06df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_pollfds_handle_timeouts</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_pollfds_handle_timeouts</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Determines whether your application must apply special timing considerations when monitoring libusb&apos;s file descriptors. </para>        </briefdescription>
        <detaileddescription>
<para>This function is only useful for applications which retrieve and poll libusb&apos;s file descriptors in their own main loop (<ref refid="group__libusb__poll_1libusb_pollmain" kindref="member">The more advanced option</ref>).</para><para>Ordinarily, libusb&apos;s event handler needs to be called into at specific moments in time (in addition to times when there is activity on the file descriptor set). The usual approach is to use <ref refid="group__libusb__poll_1ga5bc6f5bc71a43845244912da6679f634" kindref="member">libusb_get_next_timeout()</ref> to learn about when the next timeout occurs, and to adjust your poll()/select() timeout accordingly so that you can make a call into the library at that time.</para><para>Some platforms supported by libusb do not come with this baggage - any events relevant to timing will be represented by activity on the file descriptor set, and <ref refid="group__libusb__poll_1ga5bc6f5bc71a43845244912da6679f634" kindref="member">libusb_get_next_timeout()</ref> will always return 0. This function allows you to detect whether you are running on such a platform.</para><para>Since v1.0.5.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if you must call into libusb at times determined by <ref refid="group__libusb__poll_1ga5bc6f5bc71a43845244912da6679f634" kindref="member">libusb_get_next_timeout()</ref>, or 1 if all timeout events are handled internally or through regular activity on the file descriptors. <ref refid="group__libusb__poll_1libusb_pollmain" kindref="member">Polling libusb file descriptors for event handling</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2508" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2508" bodyend="2517"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga5bc6f5bc71a43845244912da6679f634" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_next_timeout</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv)</argsstring>
        <name>libusb_get_next_timeout</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <briefdescription>
<para>Determine the next internal timeout that libusb needs to handle. </para>        </briefdescription>
        <detaileddescription>
<para>You only need to use this function if you are calling poll() or select() or similar on libusb&apos;s file descriptors yourself - you do not need to use it if you are calling <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref> or a variant directly.</para><para>You should call this function in your main loop in order to determine how long to wait for select() or poll() to return results. libusb needs to be called into at this timeout, so you should use it as an upper bound on your select() or poll() call.</para><para>When the timeout has expired, call into <ref refid="group__libusb__poll_1ga6deff4c7d3a6c04bb9ec9fd259b48933" kindref="member">libusb_handle_events_timeout()</ref> (perhaps in non-blocking mode) so that libusb can handle the timeout.</para><para>This function may return 1 (success) and an all-zero timeval. If this is the case, it indicates that libusb has a timeout that has already expired so you should call <ref refid="group__libusb__poll_1ga6deff4c7d3a6c04bb9ec9fd259b48933" kindref="member">libusb_handle_events_timeout()</ref> or similar immediately. A return code of 0 indicates that there are no pending timeouts.</para><para>On some platforms, this function will always returns 0 (no pending timeouts). See <ref refid="group__libusb__poll_1polltime" kindref="member">Notes on time-based events</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tv</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for a relative time against the current clock in which libusb must be called into in order to process timeout events </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if there are no pending timeouts, 1 if a timeout was returned, or LIBUSB_ERROR_OTHER on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2547" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2547" bodyend="2602"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga1b7b2deb193f2e9ffda5e727361d7e67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_set_pollfd_notifiers</definition>
        <argsstring>(libusb_context *ctx, libusb_pollfd_added_cb added_cb, libusb_pollfd_removed_cb removed_cb, void *user_data)</argsstring>
        <name>libusb_set_pollfd_notifiers</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__poll_1ga2962a11284b09a3f18936d8f73a43804" kindref="member">libusb_pollfd_added_cb</ref></type>
          <declname>added_cb</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__poll_1ga32aa803f54cfb5bfe8b41747e6b62af5" kindref="member">libusb_pollfd_removed_cb</ref></type>
          <declname>removed_cb</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user_data</declname>
        </param>
        <briefdescription>
<para>Register notification functions for file descriptor additions/removals. </para>        </briefdescription>
        <detaileddescription>
<para>These functions will be invoked for every new or removed file descriptor that libusb uses as an event source.</para><para>To remove notifiers, pass NULL values for the function pointers.</para><para>Note that file descriptors may have been added even before you register these notifiers (e.g. at <ref refid="group__libusb__lib_1ga9517c37281bba0b51cc62eba728be48b" kindref="member">libusb_init()</ref> time).</para><para>Additionally, note that the removal notifier may be called during <ref refid="group__libusb__lib_1ga86532f222d4f1332a5f8f5eef9a92da9" kindref="member">libusb_exit()</ref> (e.g. when it is closing file descriptors that were opened and added to the poll set at <ref refid="group__libusb__lib_1ga9517c37281bba0b51cc62eba728be48b" kindref="member">libusb_init()</ref> time). If you don&apos;t want this, remove the notifiers immediately before calling <ref refid="group__libusb__lib_1ga86532f222d4f1332a5f8f5eef9a92da9" kindref="member">libusb_exit()</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>added_cb</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to function for addition notifications </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>removed_cb</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to function for removal notifications </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>User data to be passed back to callbacks (useful for passing context information) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2625" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2625" bodyend="2633"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1aebbf8d2243ce11210927e5e59e59a235" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void usbi_fd_notification</definition>
        <argsstring>(struct libusb_context *ctx)</argsstring>
        <name>usbi_fd_notification</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2639" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2639" bodyend="2649"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a4bbffcd6fb40830cf3fdee07d35f0588" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int usbi_add_pollfd</definition>
        <argsstring>(struct libusb_context *ctx, int fd, short events)</argsstring>
        <name>usbi_add_pollfd</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fd</declname>
        </param>
        <param>
          <type>short</type>
          <declname>events</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2654" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2654" bodyend="2672"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a6849e33dd24dae5311019eec843037ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void usbi_remove_pollfd</definition>
        <argsstring>(struct libusb_context *ctx, int fd)</argsstring>
        <name>usbi_remove_pollfd</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>fd</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2675" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2675" bodyend="2701"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga54c27dcf8a95d2a3a03cfb7dd37eae63" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const struct <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> **</type>
        <definition>const struct libusb_pollfd** libusb_get_pollfds</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_get_pollfds</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Retrieve a list of file descriptors that should be polled by your main loop as libusb event sources. </para>        </briefdescription>
        <detaileddescription>
<para>The returned list is NULL-terminated and should be freed with <ref refid="group__libusb__poll_1gad703b12ab275b6420c2c27e6279c955f" kindref="member">libusb_free_pollfds()</ref> when done. The actual list contents must not be touched.</para><para>As file descriptors are a Unix-specific concept, this function is not available on Windows and will always return NULL.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a NULL-terminated list of <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> structures </para></simplesect>
<simplesect kind="return"><para>NULL on error </para></simplesect>
<simplesect kind="return"><para>NULL on platforms where the functionality is not available </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2719" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2719" bodyend="2746"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1gad703b12ab275b6420c2c27e6279c955f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_pollfds</definition>
        <argsstring>(const struct libusb_pollfd **pollfds)</argsstring>
        <name>libusb_free_pollfds</name>
        <param>
          <type>const struct <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> **</type>
          <declname>pollfds</declname>
        </param>
        <briefdescription>
<para>Free a list of <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> structures. </para>        </briefdescription>
        <detaileddescription>
<para>This should be called for all pollfd lists allocated with <ref refid="group__libusb__poll_1ga54c27dcf8a95d2a3a03cfb7dd37eae63" kindref="member">libusb_get_pollfds()</ref>.</para><para>Since version 1.0.20, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000104</para><para>It is legal to call this function with a NULL pollfd list. In this case, the function will simply return safely.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pollfds</parametername>
</parameternamelist>
<parameterdescription>
<para>the list of <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> structures to free </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2759" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2759" bodyend="2765"/>
      </memberdef>
      <memberdef kind="function" id="io_8c_1a024e3907cb66fd19a2f3d66059b7246c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void usbi_handle_disconnect</definition>
        <argsstring>(struct libusb_device_handle *dev_handle)</argsstring>
        <name>usbi_handle_disconnect</name>
        <param>
          <type>struct <ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" line="2771" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2771" bodyend="2819"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c"/>
  </compounddef>
</doxygen>
