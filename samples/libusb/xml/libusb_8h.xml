<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="libusb_8h" kind="file" language="C++">
    <compoundname>libusb.h</compoundname>
    <includes local="no">stdint.h</includes>
    <includes local="no">sys/types.h</includes>
    <includes local="no">time.h</includes>
    <includes local="no">limits.h</includes>
    <incdepgraph>
      <node id="46">
        <label>stdint.h</label>
      </node>
      <node id="49">
        <label>limits.h</label>
      </node>
      <node id="47">
        <label>sys/types.h</label>
      </node>
      <node id="48">
        <label>time.h</label>
      </node>
      <node id="45">
        <label>libusb.h</label>
        <link refid="libusb_8h"/>
        <childnode refid="46" relation="include">
        </childnode>
        <childnode refid="47" relation="include">
        </childnode>
        <childnode refid="48" relation="include">
        </childnode>
        <childnode refid="49" relation="include">
        </childnode>
      </node>
    </incdepgraph>
    <innerclass refid="structlibusb__device__descriptor" prot="public">libusb_device_descriptor</innerclass>
    <innerclass refid="structlibusb__endpoint__descriptor" prot="public">libusb_endpoint_descriptor</innerclass>
    <innerclass refid="structlibusb__interface__descriptor" prot="public">libusb_interface_descriptor</innerclass>
    <innerclass refid="structlibusb__interface" prot="public">libusb_interface</innerclass>
    <innerclass refid="structlibusb__config__descriptor" prot="public">libusb_config_descriptor</innerclass>
    <innerclass refid="structlibusb__ss__endpoint__companion__descriptor" prot="public">libusb_ss_endpoint_companion_descriptor</innerclass>
    <innerclass refid="structlibusb__bos__dev__capability__descriptor" prot="public">libusb_bos_dev_capability_descriptor</innerclass>
    <innerclass refid="structlibusb__bos__descriptor" prot="public">libusb_bos_descriptor</innerclass>
    <innerclass refid="structlibusb__usb__2__0__extension__descriptor" prot="public">libusb_usb_2_0_extension_descriptor</innerclass>
    <innerclass refid="structlibusb__ss__usb__device__capability__descriptor" prot="public">libusb_ss_usb_device_capability_descriptor</innerclass>
    <innerclass refid="structlibusb__container__id__descriptor" prot="public">libusb_container_id_descriptor</innerclass>
    <innerclass refid="structlibusb__control__setup" prot="public">libusb_control_setup</innerclass>
    <innerclass refid="structlibusb__version" prot="public">libusb_version</innerclass>
    <innerclass refid="structlibusb__iso__packet__descriptor" prot="public">libusb_iso_packet_descriptor</innerclass>
    <innerclass refid="structlibusb__transfer" prot="public">libusb_transfer</innerclass>
    <innerclass refid="structlibusb__pollfd" prot="public">libusb_pollfd</innerclass>
      <sectiondef kind="define">
      <memberdef kind="define" id="libusb_8h_1a2698d3115702f9a9999c806872951cdd" prot="public" static="no">
        <name>LIBUSB_DEPRECATED_FOR</name>
        <param><defname>f</defname></param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="83" column="10" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="83" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__libusb__misc_1gaa7d6035eb2692d455d27144560a0f68d" prot="public" static="no">
        <name>LIBUSB_CALL</name>
        <briefdescription>
<para>libusb&apos;s Windows calling convention. </para>        </briefdescription>
        <detaileddescription>
<para>Under Windows, the selection of available compilers and configurations means that, unlike other platforms, there is not <emphasis>one true calling convention</emphasis> (calling convention: the manner in which parameters are passed to functions in the generated assembly code).</para><para>Matching the Windows API itself, libusb uses the WINAPI convention (which translates to the <computeroutput>stdcall</computeroutput> convention) and guarantees that the library is compiled in this way. The public header file also includes appropriate annotations so that your own software will use the right convention, even if another convention is being used by default within your codebase.</para><para>The one consideration that you must apply in your software is to mark all functions which you use as libusb callbacks with this LIBUSB_CALL annotation, so that they too get compiled for the correct calling convention.</para><para>On non-Windows operating systems, this macro is defined as nothing. This means that you can apply it to your code without worrying about cross-platform compatibility. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="121" column="10" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="121" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" prot="public" static="no">
        <name>LIBUSB_API_VERSION</name>
        <initializer>0x01000105</initializer>
        <briefdescription>
<para>libusb&apos;s API version. </para>        </briefdescription>
        <detaileddescription>
<para>Since version 1.0.13, to help with feature detection, libusb defines a LIBUSB_API_VERSION macro that gets increased every time there is a significant change to the API, such as the introduction of a new call, the definition of a new macro/enum member, or any other element that libusb applications may want to detect at compilation time.</para><para>The macro is typically used in an application as follows: <programlisting><codeline><highlight class="normal">#if<sp/>defined(LIBUSB_API_VERSION)<sp/>&amp;&amp;<sp/>(LIBUSB_API_VERSION<sp/>&gt;=<sp/>0x01001234)</highlight></codeline>
<codeline><highlight class="normal">//<sp/>Use<sp/>one<sp/>of<sp/>the<sp/>newer<sp/>features<sp/>from<sp/>the<sp/>libusb<sp/>API</highlight></codeline>
<codeline><highlight class="normal">#endif</highlight></codeline>
</programlisting></para><para>Internally, LIBUSB_API_VERSION is defined as follows: (libusb major &lt;&lt; 24) | (libusb minor &lt;&lt; 16) | (16 bit incremental) </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="144" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="144" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1aa83ecded256e0767220bcc21cc92365d" prot="public" static="no">
        <name>LIBUSBX_API_VERSION</name>
        <initializer><ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref></initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="147" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="147" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__libusb__misc_1ga22961bb8cb0d6a9b22c88079efb59b8b" prot="public" static="no">
        <name>libusb_le16_to_cpu</name>
        <initializer><ref refid="group__libusb__misc_1gae3b1162b8e69b49bbf74dcbbdeeadbda" kindref="member">libusb_cpu_to_le16</ref></initializer>
        <briefdescription>
<para>Convert a 16-bit value from little-endian to host-endian format. </para>        </briefdescription>
        <detaileddescription>
<para>On little endian systems, this function does nothing. On big endian systems, the bytes are swapped. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the little-endian value to convert </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the value in host-endian byte order </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="180" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="180" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1ae508b6ba07730085fb3af2891406ab8f" prot="public" static="no">
        <name>LIBUSB_DT_DEVICE_SIZE</name>
        <initializer>18</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="290" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="290" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1ab7001b519280b66cf9c707f87c6005b3" prot="public" static="no">
        <name>LIBUSB_DT_CONFIG_SIZE</name>
        <initializer>9</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="291" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="291" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1ac7327580a45c1028c93b8bb7db6a5e57" prot="public" static="no">
        <name>LIBUSB_DT_INTERFACE_SIZE</name>
        <initializer>9</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="292" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="292" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1ae552a669c2f058e790f28dc2003ca950" prot="public" static="no">
        <name>LIBUSB_DT_ENDPOINT_SIZE</name>
        <initializer>7</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="293" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="293" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1ac58326aebf1aa7689277004bdeb341d4" prot="public" static="no">
        <name>LIBUSB_DT_ENDPOINT_AUDIO_SIZE</name>
        <initializer>9	/* Audio extension */</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="294" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="294" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1ac265b185cdb5fb3a060ff55ef5d143f4" prot="public" static="no">
        <name>LIBUSB_DT_HUB_NONVAR_SIZE</name>
        <initializer>7</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="295" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="295" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a979bdc4ea2d9ced3597fbac9fa662498" prot="public" static="no">
        <name>LIBUSB_DT_SS_ENDPOINT_COMPANION_SIZE</name>
        <initializer>6</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="296" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="296" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1adb2eff5a633eb521aa4f1d5511ad5dbb" prot="public" static="no">
        <name>LIBUSB_DT_BOS_SIZE</name>
        <initializer>5</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="297" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="297" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1af86d8c390f27a8ef7eb842f0d4799ecb" prot="public" static="no">
        <name>LIBUSB_DT_DEVICE_CAPABILITY_SIZE</name>
        <initializer>3</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="298" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="298" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a291016200aa973044c586eb1dd1b0712" prot="public" static="no">
        <name>LIBUSB_BT_USB_2_0_EXTENSION_SIZE</name>
        <initializer>7</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="301" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="301" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a25ff6ca821e57fb551b9e07a025f510e" prot="public" static="no">
        <name>LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE</name>
        <initializer>10</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="302" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="302" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a1c38198af7c00fd12b11919b74e2019a" prot="public" static="no">
        <name>LIBUSB_BT_CONTAINER_ID_SIZE</name>
        <initializer>20</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="303" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="303" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a8dac81b646ce578d008165869d477c5f" prot="public" static="no">
        <name>LIBUSB_DT_BOS_MAX_SIZE</name>
        <initializer>((LIBUSB_DT_BOS_SIZE)     +\
					(LIBUSB_BT_USB_2_0_EXTENSION_SIZE)       +\
					(LIBUSB_BT_SS_USB_DEVICE_CAPABILITY_SIZE) +\
					(LIBUSB_BT_CONTAINER_ID_SIZE))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="306" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="306" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a9c3a2631dd8aa2d78d68a91fd7bb299c" prot="public" static="no">
        <name>LIBUSB_ENDPOINT_ADDRESS_MASK</name>
        <initializer>0x0f    /* in bEndpointAddress */</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="311" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="311" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a44868bdcbb34eb58070f16fc7b912384" prot="public" static="no">
        <name>LIBUSB_ENDPOINT_DIR_MASK</name>
        <initializer>0x80</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="312" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="312" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a5713da542b75569bbfd972b1422a4ddb" prot="public" static="no">
        <name>LIBUSB_TRANSFER_TYPE_MASK</name>
        <initializer>0x03    /* in bmAttributes */</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="326" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="326" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a98f14c9168a01b7cf3bea051e29e2d2c" prot="public" static="no">
        <name>LIBUSB_ISO_SYNC_TYPE_MASK</name>
        <initializer>0x0C</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="433" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="433" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a17158be32124e69ad91823f52e511123" prot="public" static="no">
        <name>LIBUSB_ISO_USAGE_TYPE_MASK</name>
        <initializer>0x30</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="454" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="454" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1af39dc5e7622e8559df7f1d3da5478717" prot="public" static="no">
        <name>LIBUSB_CONTROL_SETUP_SIZE</name>
        <initializer>(sizeof(struct <ref refid="structlibusb__control__setup" kindref="compound">libusb_control_setup</ref>))</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="894" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="894" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="libusb_8h_1a784c39b6aab35cf2b21ee8f28a77edb0" prot="public" static="no">
        <name>LIBUSB_ERROR_COUNT</name>
        <initializer>14</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1102" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1102" bodyend="-1"/>
      </memberdef>
      <memberdef kind="define" id="group__libusb__hotplug_1ga6d4f5e524a3b7ab4a25b751073335d4c" prot="public" static="no">
        <name>LIBUSB_HOTPLUG_MATCH_ANY</name>
        <initializer>-1</initializer>
        <briefdescription>
<para>Wildcard matching for hotplug events. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1918" column="9" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1918" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="group__libusb__desc_1gac529888effbefef8af4f9d17ebc903a1" prot="public" static="no">
        <name>libusb_class_code</name>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1ac6d01c08f92219d625162271d9547550" prot="public">
          <name>LIBUSB_CLASS_PER_INTERFACE</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>In the context of a <ref refid="structlibusb__device__descriptor" kindref="compound">device descriptor</ref>, this bDeviceClass value indicates that each interface specifies its own class information and all interfaces operate independently. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1a1f87be5c5c32c30e1e6831abdb61461a" prot="public">
          <name>LIBUSB_CLASS_AUDIO</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Audio class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1a7db61f0ea65d1919962ac0370513183b" prot="public">
          <name>LIBUSB_CLASS_COMM</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Communications class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1ad126069ffbc9cb3cda97fe0fe8c190f3" prot="public">
          <name>LIBUSB_CLASS_HID</name>
          <initializer>= 3</initializer>
          <briefdescription>
<para>Human Interface Device class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1a7abdd4f2d21f046622717f70ad0b6ea9" prot="public">
          <name>LIBUSB_CLASS_PHYSICAL</name>
          <initializer>= 5</initializer>
          <briefdescription>
<para>Physical. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1ab1592f5d41d4ee3ccfe0adef8cbf04ee" prot="public">
          <name>LIBUSB_CLASS_PRINTER</name>
          <initializer>= 7</initializer>
          <briefdescription>
<para>Printer class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1abcd1d4f42671058f70ab9ae41c5ce303" prot="public">
          <name>LIBUSB_CLASS_PTP</name>
          <initializer>= 6</initializer>
          <briefdescription>
<para>Image class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1af393b0c8f1da0b9c558f6e5c113b59b2" prot="public">
          <name>LIBUSB_CLASS_IMAGE</name>
          <initializer>= 6</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1ac84d2301375aef28bf5c3f4bda35f9d1" prot="public">
          <name>LIBUSB_CLASS_MASS_STORAGE</name>
          <initializer>= 8</initializer>
          <briefdescription>
<para>Mass storage class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1a28ba55c39b90ba3f281542e4ffdb626d" prot="public">
          <name>LIBUSB_CLASS_HUB</name>
          <initializer>= 9</initializer>
          <briefdescription>
<para>Hub class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1aa18621124b0db0f8972556647ad16827" prot="public">
          <name>LIBUSB_CLASS_DATA</name>
          <initializer>= 10</initializer>
          <briefdescription>
<para>Data class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1af4ec75b9ab816c46da747c80bbf9cca0" prot="public">
          <name>LIBUSB_CLASS_SMART_CARD</name>
          <initializer>= 0x0b</initializer>
          <briefdescription>
<para>Smart Card. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1a5d306be7a6fbfb331ce25c8c804eada8" prot="public">
          <name>LIBUSB_CLASS_CONTENT_SECURITY</name>
          <initializer>= 0x0d</initializer>
          <briefdescription>
<para>Content Security. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1a7deae7d18c3d99dda5bb3bd8b6ec01da" prot="public">
          <name>LIBUSB_CLASS_VIDEO</name>
          <initializer>= 0x0e</initializer>
          <briefdescription>
<para>Video. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1ab97e8441e102707252263abcdc29b4c0" prot="public">
          <name>LIBUSB_CLASS_PERSONAL_HEALTHCARE</name>
          <initializer>= 0x0f</initializer>
          <briefdescription>
<para>Personal Healthcare. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1a5f1089ee11b766a10a27c0c0600bebfa" prot="public">
          <name>LIBUSB_CLASS_DIAGNOSTIC_DEVICE</name>
          <initializer>= 0xdc</initializer>
          <briefdescription>
<para>Diagnostic Device. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1aaeea39cf3f500f56381cd6e05132d934" prot="public">
          <name>LIBUSB_CLASS_WIRELESS</name>
          <initializer>= 0xe0</initializer>
          <briefdescription>
<para>Wireless class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1a3a95beae54453469c4862efc1606dcc9" prot="public">
          <name>LIBUSB_CLASS_APPLICATION</name>
          <initializer>= 0xfe</initializer>
          <briefdescription>
<para>Application class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggac529888effbefef8af4f9d17ebc903a1ad68e1d33a332360428f838c6ddd847f6" prot="public">
          <name>LIBUSB_CLASS_VENDOR_SPEC</name>
          <initializer>= 0xff</initializer>
          <briefdescription>
<para>Class is vendor-specific. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Device and/or Interface Class codes. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="186" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="186" bodyend="244"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__desc_1ga0a2e8a25dfdebf29fdd4764dcdbc1a9c" prot="public" static="no">
        <name>libusb_descriptor_type</name>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca486e222e9f3053502ce4954a5bd89ba2" prot="public">
          <name>LIBUSB_DT_DEVICE</name>
          <initializer>= 0x01</initializer>
          <briefdescription>
<para>Device descriptor. </para>          </briefdescription>
          <detaileddescription>
<para>See <ref refid="structlibusb__device__descriptor" kindref="compound">libusb_device_descriptor</ref>. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca2a3f906d7755932ab67f39701da0b508" prot="public">
          <name>LIBUSB_DT_CONFIG</name>
          <initializer>= 0x02</initializer>
          <briefdescription>
<para>Configuration descriptor. </para>          </briefdescription>
          <detaileddescription>
<para>See <ref refid="structlibusb__config__descriptor" kindref="compound">libusb_config_descriptor</ref>. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca2b8ca4332dce1357767ecab20ed2f4c2" prot="public">
          <name>LIBUSB_DT_STRING</name>
          <initializer>= 0x03</initializer>
          <briefdescription>
<para>String descriptor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca797f18e35ee27434562aed0c20c46b78" prot="public">
          <name>LIBUSB_DT_INTERFACE</name>
          <initializer>= 0x04</initializer>
          <briefdescription>
<para>Interface descriptor. </para>          </briefdescription>
          <detaileddescription>
<para>See <ref refid="structlibusb__interface__descriptor" kindref="compound">libusb_interface_descriptor</ref>. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca97df43465eec9e6db81346f521777815" prot="public">
          <name>LIBUSB_DT_ENDPOINT</name>
          <initializer>= 0x05</initializer>
          <briefdescription>
<para>Endpoint descriptor. </para>          </briefdescription>
          <detaileddescription>
<para>See <ref refid="structlibusb__endpoint__descriptor" kindref="compound">libusb_endpoint_descriptor</ref>. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9caab1245826594605de870d70bffae7f2c" prot="public">
          <name>LIBUSB_DT_BOS</name>
          <initializer>= 0x0f</initializer>
          <briefdescription>
<para>BOS descriptor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca56875fd1a3df25bdea7680fa9047743c" prot="public">
          <name>LIBUSB_DT_DEVICE_CAPABILITY</name>
          <initializer>= 0x10</initializer>
          <briefdescription>
<para>Device Capability descriptor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca3085fb63563770bfa1ede7b27cbf4f5e" prot="public">
          <name>LIBUSB_DT_HID</name>
          <initializer>= 0x21</initializer>
          <briefdescription>
<para>HID descriptor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca3972f13fb6b6abdb0978dc43d9d24e6f" prot="public">
          <name>LIBUSB_DT_REPORT</name>
          <initializer>= 0x22</initializer>
          <briefdescription>
<para>HID report descriptor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca77c22f3dc80f2a505c22c68cc54c70d3" prot="public">
          <name>LIBUSB_DT_PHYSICAL</name>
          <initializer>= 0x23</initializer>
          <briefdescription>
<para>Physical descriptor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca2186edbc7dc05b063ac41103a5ccfa9a" prot="public">
          <name>LIBUSB_DT_HUB</name>
          <initializer>= 0x29</initializer>
          <briefdescription>
<para>Hub descriptor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca6892da187e642c8a9b7900e86bf38ba8" prot="public">
          <name>LIBUSB_DT_SUPERSPEED_HUB</name>
          <initializer>= 0x2a</initializer>
          <briefdescription>
<para>SuperSpeed Hub descriptor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga0a2e8a25dfdebf29fdd4764dcdbc1a9ca9bdd0a16eb0647330c2b7085520db533" prot="public">
          <name>LIBUSB_DT_SS_ENDPOINT_COMPANION</name>
          <initializer>= 0x30</initializer>
          <briefdescription>
<para>SuperSpeed Endpoint Companion descriptor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Descriptor types as defined by the USB specification. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="248" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="248" bodyend="287"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__desc_1ga86c880af878493aa8f805c2aba654b8b" prot="public" static="no">
        <name>libusb_endpoint_direction</name>
        <enumvalue id="group__libusb__desc_1gga86c880af878493aa8f805c2aba654b8ba3829979c66e5344367f32f4a31d43613" prot="public">
          <name>LIBUSB_ENDPOINT_IN</name>
          <initializer>= 0x80</initializer>
          <briefdescription>
<para>In: device-to-host. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1gga86c880af878493aa8f805c2aba654b8ba940484c16d44bdfc6eccc2de7a9ffcb2" prot="public">
          <name>LIBUSB_ENDPOINT_OUT</name>
          <initializer>= 0x00</initializer>
          <briefdescription>
<para>Out: host-to-device. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Endpoint direction. </para>        </briefdescription>
        <detaileddescription>
<para>Values for bit 7 of the <ref refid="structlibusb__endpoint__descriptor_1a111d087a09cbeded8e15eda9127e23d2" kindref="member">endpoint address</ref> scheme. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="318" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="318" bodyend="324"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__desc_1gacb52027036a07de6ecc6c2bf07d07c71" prot="public" static="no">
        <name>libusb_transfer_type</name>
        <enumvalue id="group__libusb__desc_1ggacb52027036a07de6ecc6c2bf07d07c71a4c89624658c783ef9b2a2f08091bc7d7" prot="public">
          <name>LIBUSB_TRANSFER_TYPE_CONTROL</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>Control endpoint. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggacb52027036a07de6ecc6c2bf07d07c71a40de9889554fc1785d784b3c31333300" prot="public">
          <name>LIBUSB_TRANSFER_TYPE_ISOCHRONOUS</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Isochronous endpoint. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggacb52027036a07de6ecc6c2bf07d07c71a7bdfa2fc5dadbaaa0e9262e1b4a228e2" prot="public">
          <name>LIBUSB_TRANSFER_TYPE_BULK</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Bulk endpoint. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggacb52027036a07de6ecc6c2bf07d07c71aefb0e07862c0eed894ec9c2f957a7e3c" prot="public">
          <name>LIBUSB_TRANSFER_TYPE_INTERRUPT</name>
          <initializer>= 3</initializer>
          <briefdescription>
<para>Interrupt endpoint. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggacb52027036a07de6ecc6c2bf07d07c71a3b26ee40f9c586ece75f8de822d974e3" prot="public">
          <name>LIBUSB_TRANSFER_TYPE_BULK_STREAM</name>
          <initializer>= 4</initializer>
          <briefdescription>
<para>Stream endpoint. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Endpoint transfer type. </para>        </briefdescription>
        <detaileddescription>
<para>Values for bits 0:1 of the <ref refid="structlibusb__endpoint__descriptor_1a932b84417c46467f9916ecf7b679160b" kindref="member">endpoint attributes</ref> field. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="332" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="332" bodyend="347"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__misc_1ga5b5912057c2d7e23b3ed5aa0c20236df" prot="public" static="no">
        <name>libusb_standard_request</name>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfa42f2eefbbd7a5c5cce68ca5989a02a7a" prot="public">
          <name>LIBUSB_REQUEST_GET_STATUS</name>
          <initializer>= 0x00</initializer>
          <briefdescription>
<para>Request status of the specific recipient. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfa0b0f3b3ac6e8ebca120bf3581c5505de" prot="public">
          <name>LIBUSB_REQUEST_CLEAR_FEATURE</name>
          <initializer>= 0x01</initializer>
          <briefdescription>
<para>Clear or disable a specific feature. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfa6059966cdfccc4db0cccaab22a6d9a83" prot="public">
          <name>LIBUSB_REQUEST_SET_FEATURE</name>
          <initializer>= 0x03</initializer>
          <briefdescription>
<para>Set or enable a specific feature. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfa7c69aef99e548d128bc1f9e18c539c1d" prot="public">
          <name>LIBUSB_REQUEST_SET_ADDRESS</name>
          <initializer>= 0x05</initializer>
          <briefdescription>
<para>Set device address for all future accesses. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfa3ebb19fe897a2a36e90b2e8193b88b0f" prot="public">
          <name>LIBUSB_REQUEST_GET_DESCRIPTOR</name>
          <initializer>= 0x06</initializer>
          <briefdescription>
<para>Get the specified descriptor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfa40ad5a26219379bbbeab2137b21dcb74" prot="public">
          <name>LIBUSB_REQUEST_SET_DESCRIPTOR</name>
          <initializer>= 0x07</initializer>
          <briefdescription>
<para>Used to update existing descriptors or add new descriptors. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfa7e33754fe6c088b94905c387155a8586" prot="public">
          <name>LIBUSB_REQUEST_GET_CONFIGURATION</name>
          <initializer>= 0x08</initializer>
          <briefdescription>
<para>Get the current device configuration value. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfaefcadf8a4b1f0d1dadd79764486b2cb3" prot="public">
          <name>LIBUSB_REQUEST_SET_CONFIGURATION</name>
          <initializer>= 0x09</initializer>
          <briefdescription>
<para>Set device configuration. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfa179b703deda249f6e48412bc2cf61d8c" prot="public">
          <name>LIBUSB_REQUEST_GET_INTERFACE</name>
          <initializer>= 0x0A</initializer>
          <briefdescription>
<para>Return the selected alternate setting for the specified interface. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfa72e910864721ebe3e5cb6a5b53de6061" prot="public">
          <name>LIBUSB_REQUEST_SET_INTERFACE</name>
          <initializer>= 0x0B</initializer>
          <briefdescription>
<para>Select an alternate interface for the specified interface. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfab4244333798720a3664e59187819f2d5" prot="public">
          <name>LIBUSB_REQUEST_SYNCH_FRAME</name>
          <initializer>= 0x0C</initializer>
          <briefdescription>
<para>Set then report an endpoint&apos;s synchronization frame. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfa8fc0213fcc23566ec28e88bee216777b" prot="public">
          <name>LIBUSB_REQUEST_SET_SEL</name>
          <initializer>= 0x30</initializer>
          <briefdescription>
<para>Sets both the U1 and U2 Exit Latency. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga5b5912057c2d7e23b3ed5aa0c20236dfaa280efe17cdd0be55d528b9932142376" prot="public">
          <name>LIBUSB_SET_ISOCH_DELAY</name>
          <initializer>= 0x31</initializer>
          <briefdescription>
<para>Delay from the time a host transmits a packet to the time it is received by the device. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Standard requests, as defined in table 9-5 of the USB 3.0 specifications. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="351" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="351" bodyend="395"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__misc_1ga0b0933ae70744726cde11254c39fac91" prot="public" static="no">
        <name>libusb_request_type</name>
        <enumvalue id="group__libusb__misc_1gga0b0933ae70744726cde11254c39fac91a20eca62c34d2d25be7e1776510184209" prot="public">
          <name>LIBUSB_REQUEST_TYPE_STANDARD</name>
          <initializer>= (0x00 &lt;&lt; 5)</initializer>
          <briefdescription>
<para>Standard. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga0b0933ae70744726cde11254c39fac91a43f45ae56bf339e3f984a4182fdd85f0" prot="public">
          <name>LIBUSB_REQUEST_TYPE_CLASS</name>
          <initializer>= (0x01 &lt;&lt; 5)</initializer>
          <briefdescription>
<para>Class. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga0b0933ae70744726cde11254c39fac91a1585f40d2a73c752a5f60688612c1345" prot="public">
          <name>LIBUSB_REQUEST_TYPE_VENDOR</name>
          <initializer>= (0x02 &lt;&lt; 5)</initializer>
          <briefdescription>
<para>Vendor. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga0b0933ae70744726cde11254c39fac91a8e2a1b00f9bcf05d3303c75c9e9cda69" prot="public">
          <name>LIBUSB_REQUEST_TYPE_RESERVED</name>
          <initializer>= (0x03 &lt;&lt; 5)</initializer>
          <briefdescription>
<para>Reserved. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Request type bits of the <ref refid="structlibusb__control__setup_1a39b148c231d675492ccd2383196926bf" kindref="member">bmRequestType</ref> field in control transfers. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="401" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="401" bodyend="413"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__misc_1ga20a4e8a729aa543fa742a5086596cbae" prot="public" static="no">
        <name>libusb_request_recipient</name>
        <enumvalue id="group__libusb__misc_1gga20a4e8a729aa543fa742a5086596cbaeaf39ffde2a586d565a817bfd591f2dc33" prot="public">
          <name>LIBUSB_RECIPIENT_DEVICE</name>
          <initializer>= 0x00</initializer>
          <briefdescription>
<para>Device. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga20a4e8a729aa543fa742a5086596cbaea9e5f9678cb9b301ccc07a247d350aadc" prot="public">
          <name>LIBUSB_RECIPIENT_INTERFACE</name>
          <initializer>= 0x01</initializer>
          <briefdescription>
<para>Interface. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga20a4e8a729aa543fa742a5086596cbaea6873e84c5a1ae0160891ebab16e5d93b" prot="public">
          <name>LIBUSB_RECIPIENT_ENDPOINT</name>
          <initializer>= 0x02</initializer>
          <briefdescription>
<para>Endpoint. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1gga20a4e8a729aa543fa742a5086596cbaeae6f863cf9e2122d2194916876e9477eb" prot="public">
          <name>LIBUSB_RECIPIENT_OTHER</name>
          <initializer>= 0x03</initializer>
          <briefdescription>
<para>Other. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Recipient bits of the <ref refid="structlibusb__control__setup_1a39b148c231d675492ccd2383196926bf" kindref="member">bmRequestType</ref> field in control transfers. </para>        </briefdescription>
        <detaileddescription>
<para>Values 4 through 31 are reserved. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="419" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="419" bodyend="431"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__desc_1gaa2231202dfe12eddca49b1193d44a441" prot="public" static="no">
        <name>libusb_iso_sync_type</name>
        <enumvalue id="group__libusb__desc_1ggaa2231202dfe12eddca49b1193d44a441a4a74eefd565a40b4ed911baaaaea1cee" prot="public">
          <name>LIBUSB_ISO_SYNC_TYPE_NONE</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>No synchronization. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggaa2231202dfe12eddca49b1193d44a441ab97a868cd66bfcac50f9ccf8ff0b3a67" prot="public">
          <name>LIBUSB_ISO_SYNC_TYPE_ASYNC</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Asynchronous. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggaa2231202dfe12eddca49b1193d44a441a813f487563e5b61a8399e7512f0c303b" prot="public">
          <name>LIBUSB_ISO_SYNC_TYPE_ADAPTIVE</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Adaptive. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggaa2231202dfe12eddca49b1193d44a441a39244a977707c95c7f3ba0e978faba84" prot="public">
          <name>LIBUSB_ISO_SYNC_TYPE_SYNC</name>
          <initializer>= 3</initializer>
          <briefdescription>
<para>Synchronous. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Synchronization type for isochronous endpoints. </para>        </briefdescription>
        <detaileddescription>
<para>Values for bits 2:3 of the <ref refid="structlibusb__endpoint__descriptor_1a932b84417c46467f9916ecf7b679160b" kindref="member">bmAttributes</ref> field in <ref refid="structlibusb__endpoint__descriptor" kindref="compound">libusb_endpoint_descriptor</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="440" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="440" bodyend="452"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__desc_1gab72474551b0eb965401e6febb856007c" prot="public" static="no">
        <name>libusb_iso_usage_type</name>
        <enumvalue id="group__libusb__desc_1ggab72474551b0eb965401e6febb856007ca13edfd0d36d959bcf32d5cca341c7f38" prot="public">
          <name>LIBUSB_ISO_USAGE_TYPE_DATA</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>Data endpoint. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggab72474551b0eb965401e6febb856007ca2390aa76c4444e0b590fb65f305e4485" prot="public">
          <name>LIBUSB_ISO_USAGE_TYPE_FEEDBACK</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Feedback endpoint. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__desc_1ggab72474551b0eb965401e6febb856007ca8e48a0bad38cfaf0e87dfdc225f91e32" prot="public">
          <name>LIBUSB_ISO_USAGE_TYPE_IMPLICIT</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Implicit feedback Data endpoint. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Usage type for isochronous endpoints. </para>        </briefdescription>
        <detaileddescription>
<para>Values for bits 4:5 of the <ref refid="structlibusb__endpoint__descriptor_1a932b84417c46467f9916ecf7b679160b" kindref="member">bmAttributes</ref> field in <ref refid="structlibusb__endpoint__descriptor" kindref="compound">libusb_endpoint_descriptor</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="461" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="461" bodyend="470"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__dev_1ga2959abf1184f87b2ce06fe90db6ce614" prot="public" static="no">
        <name>libusb_speed</name>
        <enumvalue id="group__libusb__dev_1gga2959abf1184f87b2ce06fe90db6ce614ace31df1e97e9a66146ac83dcab1e6cfb" prot="public">
          <name>LIBUSB_SPEED_UNKNOWN</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>The OS doesn&apos;t report or know the device speed. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__dev_1gga2959abf1184f87b2ce06fe90db6ce614a6017f9ac2509cd523b51c1b72ad6991b" prot="public">
          <name>LIBUSB_SPEED_LOW</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>The device is operating at low speed (1.5MBit/s). </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__dev_1gga2959abf1184f87b2ce06fe90db6ce614a0011bead7a48b873808795d8495b4d9e" prot="public">
          <name>LIBUSB_SPEED_FULL</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>The device is operating at full speed (12MBit/s). </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__dev_1gga2959abf1184f87b2ce06fe90db6ce614a27bc0b9fe76f8ddf524f3d2ece0eefac" prot="public">
          <name>LIBUSB_SPEED_HIGH</name>
          <initializer>= 3</initializer>
          <briefdescription>
<para>The device is operating at high speed (480MBit/s). </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__dev_1gga2959abf1184f87b2ce06fe90db6ce614ab8c71e1409cd555ae05937b4db9946a2" prot="public">
          <name>LIBUSB_SPEED_SUPER</name>
          <initializer>= 4</initializer>
          <briefdescription>
<para>The device is operating at super speed (5000MBit/s). </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Speed codes. </para>        </briefdescription>
        <detaileddescription>
<para>Indicates the speed at which the device is operating. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="975" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="975" bodyend="990"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__dev_1ga1454797ecc0de4d084c1619c420014f6" prot="public" static="no">
        <name>libusb_supported_speed</name>
        <enumvalue id="group__libusb__dev_1gga1454797ecc0de4d084c1619c420014f6aa7707c4cef77f4be8aceef859fad2087" prot="public">
          <name>LIBUSB_LOW_SPEED_OPERATION</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Low speed operation supported (1.5MBit/s). </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__dev_1gga1454797ecc0de4d084c1619c420014f6adbebc659daf53947527259172f81b41a" prot="public">
          <name>LIBUSB_FULL_SPEED_OPERATION</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Full speed operation supported (12MBit/s). </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__dev_1gga1454797ecc0de4d084c1619c420014f6a2db8b2bb845a23ad1083521ff5b6e9a8" prot="public">
          <name>LIBUSB_HIGH_SPEED_OPERATION</name>
          <initializer>= 4</initializer>
          <briefdescription>
<para>High speed operation supported (480MBit/s). </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__dev_1gga1454797ecc0de4d084c1619c420014f6accd7b9361912b76e40348dc30e6dc7f4" prot="public">
          <name>LIBUSB_SUPER_SPEED_OPERATION</name>
          <initializer>= 8</initializer>
          <briefdescription>
<para>Superspeed operation supported (5000MBit/s). </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Supported speeds (wSpeedSupported) bitfield. </para>        </briefdescription>
        <detaileddescription>
<para>Indicates what speeds the device supports. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="996" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="996" bodyend="1008"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__dev_1gacb8cfa928bffdd0066a3dd2e6aba0558" prot="public" static="no">
        <name>libusb_usb_2_0_extension_attributes</name>
        <enumvalue id="group__libusb__dev_1ggacb8cfa928bffdd0066a3dd2e6aba0558a02f60b018f4bc01e8813da813779b792" prot="public">
          <name>LIBUSB_BM_LPM_SUPPORT</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Supports Link Power Management (LPM) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Masks for the bits of the <ref refid="structlibusb__usb__2__0__extension__descriptor_1ab22e1857d38c9205aaecca52b2e20ae0" kindref="member">bmAttributes</ref> field of the USB 2.0 Extension descriptor. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1015" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1015" bodyend="1018"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__dev_1gaad5a5399176a35a64164dafad7fe4fcd" prot="public" static="no">
        <name>libusb_ss_usb_device_capability_attributes</name>
        <enumvalue id="group__libusb__dev_1ggaad5a5399176a35a64164dafad7fe4fcda5987a17b394338df71c1e04c5c75bc21" prot="public">
          <name>LIBUSB_BM_LTM_SUPPORT</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>Supports Latency Tolerance Messages (LTM) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Masks for the bits of the <ref refid="structlibusb__ss__usb__device__capability__descriptor_1ad387790c14d8d6eefe6aa1b4a55006bf" kindref="member">bmAttributes</ref> field field of the SuperSpeed USB Device Capability descriptor. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1025" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1025" bodyend="1028"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__dev_1ga6ccabbf3b3728ae69608ba83bba4e64c" prot="public" static="no">
        <name>libusb_bos_type</name>
        <enumvalue id="group__libusb__dev_1gga6ccabbf3b3728ae69608ba83bba4e64cac05dcfcd0a5c0dbaef90b1d09e4b5505" prot="public">
          <name>LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>Wireless USB device capability. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__dev_1gga6ccabbf3b3728ae69608ba83bba4e64ca243b090db95a0fdf7104fbf581724b86" prot="public">
          <name>LIBUSB_BT_USB_2_0_EXTENSION</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>USB 2.0 extensions. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__dev_1gga6ccabbf3b3728ae69608ba83bba4e64ca2f1ab0d2d1e14d4942c079749b1b6c85" prot="public">
          <name>LIBUSB_BT_SS_USB_DEVICE_CAPABILITY</name>
          <initializer>= 3</initializer>
          <briefdescription>
<para>SuperSpeed USB device capability. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__dev_1gga6ccabbf3b3728ae69608ba83bba4e64cac3c00e8861b4b596ea1f53c505809e5e" prot="public">
          <name>LIBUSB_BT_CONTAINER_ID</name>
          <initializer>= 4</initializer>
          <briefdescription>
<para>Container ID type. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>USB capability types. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1033" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1033" bodyend="1045"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__misc_1gab2323aa0f04bc22038e7e1740b2f29ef" prot="public" static="no">
        <name>libusb_error</name>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa576d8d63f6e24b2e57cb2ca63b304f15" prot="public">
          <name>LIBUSB_SUCCESS</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>Success (no error) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa790feab8b45d8c323038f4d7d15eceec" prot="public">
          <name>LIBUSB_ERROR_IO</name>
          <initializer>= -1</initializer>
          <briefdescription>
<para>Input/output error. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa680e4bf39b66a36be3182be3ebf58062" prot="public">
          <name>LIBUSB_ERROR_INVALID_PARAM</name>
          <initializer>= -2</initializer>
          <briefdescription>
<para>Invalid parameter. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa131f3c2f6f2bb40bc6fb60ccb6f3152f" prot="public">
          <name>LIBUSB_ERROR_ACCESS</name>
          <initializer>= -3</initializer>
          <briefdescription>
<para>Access denied (insufficient permissions) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efaf8d98f464314a8e202507a0e5c67336f" prot="public">
          <name>LIBUSB_ERROR_NO_DEVICE</name>
          <initializer>= -4</initializer>
          <briefdescription>
<para>No such device (it may have been disconnected) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa28214194dc4399e51777408b2c27f03f" prot="public">
          <name>LIBUSB_ERROR_NOT_FOUND</name>
          <initializer>= -5</initializer>
          <briefdescription>
<para>Entity not found. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa34ede1140a8a16022f730ac80875ed3b" prot="public">
          <name>LIBUSB_ERROR_BUSY</name>
          <initializer>= -6</initializer>
          <briefdescription>
<para>Resource busy. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa9b000ac2e6dc4ac864c59579dd08c8bd" prot="public">
          <name>LIBUSB_ERROR_TIMEOUT</name>
          <initializer>= -7</initializer>
          <briefdescription>
<para>Operation timed out. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efaf00ae4b8772fda64263ae6e4d6569af0" prot="public">
          <name>LIBUSB_ERROR_OVERFLOW</name>
          <initializer>= -8</initializer>
          <briefdescription>
<para>Overflow. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa1406e98370900156484f5fe609270837" prot="public">
          <name>LIBUSB_ERROR_PIPE</name>
          <initializer>= -9</initializer>
          <briefdescription>
<para>Pipe error. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa39c9284a18fb3277696d84d65f50dbea" prot="public">
          <name>LIBUSB_ERROR_INTERRUPTED</name>
          <initializer>= -10</initializer>
          <briefdescription>
<para>System call interrupted (perhaps due to signal) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efaff885c8ef4522f22f6673059c7b9edec" prot="public">
          <name>LIBUSB_ERROR_NO_MEM</name>
          <initializer>= -11</initializer>
          <briefdescription>
<para>Insufficient memory. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa01b43115484f435627be755d5dc9509b" prot="public">
          <name>LIBUSB_ERROR_NOT_SUPPORTED</name>
          <initializer>= -12</initializer>
          <briefdescription>
<para>Operation not supported or unimplemented on this platform. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggab2323aa0f04bc22038e7e1740b2f29efa9705eb232d1a5e249926d4e76599672e" prot="public">
          <name>LIBUSB_ERROR_OTHER</name>
          <initializer>= -99</initializer>
          <briefdescription>
<para>Other error. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Error codes. </para>        </briefdescription>
        <detaileddescription>
<para>Most libusb functions return 0 on success or one of these codes on failure. You can call <ref refid="group__libusb__misc_1gacf319b823a1a1a25cc934d80db2f28c7" kindref="member">libusb_error_name()</ref> to retrieve a string representation of an error code or <ref refid="group__libusb__misc_1gab977153d03d867a8b228a5921edaf457" kindref="member">libusb_strerror()</ref> to get an end-user suitable description of an error code. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1054" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1054" bodyend="1099"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__asyncio_1ga9fcb2aa23d342060ebda1d0cf7478856" prot="public" static="no">
        <name>libusb_transfer_status</name>
        <enumvalue id="group__libusb__asyncio_1gga9fcb2aa23d342060ebda1d0cf7478856a4595f6532aab12352a58a0fd4ce48363" prot="public">
          <name>LIBUSB_TRANSFER_COMPLETED</name>
          <briefdescription>
<para>Transfer completed without error. </para>          </briefdescription>
          <detaileddescription>
<para>Note that this does not indicate that the entire amount of requested data was transferred. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__asyncio_1gga9fcb2aa23d342060ebda1d0cf7478856aa8852ed719d03c2a3cc6f0312d919398" prot="public">
          <name>LIBUSB_TRANSFER_ERROR</name>
          <briefdescription>
<para>Transfer failed. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__asyncio_1gga9fcb2aa23d342060ebda1d0cf7478856ac2b7626d7b51cb980f83933b6ada1ddf" prot="public">
          <name>LIBUSB_TRANSFER_TIMED_OUT</name>
          <briefdescription>
<para>Transfer timed out. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__asyncio_1gga9fcb2aa23d342060ebda1d0cf7478856a8af1f19e46cccafdcf3feadce47e880b" prot="public">
          <name>LIBUSB_TRANSFER_CANCELLED</name>
          <briefdescription>
<para>Transfer was cancelled. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__asyncio_1gga9fcb2aa23d342060ebda1d0cf7478856a23cdfd929f5fe82cca9654f8075eeebb" prot="public">
          <name>LIBUSB_TRANSFER_STALL</name>
          <briefdescription>
<para>For bulk/interrupt endpoints: halt condition detected (endpoint stalled). </para>          </briefdescription>
          <detaileddescription>
<para>For control endpoints: control request not supported. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__asyncio_1gga9fcb2aa23d342060ebda1d0cf7478856ab7dcb24f313ace407e0c070d6b2c5f13" prot="public">
          <name>LIBUSB_TRANSFER_NO_DEVICE</name>
          <briefdescription>
<para>Device was disconnected. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__asyncio_1gga9fcb2aa23d342060ebda1d0cf7478856ab1b9cbcb1de27a8fbeceb3427fb2fb14" prot="public">
          <name>LIBUSB_TRANSFER_OVERFLOW</name>
          <briefdescription>
<para>Device sent more data than requested. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Transfer status codes. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1106" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1106" bodyend="1132"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__asyncio_1ga1fb47dd0f7c209b60a3609ff0c03d56d" prot="public" static="no">
        <name>libusb_transfer_flags</name>
        <enumvalue id="group__libusb__asyncio_1gga1fb47dd0f7c209b60a3609ff0c03d56dae4c0697c266819c51c1734b3456e7276" prot="public">
          <name>LIBUSB_TRANSFER_SHORT_NOT_OK</name>
          <initializer>= 1&lt;&lt;0</initializer>
          <briefdescription>
<para>Report short frames as errors. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__asyncio_1gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86" prot="public">
          <name>LIBUSB_TRANSFER_FREE_BUFFER</name>
          <initializer>= 1&lt;&lt;1</initializer>
          <briefdescription>
<para>Automatically free() transfer buffer during <ref refid="group__libusb__asyncio_1ga6ab8b2cff4de9091298a06b2f4b86cd6" kindref="member">libusb_free_transfer()</ref>. </para>          </briefdescription>
          <detaileddescription>
<para>Note that buffers allocated with <ref refid="group__libusb__asyncio_1ga47c492e750197f1a28874c7a0dee40e3" kindref="member">libusb_dev_mem_alloc()</ref> should not be attempted freed in this way, since free() is not an appropriate way to release such memory. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__asyncio_1gga1fb47dd0f7c209b60a3609ff0c03d56dacf3f064997b283a14097c9f4d6f8ccc1" prot="public">
          <name>LIBUSB_TRANSFER_FREE_TRANSFER</name>
          <initializer>= 1&lt;&lt;2</initializer>
          <briefdescription>
<para>Automatically call <ref refid="group__libusb__asyncio_1ga6ab8b2cff4de9091298a06b2f4b86cd6" kindref="member">libusb_free_transfer()</ref> after callback returns. </para>          </briefdescription>
          <detaileddescription>
<para>If this flag is set, it is illegal to call <ref refid="group__libusb__asyncio_1ga6ab8b2cff4de9091298a06b2f4b86cd6" kindref="member">libusb_free_transfer()</ref> from your transfer callback, as this will result in a double-free when this flag is acted upon. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__asyncio_1gga1fb47dd0f7c209b60a3609ff0c03d56da26b66334b6ec0537c49841ca623d901f" prot="public">
          <name>LIBUSB_TRANSFER_ADD_ZERO_PACKET</name>
          <initializer>= 1 &lt;&lt; 3</initializer>
          <briefdescription>
<para>Terminate transfers that are a multiple of the endpoint&apos;s wMaxPacketSize with an extra zero length packet. </para>          </briefdescription>
          <detaileddescription>
<para>This is useful when a device protocol mandates that each logical request is terminated by an incomplete packet (i.e. the logical requests are not separated by other means).</para><para>This flag only affects host-to-device transfers to bulk and interrupt endpoints. In other situations, it is ignored.</para><para>This flag only affects transfers with a length that is a multiple of the endpoint&apos;s wMaxPacketSize. On transfers of other lengths, this flag has no effect. Therefore, if you are working with a device that needs a ZLP whenever the end of the logical request falls on a packet boundary, then it is sensible to set this flag on <emphasis>every</emphasis> transfer (you do not have to worry about only setting it on transfers that end on the boundary).</para><para>This flag is currently only supported on Linux. On other systems, <ref refid="group__libusb__asyncio_1gabb0932601f2c7dad2fee4b27962848ce" kindref="member">libusb_submit_transfer()</ref> will return LIBUSB_ERROR_NOT_SUPPORTED for every transfer where this flag is set.</para><para>Available since libusb-1.0.9. </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para><ref refid="structlibusb__transfer_1ae26c063df30c2e29835212aad98c6e06" kindref="member">libusb_transfer.flags</ref> values </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1136" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1136" bodyend="1176"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__misc_1gaab1b3fa0728c06fafbee897795889bd5" prot="public" static="no">
        <name>libusb_capability</name>
        <enumvalue id="group__libusb__misc_1ggaab1b3fa0728c06fafbee897795889bd5a24b79436d4bd088d169f9d1edb4b9649" prot="public">
          <name>LIBUSB_CAP_HAS_CAPABILITY</name>
          <initializer>= 0x0000</initializer>
          <briefdescription>
<para>The <ref refid="group__libusb__misc_1ga9b8e324d28c624cd0b8e7ba21607b8db" kindref="member">libusb_has_capability()</ref> API is available. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggaab1b3fa0728c06fafbee897795889bd5a8b1bbccc648a6677cb9030a6ba827438" prot="public">
          <name>LIBUSB_CAP_HAS_HOTPLUG</name>
          <initializer>= 0x0001</initializer>
          <briefdescription>
<para>Hotplug support is available on this platform. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggaab1b3fa0728c06fafbee897795889bd5aa74726ef0af0e42d2d56532f82e873a5" prot="public">
          <name>LIBUSB_CAP_HAS_HID_ACCESS</name>
          <initializer>= 0x0100</initializer>
          <briefdescription>
<para>The library can access HID devices without requiring user intervention. </para>          </briefdescription>
          <detaileddescription>
<para>Note that before being able to actually access an HID device, you may still have to call additional libusb functions such as <ref refid="group__libusb__dev_1ga5e0cc1d666097e915748593effdc634a" kindref="member">libusb_detach_kernel_driver()</ref>. </para>          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__misc_1ggaab1b3fa0728c06fafbee897795889bd5ad15a06b1aede635004f08bdc0fe561cc" prot="public">
          <name>LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER</name>
          <initializer>= 0x0101</initializer>
          <briefdescription>
<para>The library supports detaching of the default USB driver, using <ref refid="group__libusb__dev_1ga5e0cc1d666097e915748593effdc634a" kindref="member">libusb_detach_kernel_driver()</ref>, if one is set by the OS kernel. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Capabilities supported by an instance of libusb on the current running platform. </para>        </briefdescription>
        <detaileddescription>
<para>Test if the loaded library supports a given capability by calling <ref refid="group__libusb__misc_1ga9b8e324d28c624cd0b8e7ba21607b8db" kindref="member">libusb_has_capability()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1273" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1273" bodyend="1286"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__lib_1ga2d6144203f0fc6d373677f6e2e89d2d2" prot="public" static="no">
        <name>libusb_log_level</name>
        <enumvalue id="group__libusb__lib_1gga2d6144203f0fc6d373677f6e2e89d2d2af431dbe84c85599526cc0103f8178270" prot="public">
          <name>LIBUSB_LOG_LEVEL_NONE</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__lib_1gga2d6144203f0fc6d373677f6e2e89d2d2ace959b4b99f6c460dfa929b6152e49a8" prot="public">
          <name>LIBUSB_LOG_LEVEL_ERROR</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__lib_1gga2d6144203f0fc6d373677f6e2e89d2d2a1d141f7a981d9fcd4bc12e41a1a14e78" prot="public">
          <name>LIBUSB_LOG_LEVEL_WARNING</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__lib_1gga2d6144203f0fc6d373677f6e2e89d2d2ab942d780c83ba4f30b9dd2e338002a07" prot="public">
          <name>LIBUSB_LOG_LEVEL_INFO</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__lib_1gga2d6144203f0fc6d373677f6e2e89d2d2afabee6826e913933f5d6fe4040bd7b9c" prot="public">
          <name>LIBUSB_LOG_LEVEL_DEBUG</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Log message levels. </para>        </briefdescription>
        <detaileddescription>
<para><itemizedlist>
<listitem><para>LIBUSB_LOG_LEVEL_NONE (0) : no messages ever printed by the library (default)</para></listitem><listitem><para>LIBUSB_LOG_LEVEL_ERROR (1) : error messages are printed to stderr</para></listitem><listitem><para>LIBUSB_LOG_LEVEL_WARNING (2) : warning and error messages are printed to stderr</para></listitem><listitem><para>LIBUSB_LOG_LEVEL_INFO (3) : informational messages are printed to stdout, warning and error messages are printed to stderr</para></listitem><listitem><para>LIBUSB_LOG_LEVEL_DEBUG (4) : debug and informational messages are printed to stdout, warnings and errors to stderr </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1298" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1298" bodyend="1304"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__hotplug_1ga95ce2ec85dec177854c423cea2853c52" prot="public" static="no">
        <name>libusb_hotplug_flag</name>
        <enumvalue id="group__libusb__hotplug_1gga95ce2ec85dec177854c423cea2853c52a2522bd2268865687cbfe8e7e0d8e4c10" prot="public">
          <name>LIBUSB_HOTPLUG_NO_FLAGS</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>Default value when not using any flags. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__hotplug_1gga95ce2ec85dec177854c423cea2853c52a01a1c0c9f4e6852cb6df713f2e8a7f6b" prot="public">
          <name>LIBUSB_HOTPLUG_ENUMERATE</name>
          <initializer>= 1&lt;&lt;0</initializer>
          <briefdescription>
<para>Arm the callback and fire it for all matching currently attached devices. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Since version 1.0.16, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000102. </para>        </briefdescription>
        <detaileddescription>
<para>Flags for hotplug events </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1893" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1893" bodyend="1899"/>
      </memberdef>
      <memberdef kind="enum" id="group__libusb__hotplug_1ga556d598ca379618a41bbec3597f55dcf" prot="public" static="no">
        <name>libusb_hotplug_event</name>
        <enumvalue id="group__libusb__hotplug_1gga556d598ca379618a41bbec3597f55dcfac012270cba6e08dafe7e3bec204dffd6" prot="public">
          <name>LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED</name>
          <initializer>= 0x01</initializer>
          <briefdescription>
<para>A device has been plugged in and is ready to use. </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="group__libusb__hotplug_1gga556d598ca379618a41bbec3597f55dcfac8234e02b673893ed549329ef3180a27" prot="public">
          <name>LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT</name>
          <initializer>= 0x02</initializer>
          <briefdescription>
<para>A device has left and is no longer available. </para>          </briefdescription>
          <detaileddescription>
<para>It is the user&apos;s responsibility to call libusb_close on any handle associated with a disconnected device. It is safe to call libusb_get_device_descriptor on a device that has left </para>          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>Since version 1.0.16, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000102. </para>        </briefdescription>
        <detaileddescription>
<para>Hotplug events </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1906" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1906" bodyend="1914"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" prot="public" static="no">
        <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref></type>
        <definition>typedef struct libusb_context libusb_context</definition>
        <argsstring></argsstring>
        <name>libusb_context</name>
        <briefdescription>
<para>Structure representing a libusb session. </para>        </briefdescription>
        <detaileddescription>
<para>The concept of individual libusb sessions allows for your program to use two libraries (or dynamically load two modules) which both independently use libusb. This will prevent interference between the individual libusb users - for example <ref refid="group__libusb__lib_1ga5f8376b7a863a5a8d5b8824feb8a427a" kindref="member">libusb_set_debug()</ref> will not affect the other user of the library, and <ref refid="group__libusb__lib_1ga86532f222d4f1332a5f8f5eef9a92da9" kindref="member">libusb_exit()</ref> will not destroy resources that the other user is still using.</para><para>Sessions are created by <ref refid="group__libusb__lib_1ga9517c37281bba0b51cc62eba728be48b" kindref="member">libusb_init()</ref> and destroyed through <ref refid="group__libusb__lib_1ga86532f222d4f1332a5f8f5eef9a92da9" kindref="member">libusb_exit()</ref>. If your application is guaranteed to only ever include a single libusb user (i.e. you), you do not have to worry about contexts: pass NULL in every function call where a context is required. The default context will be used.</para><para>For more information, see <ref refid="libusb_contexts" kindref="compound">Contexts</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="161" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="942" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" prot="public" static="no">
        <type>struct <ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref></type>
        <definition>typedef struct libusb_device libusb_device</definition>
        <argsstring></argsstring>
        <name>libusb_device</name>
        <briefdescription>
<para>Structure representing a USB device detected on the system. </para>        </briefdescription>
        <detaileddescription>
<para>This is an opaque type for which you are only ever provided with a pointer, usually originating from <ref refid="group__libusb__dev_1gac0fe4b65914c5ed036e6cbec61cb0b97" kindref="member">libusb_get_device_list()</ref>.</para><para>Certain operations can be performed on a device, but in order to do any I/O you will have to first obtain a device handle using <ref refid="group__libusb__dev_1ga3f184a8be4488a767b2e0ae07e76d1b0" kindref="member">libusb_open()</ref>.</para><para>Devices are reference counted with <ref refid="group__libusb__dev_1gaabaa4193adcabba1789cc1165ac41a03" kindref="member">libusb_ref_device()</ref> and <ref refid="group__libusb__dev_1ga3cc62e6a191b7a9f213e62b81ec30f4d" kindref="member">libusb_unref_device()</ref>, and are freed when the reference count reaches 0. New devices presented by <ref refid="group__libusb__dev_1gac0fe4b65914c5ed036e6cbec61cb0b97" kindref="member">libusb_get_device_list()</ref> have a reference count of 1, and <ref refid="group__libusb__dev_1gad3b8561d064bb3e1b8851ddeed3cd7d6" kindref="member">libusb_free_device_list()</ref> can optionally decrease the reference count on all devices in the list. <ref refid="group__libusb__dev_1ga3f184a8be4488a767b2e0ae07e76d1b0" kindref="member">libusb_open()</ref> adds another reference which is later destroyed by <ref refid="group__libusb__dev_1ga779bc4f1316bdb0ac383bddbd538620e" kindref="member">libusb_close()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="161" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="959" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" prot="public" static="no">
        <type>struct <ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref></type>
        <definition>typedef struct libusb_device_handle libusb_device_handle</definition>
        <argsstring></argsstring>
        <name>libusb_device_handle</name>
        <briefdescription>
<para>Structure representing a handle on a USB device. </para>        </briefdescription>
        <detaileddescription>
<para>This is an opaque type for which you are only ever provided with a pointer, usually originating from <ref refid="group__libusb__dev_1ga3f184a8be4488a767b2e0ae07e76d1b0" kindref="member">libusb_open()</ref>.</para><para>A device handle is used to perform I/O and other operations. When finished with a device handle, you should call <ref refid="group__libusb__dev_1ga779bc4f1316bdb0ac383bddbd538620e" kindref="member">libusb_close()</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="161" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="970" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__libusb__asyncio_1gac74874519794cd7aa40c0814702b0c88" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void( * libusb_transfer_cb_fn) (struct libusb_transfer *transfer)</definition>
        <argsstring>)(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_transfer_cb_fn</name>
        <briefdescription>
<para>Asynchronous transfer callback function type. </para>        </briefdescription>
        <detaileddescription>
<para>When submitting asynchronous transfers, you pass a pointer to a callback function of this type via the <ref refid="structlibusb__transfer_1a69c6df011ec23ff3e481cc98bfff0623" kindref="member">callback</ref> member of the <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> structure. libusb will call this function later, when the transfer has completed or failed. See <ref refid="group__libusb__asyncio" kindref="compound">Asynchronous device I/O</ref> for more information. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> struct the callback function is being notified about. </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1202" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1202" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__libusb__poll_1ga2962a11284b09a3f18936d8f73a43804" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void( * libusb_pollfd_added_cb) (int fd, short events, void *user_data)</definition>
        <argsstring>)(int fd, short events, void *user_data)</argsstring>
        <name>libusb_pollfd_added_cb</name>
        <briefdescription>
<para>Callback function, invoked when a new file descriptor should be added to the set of file descriptors monitored for events. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fd</parametername>
</parameternamelist>
<parameterdescription>
<para>the new file descriptor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>events</parametername>
</parameternamelist>
<parameterdescription>
<para>events to monitor for, see <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> for a description </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>User data pointer specified in <ref refid="group__libusb__poll_1ga1b7b2deb193f2e9ffda5e727361d7e67" kindref="member">libusb_set_pollfd_notifiers()</ref> call </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="group__libusb__poll_1ga1b7b2deb193f2e9ffda5e727361d7e67" kindref="member">libusb_set_pollfd_notifiers()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1853" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1853" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__libusb__poll_1ga32aa803f54cfb5bfe8b41747e6b62af5" prot="public" static="no">
        <type>void(*</type>
        <definition>typedef void( * libusb_pollfd_removed_cb) (int fd, void *user_data)</definition>
        <argsstring>)(int fd, void *user_data)</argsstring>
        <name>libusb_pollfd_removed_cb</name>
        <briefdescription>
<para>Callback function, invoked when a file descriptor should be removed from the set of file descriptors being monitored for events. </para>        </briefdescription>
        <detaileddescription>
<para>After returning from this callback, do not use that file descriptor again. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fd</parametername>
</parameternamelist>
<parameterdescription>
<para>the file descriptor to stop monitoring </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>User data pointer specified in <ref refid="group__libusb__poll_1ga1b7b2deb193f2e9ffda5e727361d7e67" kindref="member">libusb_set_pollfd_notifiers()</ref> call </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="group__libusb__poll_1ga1b7b2deb193f2e9ffda5e727361d7e67" kindref="member">libusb_set_pollfd_notifiers()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1865" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1865" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__libusb__hotplug_1ga4868157346bbf2c70b6af0cb0a6c0094" prot="public" static="no">
        <type>int</type>
        <definition>typedef int libusb_hotplug_callback_handle</definition>
        <argsstring></argsstring>
        <name>libusb_hotplug_callback_handle</name>
        <briefdescription>
<para>Callback handle. </para>        </briefdescription>
        <detaileddescription>
<para>Callbacks handles are generated by <ref refid="group__libusb__hotplug_1ga00e0c69ddf1fb1b6774dc918192e8dc7" kindref="member">libusb_hotplug_register_callback()</ref> and can be used to deregister callbacks. Callback handles are unique per libusb_context and it is safe to call <ref refid="group__libusb__hotplug_1ga8110f57eab2064375934f1449b2602bc" kindref="member">libusb_hotplug_deregister_callback()</ref> on an already deregisted callback.</para><para>Since version 1.0.16, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000102</para><para>For more information, see <ref refid="libusb_hotplug" kindref="compound">Device hotplug event notification</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1886" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1886" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="group__libusb__hotplug_1ga3d45c3fdf4d2e47a007fe2d9463b3f7f" prot="public" static="no">
        <type>int(*</type>
        <definition>typedef int( * libusb_hotplug_callback_fn) (libusb_context *ctx, libusb_device *device, libusb_hotplug_event event, void *user_data)</definition>
        <argsstring>)(libusb_context *ctx, libusb_device *device, libusb_hotplug_event event, void *user_data)</argsstring>
        <name>libusb_hotplug_callback_fn</name>
        <briefdescription>
<para>Hotplug callback function type. </para>        </briefdescription>
        <detaileddescription>
<para>When requesting hotplug event notifications, you pass a pointer to a callback function of this type.</para><para>This callback may be called by an internal event thread and as such it is recommended the callback do minimal processing before returning.</para><para>libusb will call this function later, when a matching event had happened on a matching device. See <ref refid="libusb_hotplug" kindref="compound">Device hotplug event notification</ref> for more information.</para><para>It is safe to call either <ref refid="group__libusb__hotplug_1ga00e0c69ddf1fb1b6774dc918192e8dc7" kindref="member">libusb_hotplug_register_callback()</ref> or <ref refid="group__libusb__hotplug_1ga8110f57eab2064375934f1449b2602bc" kindref="member">libusb_hotplug_deregister_callback()</ref> from within a callback function.</para><para>Since version 1.0.16, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000102</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>context of this notification </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>device</parametername>
</parameternamelist>
<parameterdescription>
<para>libusb_device this event occurred on </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>event</parametername>
</parameternamelist>
<parameterdescription>
<para>event that occurred </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>user data provided when this callback was registered </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>bool whether this callback is finished processing events. returning 1 will cause this callback to be deregistered </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1942" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1942" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="group__libusb__misc_1gae3b1162b8e69b49bbf74dcbbdeeadbda" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>uint16_t</type>
        <definition>static uint16_t libusb_cpu_to_le16</definition>
        <argsstring>(const uint16_t x)</argsstring>
        <name>libusb_cpu_to_le16</name>
        <param>
          <type>const uint16_t</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>Convert a 16-bit value from host-endian to little-endian format. </para>        </briefdescription>
        <detaileddescription>
<para>On little endian systems, this function does nothing. On big endian systems, the bytes are swapped. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>the host-endian value to convert </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the value in little-endian byte order </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="161" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="161" bodyend="170"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__lib_1ga9517c37281bba0b51cc62eba728be48b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_init</definition>
        <argsstring>(libusb_context **ctx)</argsstring>
        <name>libusb_init</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> **</type>
          <declname>ctx</declname>
          <defname>context</defname>
        </param>
        <briefdescription>
<para>Initialize libusb. </para>        </briefdescription>
        <detaileddescription>
<para>This function must be called before calling any other libusb function.</para><para>If you do not provide an output location for a context pointer, a default context will be created. If there was already a default context, it will be reused (and nothing will be initialized/reinitialized).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>context</parametername>
</parameternamelist>
<parameterdescription>
<para>Optional output location for context pointer. Only valid on return code 0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure </para></simplesect>
<simplesect kind="see"><para>libusb_contexts </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1306" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="2062" bodyend="2169"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__lib_1ga86532f222d4f1332a5f8f5eef9a92da9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_exit</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_exit</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Deinitialize libusb. </para>        </briefdescription>
        <detaileddescription>
<para>Should be called after closing all open devices and before your application terminates. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to deinitialize, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1307" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="2176" bodyend="2240"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__lib_1ga5f8376b7a863a5a8d5b8824feb8a427a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_set_debug</definition>
        <argsstring>(libusb_context *ctx, int level)</argsstring>
        <name>libusb_set_debug</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>int</type>
          <declname>level</declname>
        </param>
        <briefdescription>
<para>Set log message verbosity. </para>        </briefdescription>
        <detaileddescription>
<para>The default level is LIBUSB_LOG_LEVEL_NONE, which means no messages are ever printed. If you choose to increase the message verbosity level, ensure that your application does not close the stdout/stderr file descriptors.</para><para>You are advised to use level LIBUSB_LOG_LEVEL_WARNING. libusb is conservative with its message logging and most of the time, will only log messages that explain error conditions and other oddities. This will help you debug your software.</para><para>If the LIBUSB_DEBUG environment variable was set when libusb was initialized, this function does nothing: the message verbosity is fixed to the value in the environment variable.</para><para>If libusb was compiled without any message logging, this function does nothing: you&apos;ll never get any messages.</para><para>If libusb was compiled with verbose debug message logging, this function does nothing: you&apos;ll always get messages from all levels.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>level</parametername>
</parameternamelist>
<parameterdescription>
<para>debug level to set </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1308" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="2042" bodyend="2047"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__misc_1ga61d07b01404fdea080cd16c1ed8be93d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const struct <ref refid="structlibusb__version" kindref="compound">libusb_version</ref> *</type>
        <definition>const struct libusb_version* libusb_get_version</definition>
        <argsstring>(void)</argsstring>
        <name>libusb_get_version</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Returns a pointer to const struct <ref refid="structlibusb__version" kindref="compound">libusb_version</ref> with the version (major, minor, micro, nano and rc) of the running library. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1309" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="2529" bodyend="2532"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__misc_1ga9b8e324d28c624cd0b8e7ba21607b8db" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_has_capability</definition>
        <argsstring>(uint32_t capability)</argsstring>
        <name>libusb_has_capability</name>
        <param>
          <type>uint32_t</type>
          <declname>capability</declname>
        </param>
        <briefdescription>
<para>Check at runtime if the loaded library has a given capability. </para>        </briefdescription>
        <detaileddescription>
<para>This call should be performed after <ref refid="group__libusb__lib_1ga9517c37281bba0b51cc62eba728be48b" kindref="member">libusb_init()</ref>, to ensure the backend has updated its capability set.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>capability</parametername>
</parameternamelist>
<parameterdescription>
<para>the <ref refid="group__libusb__misc_1gaab1b3fa0728c06fafbee897795889bd5" kindref="member">libusb_capability</ref> to check for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>nonzero if the running library has the capability, 0 otherwise </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1310" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="2250" bodyend="2263"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__misc_1gacf319b823a1a1a25cc934d80db2f28c7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* libusb_error_name</definition>
        <argsstring>(int errcode)</argsstring>
        <name>libusb_error_name</name>
        <param>
          <type>int</type>
          <declname>errcode</declname>
          <defname>error_code</defname>
        </param>
        <briefdescription>
<para>Returns a constant NULL-terminated string with the ASCII name of a libusb error or transfer status code. </para>        </briefdescription>
        <detaileddescription>
<para>The caller must not free() the returned string.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>error_code</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="group__libusb__misc_1gab2323aa0f04bc22038e7e1740b2f29ef" kindref="member">libusb_error</ref> or libusb_transfer_status code to return the name of. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The error name, or the string <bold>UNKNOWN</bold> if the value of error_code is not a known error / status code. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1311" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="2474" bodyend="2522"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__misc_1ga0badebde406e5f1874fb72ec6d1b60f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_setlocale</definition>
        <argsstring>(const char *locale)</argsstring>
        <name>libusb_setlocale</name>
        <param>
          <type>const char *</type>
          <declname>locale</declname>
        </param>
        <briefdescription>
<para>Set the language, and only the language, not the encoding! used for translatable libusb messages. </para>        </briefdescription>
        <detaileddescription>
<para>This takes a locale string in the default setlocale format: lang[-region] or lang[_country_region][.codeset]. Only the lang part of the string is used, and only 2 letter ISO 639-1 codes are accepted for it, such as &quot;de&quot;. The optional region, country_region or codeset parts are ignored. This means that functions which return translatable strings will NOT honor the specified encoding. All strings returned are encoded as UTF-8 strings.</para><para>If <ref refid="group__libusb__misc_1ga0badebde406e5f1874fb72ec6d1b60f4" kindref="member">libusb_setlocale()</ref> is not called, all messages will be in English.</para><para>The following functions return translatable strings: <ref refid="group__libusb__misc_1gab977153d03d867a8b228a5921edaf457" kindref="member">libusb_strerror()</ref>. Note that the libusb log messages controlled through <ref refid="group__libusb__lib_1ga5f8376b7a863a5a8d5b8824feb8a427a" kindref="member">libusb_set_debug()</ref> are not translated, they are always in English.</para><para>For POSIX UTF-8 environments if you want libusb to follow the standard locale settings, call libusb_setlocale(setlocale(LC_MESSAGES, NULL)), after your app has done its locale setup.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>locale</parametername>
</parameternamelist>
<parameterdescription>
<para>locale-string in the form of lang[_country_region][.codeset] or lang[-region], where lang is a 2 letter ISO 639-1 code </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>LIBUSB_SUCCESS on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_INVALID_PARAM if the locale doesn&apos;t meet the requirements </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the requested language is not supported </para></simplesect>
<simplesect kind="return"><para>a LIBUSB_ERROR code on other errors </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1312" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/strerror.c" bodystart="158" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__misc_1gab977153d03d867a8b228a5921edaf457" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* libusb_strerror</definition>
        <argsstring>(enum libusb_error errcode)</argsstring>
        <name>libusb_strerror</name>
        <param>
          <type>enum <ref refid="group__libusb__misc_1gab2323aa0f04bc22038e7e1740b2f29ef" kindref="member">libusb_error</ref></type>
          <declname>errcode</declname>
        </param>
        <briefdescription>
<para>Returns a constant string with a short description of the given error code, this description is intended for displaying to the end user and will be in the language set by <ref refid="group__libusb__misc_1ga0badebde406e5f1874fb72ec6d1b60f4" kindref="member">libusb_setlocale()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>The returned string is encoded in UTF-8.</para><para>The messages always start with a capital letter and end without any dot. The caller must not free() the returned string.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>errcode</parametername>
</parameternamelist>
<parameterdescription>
<para>the error code whose description is desired </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a short description of the error code in UTF-8 encoding </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1313" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/strerror.c" bodystart="192" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gac0fe4b65914c5ed036e6cbec61cb0b97" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>ssize_t</type>
        <definition>ssize_t libusb_get_device_list</definition>
        <argsstring>(libusb_context *ctx, libusb_device ***list)</argsstring>
        <name>libusb_get_device_list</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> ***</type>
          <declname>list</declname>
        </param>
        <briefdescription>
<para>Returns a list of USB devices currently attached to the system. </para>        </briefdescription>
        <detaileddescription>
<para>This is your entry point into finding a USB device to operate.</para><para>You are expected to unreference all the devices when you are done with them, and then free the list with <ref refid="group__libusb__dev_1gad3b8561d064bb3e1b8851ddeed3cd7d6" kindref="member">libusb_free_device_list()</ref>. Note that <ref refid="group__libusb__dev_1gad3b8561d064bb3e1b8851ddeed3cd7d6" kindref="member">libusb_free_device_list()</ref> can unref all the devices for you. Be careful not to unreference a device you are about to open until after you have opened it.</para><para>This return value of this function indicates the number of devices in the resultant list. The list is actually one element larger, as it is NULL-terminated.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>list</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for a list of devices. Must be later freed with <ref refid="group__libusb__dev_1gad3b8561d064bb3e1b8851ddeed3cd7d6" kindref="member">libusb_free_device_list()</ref>. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the number of devices in the outputted list, or any <ref refid="group__libusb__misc_1gab2323aa0f04bc22038e7e1740b2f29ef" kindref="member">libusb_error</ref> according to errors encountered by the backend. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1315" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="810" bodyend="869"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gad3b8561d064bb3e1b8851ddeed3cd7d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_device_list</definition>
        <argsstring>(libusb_device **list, int unref_devices)</argsstring>
        <name>libusb_free_device_list</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> **</type>
          <declname>list</declname>
        </param>
        <param>
          <type>int</type>
          <declname>unref_devices</declname>
        </param>
        <briefdescription>
<para>Frees a list of devices previously discovered using <ref refid="group__libusb__dev_1gac0fe4b65914c5ed036e6cbec61cb0b97" kindref="member">libusb_get_device_list()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>If the unref_devices parameter is set, the reference count of each device in the list is decremented by 1. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>list</parametername>
</parameternamelist>
<parameterdescription>
<para>the list to free </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>unref_devices</parametername>
</parameternamelist>
<parameterdescription>
<para>whether to unref the devices in the list </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1317" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="878" bodyend="892"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gaabaa4193adcabba1789cc1165ac41a03" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
        <definition>libusb_device* libusb_ref_device</definition>
        <argsstring>(libusb_device *dev)</argsstring>
        <name>libusb_ref_device</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <briefdescription>
<para>Increment the reference count of a device. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>the device to reference </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the same device </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1319" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1141" bodyend="1147"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga3cc62e6a191b7a9f213e62b81ec30f4d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_unref_device</definition>
        <argsstring>(libusb_device *dev)</argsstring>
        <name>libusb_unref_device</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <briefdescription>
<para>Decrement the reference count of a device. </para>        </briefdescription>
        <detaileddescription>
<para>If the decrement operation causes the reference count to reach zero, the device shall be destroyed. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>the device to unreference </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1320" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1154" bodyend="1181"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gae921014b888b105471a31d54c77c1c4d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_configuration</definition>
        <argsstring>(libusb_device_handle *dev, int *config)</argsstring>
        <name>libusb_get_configuration</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev</declname>
          <defname>dev_handle</defname>
        </param>
        <param>
          <type>int *</type>
          <declname>config</declname>
        </param>
        <briefdescription>
<para>Determine the bConfigurationValue of the currently active configuration. </para>        </briefdescription>
        <detaileddescription>
<para>You could formulate your own control request to obtain this information, but this function has the advantage that it may be able to retrieve the information from operating system caches (no I/O involved).</para><para>If the OS does not cache this information, then this function will block while a control transfer is submitted to retrieve the information.</para><para>This function will return a value of 0 in the <computeroutput>config</computeroutput> output parameter if the device is in unconfigured state.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>config</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the bConfigurationValue of the active configuration (only valid for return code 0) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1322" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1488" bodyend="1517"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga5e9ab08d490a7704cf3a9b0439f16f00" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_device_descriptor</definition>
        <argsstring>(libusb_device *dev, struct libusb_device_descriptor *desc)</argsstring>
        <name>libusb_get_device_descriptor</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__device__descriptor" kindref="compound">libusb_device_descriptor</ref> *</type>
          <declname>desc</declname>
        </param>
        <briefdescription>
<para>Get the USB device descriptor for a given device. </para>        </briefdescription>
        <detaileddescription>
<para>This is a non-blocking function; the device descriptor is cached in memory.</para><para>Note since libusb-1.0.16, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000102, this function always succeeds.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>the device </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>desc</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the descriptor data </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success or a LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1324" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="543" bodyend="550"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga425885149172b53b3975a07629c8dab3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_active_config_descriptor</definition>
        <argsstring>(libusb_device *dev, struct libusb_config_descriptor **config)</argsstring>
        <name>libusb_get_active_config_descriptor</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__config__descriptor" kindref="compound">libusb_config_descriptor</ref> **</type>
          <declname>config</declname>
        </param>
        <briefdescription>
<para>Get the USB configuration descriptor for the currently active configuration. </para>        </briefdescription>
        <detaileddescription>
<para>This is a non-blocking function which does not involve any requests being sent to the device.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>config</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the USB configuration descriptor. Only valid if 0 was returned. Must be freed with <ref refid="group__libusb__desc_1ga18d2b08a065857ff7ae4f3f719c115cc" kindref="member">libusb_free_config_descriptor()</ref> after use. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the device is in unconfigured state </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on error </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__desc_1gaa635d9aec77de4895dd0896ccf001532" kindref="member">libusb_get_config_descriptor</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1326" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="566" bodyend="597"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1gaa635d9aec77de4895dd0896ccf001532" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_config_descriptor</definition>
        <argsstring>(libusb_device *dev, uint8_t config_index, struct libusb_config_descriptor **config)</argsstring>
        <name>libusb_get_config_descriptor</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>config_index</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__config__descriptor" kindref="compound">libusb_config_descriptor</ref> **</type>
          <declname>config</declname>
        </param>
        <briefdescription>
<para>Get a USB configuration descriptor based on its index. </para>        </briefdescription>
        <detaileddescription>
<para>This is a non-blocking function which does not involve any requests being sent to the device.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>config_index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index of the configuration you wish to retrieve </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>config</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the USB configuration descriptor. Only valid if 0 was returned. Must be freed with <ref refid="group__libusb__desc_1ga18d2b08a065857ff7ae4f3f719c115cc" kindref="member">libusb_free_config_descriptor()</ref> after use. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the configuration does not exist </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on error </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__desc_1ga425885149172b53b3975a07629c8dab3" kindref="member">libusb_get_active_config_descriptor()</ref> </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__desc_1ga3e7bffc5d08404c4d6491e73b967bf67" kindref="member">libusb_get_config_descriptor_by_value()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1328" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="615" bodyend="650"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga3e7bffc5d08404c4d6491e73b967bf67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_config_descriptor_by_value</definition>
        <argsstring>(libusb_device *dev, uint8_t bConfigurationValue, struct libusb_config_descriptor **config)</argsstring>
        <name>libusb_get_config_descriptor_by_value</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>bConfigurationValue</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__config__descriptor" kindref="compound">libusb_config_descriptor</ref> **</type>
          <declname>config</declname>
        </param>
        <briefdescription>
<para>Get a USB configuration descriptor with a specific bConfigurationValue. </para>        </briefdescription>
        <detaileddescription>
<para>This is a non-blocking function which does not involve any requests being sent to the device.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bConfigurationValue</parametername>
</parameternamelist>
<parameterdescription>
<para>the bConfigurationValue of the configuration you wish to retrieve </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>config</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the USB configuration descriptor. Only valid if 0 was returned. Must be freed with <ref refid="group__libusb__desc_1ga18d2b08a065857ff7ae4f3f719c115cc" kindref="member">libusb_free_config_descriptor()</ref> after use. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the configuration does not exist </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on error </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__desc_1ga425885149172b53b3975a07629c8dab3" kindref="member">libusb_get_active_config_descriptor()</ref> </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__desc_1gaa635d9aec77de4895dd0896ccf001532" kindref="member">libusb_get_config_descriptor()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1330" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="699" bodyend="720"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga18d2b08a065857ff7ae4f3f719c115cc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_config_descriptor</definition>
        <argsstring>(struct libusb_config_descriptor *config)</argsstring>
        <name>libusb_free_config_descriptor</name>
        <param>
          <type>struct <ref refid="structlibusb__config__descriptor" kindref="compound">libusb_config_descriptor</ref> *</type>
          <declname>config</declname>
        </param>
        <briefdescription>
<para>Free a configuration descriptor obtained from <ref refid="group__libusb__desc_1ga425885149172b53b3975a07629c8dab3" kindref="member">libusb_get_active_config_descriptor()</ref> or <ref refid="group__libusb__desc_1gaa635d9aec77de4895dd0896ccf001532" kindref="member">libusb_get_config_descriptor()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>It is safe to call this function with a NULL config parameter, in which case the function simply returns.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>config</parametername>
</parameternamelist>
<parameterdescription>
<para>the configuration descriptor to free </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1332" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="730" bodyend="738"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1gade95f9708956c3d45d9969e860fc7241" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_ss_endpoint_companion_descriptor</definition>
        <argsstring>(struct libusb_context *ctx, const struct libusb_endpoint_descriptor *endpoint, struct libusb_ss_endpoint_companion_descriptor **ep_comp)</argsstring>
        <name>libusb_get_ss_endpoint_companion_descriptor</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>const struct <ref refid="structlibusb__endpoint__descriptor" kindref="compound">libusb_endpoint_descriptor</ref> *</type>
          <declname>endpoint</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__ss__endpoint__companion__descriptor" kindref="compound">libusb_ss_endpoint_companion_descriptor</ref> **</type>
          <declname>ep_comp</declname>
        </param>
        <briefdescription>
<para>Get an endpoints superspeed endpoint companion descriptor (if any) </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>endpoint descriptor from which to get the superspeed endpoint companion descriptor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ep_comp</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the superspeed endpoint companion descriptor. Only valid if 0 was returned. Must be freed with <ref refid="group__libusb__desc_1ga52738e36d2c0e6a0607405d783a2c894" kindref="member">libusb_free_ss_endpoint_companion_descriptor()</ref> after use. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the configuration does not exist </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on error </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1334" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="753" bodyend="788"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga52738e36d2c0e6a0607405d783a2c894" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_ss_endpoint_companion_descriptor</definition>
        <argsstring>(struct libusb_ss_endpoint_companion_descriptor *ep_comp)</argsstring>
        <name>libusb_free_ss_endpoint_companion_descriptor</name>
        <param>
          <type>struct <ref refid="structlibusb__ss__endpoint__companion__descriptor" kindref="compound">libusb_ss_endpoint_companion_descriptor</ref> *</type>
          <declname>ep_comp</declname>
        </param>
        <briefdescription>
<para>Free a superspeed endpoint companion descriptor obtained from <ref refid="group__libusb__desc_1gade95f9708956c3d45d9969e860fc7241" kindref="member">libusb_get_ss_endpoint_companion_descriptor()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>It is safe to call this function with a NULL ep_comp parameter, in which case the function simply returns.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ep_comp</parametername>
</parameternamelist>
<parameterdescription>
<para>the superspeed endpoint companion descriptor to free </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1338" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="798" bodyend="802"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga68fd9576677c12aa397192916dc49a0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_bos_descriptor</definition>
        <argsstring>(libusb_device_handle *dev_handle, struct libusb_bos_descriptor **bos)</argsstring>
        <name>libusb_get_bos_descriptor</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__bos__descriptor" kindref="compound">libusb_bos_descriptor</ref> **</type>
          <declname>bos</declname>
        </param>
        <briefdescription>
<para>Get a Binary Object Store (BOS) descriptor This is a BLOCKING function, which will send requests to the device. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>the handle of an open libusb device </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bos</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the BOS descriptor. Only valid if 0 was returned. Must be freed with <ref refid="group__libusb__desc_1gac9bff9809a7b8663190dda0455998767" kindref="member">libusb_free_bos_descriptor()</ref> after use. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the device doesn&apos;t have a BOS descriptor </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on error </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1340" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="894" bodyend="934"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1gac9bff9809a7b8663190dda0455998767" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_bos_descriptor</definition>
        <argsstring>(struct libusb_bos_descriptor *bos)</argsstring>
        <name>libusb_free_bos_descriptor</name>
        <param>
          <type>struct <ref refid="structlibusb__bos__descriptor" kindref="compound">libusb_bos_descriptor</ref> *</type>
          <declname>bos</declname>
        </param>
        <briefdescription>
<para>Free a BOS descriptor obtained from <ref refid="group__libusb__desc_1ga68fd9576677c12aa397192916dc49a0b" kindref="member">libusb_get_bos_descriptor()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>It is safe to call this function with a NULL bos parameter, in which case the function simply returns.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>bos</parametername>
</parameternamelist>
<parameterdescription>
<para>the BOS descriptor to free </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1342" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="943" bodyend="953"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1gac76954b54b97d90c760716fc048b6555" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_usb_2_0_extension_descriptor</definition>
        <argsstring>(struct libusb_context *ctx, struct libusb_bos_dev_capability_descriptor *dev_cap, struct libusb_usb_2_0_extension_descriptor **usb_2_0_extension)</argsstring>
        <name>libusb_get_usb_2_0_extension_descriptor</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__bos__dev__capability__descriptor" kindref="compound">libusb_bos_dev_capability_descriptor</ref> *</type>
          <declname>dev_cap</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__usb__2__0__extension__descriptor" kindref="compound">libusb_usb_2_0_extension_descriptor</ref> **</type>
          <declname>usb_2_0_extension</declname>
        </param>
        <briefdescription>
<para>Get an USB 2.0 Extension descriptor. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dev_cap</parametername>
</parameternamelist>
<parameterdescription>
<para>Device Capability descriptor with a bDevCapabilityType of <ref refid="group__libusb__dev_1gga6ccabbf3b3728ae69608ba83bba4e64ca243b090db95a0fdf7104fbf581724b86" kindref="member">libusb_capability_type::LIBUSB_BT_USB_2_0_EXTENSION</ref> LIBUSB_BT_USB_2_0_EXTENSION </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>usb_2_0_extension</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the USB 2.0 Extension descriptor. Only valid if 0 was returned. Must be freed with <ref refid="group__libusb__desc_1ga5efd69bf490c4359356f5e5bea8dd48c" kindref="member">libusb_free_usb_2_0_extension_descriptor()</ref> after use. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>a LIBUSB_ERROR code on error </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1343" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="968" bodyend="997"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga5efd69bf490c4359356f5e5bea8dd48c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_usb_2_0_extension_descriptor</definition>
        <argsstring>(struct libusb_usb_2_0_extension_descriptor *usb_2_0_extension)</argsstring>
        <name>libusb_free_usb_2_0_extension_descriptor</name>
        <param>
          <type>struct <ref refid="structlibusb__usb__2__0__extension__descriptor" kindref="compound">libusb_usb_2_0_extension_descriptor</ref> *</type>
          <declname>usb_2_0_extension</declname>
        </param>
        <briefdescription>
<para>Free a USB 2.0 Extension descriptor obtained from <ref refid="group__libusb__desc_1gac76954b54b97d90c760716fc048b6555" kindref="member">libusb_get_usb_2_0_extension_descriptor()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>It is safe to call this function with a NULL usb_2_0_extension parameter, in which case the function simply returns.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>usb_2_0_extension</parametername>
</parameternamelist>
<parameterdescription>
<para>the USB 2.0 Extension descriptor to free </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1347" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="1007" bodyend="1011"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga6f9118c2c4c5a42f9e4040e78af63f78" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_ss_usb_device_capability_descriptor</definition>
        <argsstring>(struct libusb_context *ctx, struct libusb_bos_dev_capability_descriptor *dev_cap, struct libusb_ss_usb_device_capability_descriptor **ss_usb_device_cap)</argsstring>
        <name>libusb_get_ss_usb_device_capability_descriptor</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__bos__dev__capability__descriptor" kindref="compound">libusb_bos_dev_capability_descriptor</ref> *</type>
          <declname>dev_cap</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__ss__usb__device__capability__descriptor" kindref="compound">libusb_ss_usb_device_capability_descriptor</ref> **</type>
          <declname>ss_usb_device_cap</declname>
        </param>
        <briefdescription>
<para>Get a SuperSpeed USB Device Capability descriptor. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dev_cap</parametername>
</parameternamelist>
<parameterdescription>
<para>Device Capability descriptor with a bDevCapabilityType of <ref refid="group__libusb__dev_1gga6ccabbf3b3728ae69608ba83bba4e64ca2f1ab0d2d1e14d4942c079749b1b6c85" kindref="member">libusb_capability_type::LIBUSB_BT_SS_USB_DEVICE_CAPABILITY</ref> LIBUSB_BT_SS_USB_DEVICE_CAPABILITY </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ss_usb_device_cap</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the SuperSpeed USB Device Capability descriptor. Only valid if 0 was returned. Must be freed with <ref refid="group__libusb__desc_1ga8fbf4e49c3ae0c6b7bc2d540ad9a75fb" kindref="member">libusb_free_ss_usb_device_capability_descriptor()</ref> after use. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>a LIBUSB_ERROR code on error </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1349" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="1026" bodyend="1055"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga8fbf4e49c3ae0c6b7bc2d540ad9a75fb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_ss_usb_device_capability_descriptor</definition>
        <argsstring>(struct libusb_ss_usb_device_capability_descriptor *ss_usb_device_cap)</argsstring>
        <name>libusb_free_ss_usb_device_capability_descriptor</name>
        <param>
          <type>struct <ref refid="structlibusb__ss__usb__device__capability__descriptor" kindref="compound">libusb_ss_usb_device_capability_descriptor</ref> *</type>
          <declname>ss_usb_device_cap</declname>
        </param>
        <briefdescription>
<para>Free a SuperSpeed USB Device Capability descriptor obtained from <ref refid="group__libusb__desc_1ga6f9118c2c4c5a42f9e4040e78af63f78" kindref="member">libusb_get_ss_usb_device_capability_descriptor()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>It is safe to call this function with a NULL ss_usb_device_cap parameter, in which case the function simply returns.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ss_usb_device_cap</parametername>
</parameternamelist>
<parameterdescription>
<para>the USB 2.0 Extension descriptor to free </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1353" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="1065" bodyend="1069"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1gabe419223add0c8190a940cc4fae19c7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_container_id_descriptor</definition>
        <argsstring>(struct libusb_context *ctx, struct libusb_bos_dev_capability_descriptor *dev_cap, struct libusb_container_id_descriptor **container_id)</argsstring>
        <name>libusb_get_container_id_descriptor</name>
        <param>
          <type>struct <ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__bos__dev__capability__descriptor" kindref="compound">libusb_bos_dev_capability_descriptor</ref> *</type>
          <declname>dev_cap</declname>
        </param>
        <param>
          <type>struct <ref refid="structlibusb__container__id__descriptor" kindref="compound">libusb_container_id_descriptor</ref> **</type>
          <declname>container_id</declname>
        </param>
        <briefdescription>
<para>Get a Container ID descriptor. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dev_cap</parametername>
</parameternamelist>
<parameterdescription>
<para>Device Capability descriptor with a bDevCapabilityType of <ref refid="group__libusb__dev_1gga6ccabbf3b3728ae69608ba83bba4e64cac3c00e8861b4b596ea1f53c505809e5e" kindref="member">libusb_capability_type::LIBUSB_BT_CONTAINER_ID</ref> LIBUSB_BT_CONTAINER_ID </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>container_id</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the Container ID descriptor. Only valid if 0 was returned. Must be freed with <ref refid="group__libusb__desc_1gafeb7c49aa9d3a9c4964f397220d8eab4" kindref="member">libusb_free_container_id_descriptor()</ref> after use. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>a LIBUSB_ERROR code on error </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1355" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="1084" bodyend="1112"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1gafeb7c49aa9d3a9c4964f397220d8eab4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_container_id_descriptor</definition>
        <argsstring>(struct libusb_container_id_descriptor *container_id)</argsstring>
        <name>libusb_free_container_id_descriptor</name>
        <param>
          <type>struct <ref refid="structlibusb__container__id__descriptor" kindref="compound">libusb_container_id_descriptor</ref> *</type>
          <declname>container_id</declname>
        </param>
        <briefdescription>
<para>Free a Container ID descriptor obtained from <ref refid="group__libusb__desc_1gabe419223add0c8190a940cc4fae19c7f" kindref="member">libusb_get_container_id_descriptor()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>It is safe to call this function with a NULL container_id parameter, in which case the function simply returns.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>container_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the USB 2.0 Extension descriptor to free </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1358" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="1122" bodyend="1126"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gaf2718609d50c8ded2704e4051b3d2925" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint8_t</type>
        <definition>uint8_t libusb_get_bus_number</definition>
        <argsstring>(libusb_device *dev)</argsstring>
        <name>libusb_get_bus_number</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <briefdescription>
<para>Get the number of the bus that a device is connected to. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the bus number </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1360" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="899" bodyend="902"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga14879a0ea7daccdcddb68852d86c00c4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint8_t</type>
        <definition>uint8_t libusb_get_port_number</definition>
        <argsstring>(libusb_device *dev)</argsstring>
        <name>libusb_get_port_number</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <briefdescription>
<para>Get the number of the port that a device is connected to. </para>        </briefdescription>
        <detaileddescription>
<para>Unless the OS does something funky, or you are hot-plugging USB extension cards, the port number returned by this call is usually guaranteed to be uniquely tied to a physical port, meaning that different devices plugged on the same physical port should return the same port number.</para><para>But outside of this, there is no guarantee that the port number returned by this call will remain the same, or even match the order in which ports have been numbered by the HUB/HCD manufacturer.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the port number (0 if not available) </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1361" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="918" bodyend="921"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gaa4b7b2b50a9ce2aa396b0af2b979544d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_port_numbers</definition>
        <argsstring>(libusb_device *dev, uint8_t *port_numbers, int port_numbers_len)</argsstring>
        <name>libusb_get_port_numbers</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>uint8_t *</type>
          <declname>port_numbers</declname>
        </param>
        <param>
          <type>int</type>
          <declname>port_numbers_len</declname>
        </param>
        <briefdescription>
<para>Get the list of all port numbers from root for the specified device. </para>        </briefdescription>
        <detaileddescription>
<para>Since version 1.0.16, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000102 <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>port_numbers</parametername>
</parameternamelist>
<parameterdescription>
<para>the array that should contain the port numbers </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>port_numbers_len</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum length of the array. As per the USB 3.0 specs, the current maximum limit for the depth is 7. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the number of elements filled </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_OVERFLOW if the array is too small </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1362" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="934" bodyend="955"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga9d392b8dff7abf5e475c72fd071c3c34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_port_path</definition>
        <argsstring>(libusb_context *ctx, libusb_device *dev, uint8_t *path, uint8_t path_length)</argsstring>
        <name>libusb_get_port_path</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>uint8_t *</type>
          <declname>path</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>path_length</declname>
        </param>
        <briefdescription>
<para>Deprecated please use libusb_get_port_numbers instead. </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1364" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="960" bodyend="966"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga97bb4dfff6bbb897ed9dfd6fa1a1deed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
        <definition>libusb_device* libusb_get_parent</definition>
        <argsstring>(libusb_device *dev)</argsstring>
        <name>libusb_get_parent</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <briefdescription>
<para>Get the the parent from the specified device. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the device parent or NULL if not available You should issue a <ref refid="group__libusb__dev_1gac0fe4b65914c5ed036e6cbec61cb0b97" kindref="member">libusb_get_device_list()</ref> before calling this function and make sure that you only access the parent before issuing <ref refid="group__libusb__dev_1gad3b8561d064bb3e1b8851ddeed3cd7d6" kindref="member">libusb_free_device_list()</ref>. The reason is that libusb currently does not maintain a permanent list of device instances, and therefore can only guarantee that parents are fully instantiated within a <ref refid="group__libusb__dev_1gac0fe4b65914c5ed036e6cbec61cb0b97" kindref="member">libusb_get_device_list()</ref> - <ref refid="group__libusb__dev_1gad3b8561d064bb3e1b8851ddeed3cd7d6" kindref="member">libusb_free_device_list()</ref> block. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1365" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="980" bodyend="983"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gab6d4e39ac483ebaeb108f2954715305d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint8_t</type>
        <definition>uint8_t libusb_get_device_address</definition>
        <argsstring>(libusb_device *dev)</argsstring>
        <name>libusb_get_device_address</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <briefdescription>
<para>Get the address of the device on the bus it is connected to. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the device address </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1366" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="990" bodyend="993"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga58c4e448ecd5cd4782f2b896ec40b22b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_device_speed</definition>
        <argsstring>(libusb_device *dev)</argsstring>
        <name>libusb_get_device_speed</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <briefdescription>
<para>Get the negotiated connection speed for a device. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="group__libusb__dev_1ga2959abf1184f87b2ce06fe90db6ce614" kindref="member">libusb_speed</ref> code, where LIBUSB_SPEED_UNKNOWN means that the OS doesn&apos;t know or doesn&apos;t support returning the negotiated speed. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1367" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1001" bodyend="1004"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gac81968047e262409e78f3fe24321b604" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_max_packet_size</definition>
        <argsstring>(libusb_device *dev, unsigned char endpoint)</argsstring>
        <name>libusb_get_max_packet_size</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <briefdescription>
<para>Convenience function to retrieve the wMaxPacketSize value for a particular endpoint in the active device configuration. </para>        </briefdescription>
        <detaileddescription>
<para>This function was originally intended to be of assistance when setting up isochronous transfers, but a design mistake resulted in this function instead. It simply returns the wMaxPacketSize value without considering its contents. If you&apos;re dealing with isochronous transfers, you probably want <ref refid="group__libusb__dev_1gaec10b71c7209760db55ee0f8768bb4f0" kindref="member">libusb_get_max_iso_packet_size()</ref> instead.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>address of the endpoint in question </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the wMaxPacketSize value </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_OTHER on other failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1368" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1047" bodyend="1072"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gaec10b71c7209760db55ee0f8768bb4f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_max_iso_packet_size</definition>
        <argsstring>(libusb_device *dev, unsigned char endpoint)</argsstring>
        <name>libusb_get_max_iso_packet_size</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <briefdescription>
<para>Calculate the maximum packet size which a specific endpoint is capable is sending or receiving in the duration of 1 microframe. </para>        </briefdescription>
        <detaileddescription>
<para>Only the active configuration is examined. The calculation is based on the wMaxPacketSize field in the endpoint descriptor as described in section 9.6.6 in the USB 2.0 specifications.</para><para>If acting on an isochronous or interrupt endpoint, this function will multiply the value found in bits 0:10 by the number of transactions per microframe (determined by bits 11:12). Otherwise, this function just returns the numeric value found in bits 0:10.</para><para>This function is useful for setting up isochronous transfers, for example you might pass the return value from this function to <ref refid="group__libusb__asyncio_1gacbdecd6f50093f0c1d0e72ee35ace274" kindref="member">libusb_set_iso_packet_lengths()</ref> in order to set the length field of every isochronous packet in a transfer.</para><para>Since v1.0.3.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>a device </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>address of the endpoint in question </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the maximum packet size which can be sent/received on this endpoint </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_OTHER on other failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1370" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1100" bodyend="1133"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga3f184a8be4488a767b2e0ae07e76d1b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_open</definition>
        <argsstring>(libusb_device *dev, libusb_device_handle **dev_handle)</argsstring>
        <name>libusb_open</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
          <declname>dev</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> **</type>
          <declname>dev_handle</declname>
        </param>
        <briefdescription>
<para>Open a device and obtain a device handle. </para>        </briefdescription>
        <detaileddescription>
<para>A handle allows you to perform I/O on the device in question.</para><para>Internally, this function adds a reference to the device and makes it available to you through <ref refid="group__libusb__dev_1gafe70b8a797893d4d16985980acec956a" kindref="member">libusb_get_device()</ref>. This reference is removed during <ref refid="group__libusb__dev_1ga779bc4f1316bdb0ac383bddbd538620e" kindref="member">libusb_close()</ref>.</para><para>This is a non-blocking function; no requests are sent over the bus.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev</parametername>
</parameternamelist>
<parameterdescription>
<para>the device to open </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the returned device handle pointer. Only populated when the return code is 0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_MEM on memory allocation failure </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_ACCESS if the user has insufficient permissions </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1373" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1240" bodyend="1283"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga779bc4f1316bdb0ac383bddbd538620e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_close</definition>
        <argsstring>(libusb_device_handle *dev_handle)</argsstring>
        <name>libusb_close</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <briefdescription>
<para>Close a device handle. </para>        </briefdescription>
        <detaileddescription>
<para>Should be called on all open handles before your application exits.</para><para>Internally, this function destroys the reference that was added by <ref refid="group__libusb__dev_1ga3f184a8be4488a767b2e0ae07e76d1b0" kindref="member">libusb_open()</ref> on the given device.</para><para>This is a non-blocking function; no requests are sent over the bus.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>the device handle to close </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1374" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1402" bodyend="1453"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gafe70b8a797893d4d16985980acec956a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__libusb__dev_1ga77eedd00d01eb7569b880e861a971c2b" kindref="member">libusb_device</ref> *</type>
        <definition>libusb_device* libusb_get_device</definition>
        <argsstring>(libusb_device_handle *dev_handle)</argsstring>
        <name>libusb_get_device</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <briefdescription>
<para>Get the underlying device for a device handle. </para>        </briefdescription>
        <detaileddescription>
<para>This function does not modify the reference count of the returned device, so do not feel compelled to unreference it when you are done. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the underlying device </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1375" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1463" bodyend="1466"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga785ddea63a2b9bcb879a614ca4867bed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_set_configuration</definition>
        <argsstring>(libusb_device_handle *dev_handle, int configuration)</argsstring>
        <name>libusb_set_configuration</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>int</type>
          <declname>configuration</declname>
        </param>
        <briefdescription>
<para>Set the active configuration for a device. </para>        </briefdescription>
        <detaileddescription>
<para>The operating system may or may not have already set an active configuration on the device. It is up to your application to ensure the correct configuration is selected before you attempt to claim interfaces and perform other operations.</para><para>If you call this function on a device already configured with the selected configuration, then this function will act as a lightweight device reset: it will issue a SET_CONFIGURATION request using the current configuration, causing most USB-related device state to be reset (altsetting reset to zero, endpoint halts cleared, toggles reset).</para><para>You cannot change/reset configuration if your application has claimed interfaces. It is advised to set the desired configuration before claiming interfaces.</para><para>Alternatively you can call <ref refid="group__libusb__dev_1ga49b5cb0d894f6807cd1693ef29aecbfa" kindref="member">libusb_release_interface()</ref> first. Note if you do things this way you must ensure that auto_detach_kernel_driver for <computeroutput>dev</computeroutput> is 0, otherwise the kernel driver will be re-attached when you release the interface(s).</para><para>You cannot change/reset configuration if other applications or drivers have claimed interfaces.</para><para>A configuration value of -1 will put the device in unconfigured state. The USB specifications state that a configuration value of 0 does this, however buggy devices exist which actually have a configuration 0.</para><para>You should always use this function rather than formulating your own SET_CONFIGURATION control request. This is because the underlying operating system needs to know when such changes happen.</para><para>This is a blocking function.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>configuration</parametername>
</parameternamelist>
<parameterdescription>
<para>the bConfigurationValue of the configuration you wish to activate, or -1 if you wish to put the device in an unconfigured state </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the requested configuration does not exist </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if interfaces are currently claimed </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__dev_1gac35b26fef01271eba65c60b2b3ce1cbf" kindref="member">libusb_set_auto_detach_kernel_driver()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1377" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1566" bodyend="1571"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gaee5076addf5de77c7962138397fd5b1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_claim_interface</definition>
        <argsstring>(libusb_device_handle *dev_handle, int interface_number)</argsstring>
        <name>libusb_claim_interface</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>int</type>
          <declname>interface_number</declname>
        </param>
        <briefdescription>
<para>Claim an interface on a given device handle. </para>        </briefdescription>
        <detaileddescription>
<para>You must claim the interface you wish to use before you can perform I/O on any of its endpoints.</para><para>It is legal to attempt to claim an already-claimed interface, in which case libusb just returns 0 without doing anything.</para><para>If auto_detach_kernel_driver is set to 1 for <computeroutput>dev</computeroutput>, the kernel driver will be detached if necessary, on failure the detach error is returned.</para><para>Claiming of interfaces is a purely logical operation; it does not cause any requests to be sent over the bus. Interface claiming is used to instruct the underlying operating system that your application wishes to take ownership of the interface.</para><para>This is a non-blocking function.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>interface_number</parametername>
</parameternamelist>
<parameterdescription>
<para>the <computeroutput>bInterfaceNumber</computeroutput> of the interface you wish to claim </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the requested interface does not exist </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if another program or driver has claimed the interface </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>a LIBUSB_ERROR code on other failure </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__dev_1gac35b26fef01271eba65c60b2b3ce1cbf" kindref="member">libusb_set_auto_detach_kernel_driver()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1379" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1601" bodyend="1624"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga49b5cb0d894f6807cd1693ef29aecbfa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_release_interface</definition>
        <argsstring>(libusb_device_handle *dev_handle, int interface_number)</argsstring>
        <name>libusb_release_interface</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>int</type>
          <declname>interface_number</declname>
        </param>
        <briefdescription>
<para>Release an interface previously claimed with <ref refid="group__libusb__dev_1gaee5076addf5de77c7962138397fd5b1a" kindref="member">libusb_claim_interface()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>You should release all claimed interfaces before closing a device handle.</para><para>This is a blocking function. A SET_INTERFACE control request will be sent to the device, resetting interface state to the first alternate setting.</para><para>If auto_detach_kernel_driver is set to 1 for <computeroutput>dev</computeroutput>, the kernel driver will be re-attached after releasing the interface.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>interface_number</parametername>
</parameternamelist>
<parameterdescription>
<para>the <computeroutput>bInterfaceNumber</computeroutput> of the previously-claimed interface </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the interface was not claimed </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__dev_1gac35b26fef01271eba65c60b2b3ce1cbf" kindref="member">libusb_set_auto_detach_kernel_driver()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1381" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1645" bodyend="1667"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga11ba48adb896b1492bbd3d0bf7e0f665" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
        <definition>libusb_device_handle* libusb_open_device_with_vid_pid</definition>
        <argsstring>(libusb_context *ctx, uint16_t vendor_id, uint16_t product_id)</argsstring>
        <name>libusb_open_device_with_vid_pid</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>vendor_id</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>product_id</declname>
        </param>
        <briefdescription>
<para>Convenience function for finding a device with a particular <computeroutput>idVendor</computeroutput>/<computeroutput>idProduct</computeroutput> combination. </para>        </briefdescription>
        <detaileddescription>
<para>This function is intended for those scenarios where you are using libusb to knock up a quick test application - it allows you to avoid calling <ref refid="group__libusb__dev_1gac0fe4b65914c5ed036e6cbec61cb0b97" kindref="member">libusb_get_device_list()</ref> and worrying about traversing/freeing the list.</para><para>This function has limitations and is hence not intended for use in real applications: if multiple devices have the same IDs it will only give you the first one, etc.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>vendor_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the idVendor value to search for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>product_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the idProduct value to search for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a device handle for the first found device, or NULL on error or if the device could not be found. </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1384" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1302" bodyend="1335"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga4858ad4f0f58fd1dc0afaead1fe6479a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_set_interface_alt_setting</definition>
        <argsstring>(libusb_device_handle *dev_handle, int interface_number, int alternate_setting)</argsstring>
        <name>libusb_set_interface_alt_setting</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>int</type>
          <declname>interface_number</declname>
        </param>
        <param>
          <type>int</type>
          <declname>alternate_setting</declname>
        </param>
        <briefdescription>
<para>Activate an alternate setting for an interface. </para>        </briefdescription>
        <detaileddescription>
<para>The interface must have been previously claimed with <ref refid="group__libusb__dev_1gaee5076addf5de77c7962138397fd5b1a" kindref="member">libusb_claim_interface()</ref>.</para><para>You should always use this function rather than formulating your own SET_INTERFACE control request. This is because the underlying operating system needs to know when such changes happen.</para><para>This is a blocking function.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>interface_number</parametername>
</parameternamelist>
<parameterdescription>
<para>the <computeroutput>bInterfaceNumber</computeroutput> of the previously-claimed interface </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>alternate_setting</parametername>
</parameternamelist>
<parameterdescription>
<para>the <computeroutput>bAlternateSetting</computeroutput> of the alternate setting to activate </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the interface was not claimed, or the requested alternate setting does not exist </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1387" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1690" bodyend="1712"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gab794bbc0b055d140f186f5a4d39c0891" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_clear_halt</definition>
        <argsstring>(libusb_device_handle *dev_handle, unsigned char endpoint)</argsstring>
        <name>libusb_clear_halt</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <briefdescription>
<para>Clear the halt/stall condition for an endpoint. </para>        </briefdescription>
        <detaileddescription>
<para>Endpoints with halt status are unable to receive or transmit data until the halt condition is stalled.</para><para>You should cancel all pending transfers before attempting to clear the halt condition.</para><para>This is a blocking function.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>the endpoint to clear halt status </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the endpoint does not exist </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1389" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1730" bodyend="1738"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gafee9c4638f1713ca5faa867948878111" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_reset_device</definition>
        <argsstring>(libusb_device_handle *dev_handle)</argsstring>
        <name>libusb_reset_device</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <briefdescription>
<para>Perform a USB port reset to reinitialize a device. </para>        </briefdescription>
        <detaileddescription>
<para>The system will attempt to restore the previous configuration and alternate settings after the reset has completed.</para><para>If the reset fails, the descriptors change, or the previous state cannot be restored, the device will appear to be disconnected and reconnected. This means that the device handle is no longer valid (you should close it) and rediscover the device. A return code of LIBUSB_ERROR_NOT_FOUND indicates when this is the case.</para><para>This is a blocking function which usually incurs a noticeable delay.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a handle of the device to reset </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if re-enumeration is required, or if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1391" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1759" bodyend="1766"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gad7e786c1bedd4a668887564465101981" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_alloc_streams</definition>
        <argsstring>(libusb_device_handle *dev_handle, uint32_t num_streams, unsigned char *endpoints, int num_endpoints)</argsstring>
        <name>libusb_alloc_streams</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>num_streams</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>endpoints</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_endpoints</declname>
        </param>
        <briefdescription>
<para>Allocate up to num_streams usb bulk streams on the specified endpoints. </para>        </briefdescription>
        <detaileddescription>
<para>This function takes an array of endpoints rather then a single endpoint because some protocols require that endpoints are setup with similar stream ids. All endpoints passed in must belong to the same interface.</para><para>Note this function may return less streams then requested. Also note that the same number of streams are allocated for each endpoint in the endpoint array.</para><para>Stream id 0 is reserved, and should not be used to communicate with devices. If <ref refid="group__libusb__asyncio_1gad7e786c1bedd4a668887564465101981" kindref="member">libusb_alloc_streams()</ref> returns with a value of N, you may use stream ids 1 to N.</para><para>Since version 1.0.19, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000103</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_streams</parametername>
</parameternamelist>
<parameterdescription>
<para>number of streams to try to allocate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoints</parametername>
</parameternamelist>
<parameterdescription>
<para>array of endpoints to allocate streams on </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_endpoints</parametername>
</parameternamelist>
<parameterdescription>
<para>length of the endpoints array </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of streams allocated, or a LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1393" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1789" bodyend="1802"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gab068de0fd203ccef5c620a8143526acb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_free_streams</definition>
        <argsstring>(libusb_device_handle *dev_handle, unsigned char *endpoints, int num_endpoints)</argsstring>
        <name>libusb_free_streams</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>endpoints</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_endpoints</declname>
        </param>
        <briefdescription>
<para>Free usb bulk streams allocated with <ref refid="group__libusb__asyncio_1gad7e786c1bedd4a668887564465101981" kindref="member">libusb_alloc_streams()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Note streams are automatically free-ed when releasing an interface.</para><para>Since version 1.0.19, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000103</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoints</parametername>
</parameternamelist>
<parameterdescription>
<para>array of endpoints to free streams on </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_endpoints</parametername>
</parameternamelist>
<parameterdescription>
<para>length of the endpoints array </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>LIBUSB_SUCCESS, or a LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1395" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1816" bodyend="1829"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga47c492e750197f1a28874c7a0dee40e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned char *</type>
        <definition>unsigned char* libusb_dev_mem_alloc</definition>
        <argsstring>(libusb_device_handle *dev_handle, size_t length)</argsstring>
        <name>libusb_dev_mem_alloc</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Attempts to allocate a block of persistent DMA memory suitable for transfers against the given device. </para>        </briefdescription>
        <detaileddescription>
<para>If successful, will return a block of memory that is suitable for use as &quot;buffer&quot; in <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> against this device. Using this memory instead of regular memory means that the host controller can use DMA directly into the buffer to increase performance, and also that transfers can no longer fail due to kernel memory fragmentation.</para><para>Note that this means you should not modify this memory (or even data on the same cache lines) when a transfer is in progress, although it is legal to have several transfers going on within the same memory block.</para><para>Will return NULL on failure. Many systems do not support such zerocopy and will always return NULL. Memory allocated with this function must be freed with <ref refid="group__libusb__asyncio_1gad7575ff325f0159a5b74b7c0ee64eb62" kindref="member">libusb_dev_mem_free</ref>. Specifically, this means that the flag <ref refid="group__libusb__asyncio_1gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86" kindref="member">LIBUSB_TRANSFER_FREE_BUFFER</ref> cannot be used to free memory allocated with this function.</para><para>Since version 1.0.21, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000105</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>size of desired data buffer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pointer to the newly allocated memory, or NULL on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1398" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1856" bodyend="1866"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gad7575ff325f0159a5b74b7c0ee64eb62" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_dev_mem_free</definition>
        <argsstring>(libusb_device_handle *dev_handle, unsigned char *buffer, size_t length)</argsstring>
        <name>libusb_dev_mem_free</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Free device memory allocated with <ref refid="group__libusb__asyncio_1ga47c492e750197f1a28874c7a0dee40e3" kindref="member">libusb_dev_mem_alloc()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the previously allocated memory </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>size of previously allocated memory </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>LIBUSB_SUCCESS, or a LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1400" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1876" bodyend="1883"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga1cabd4660a274f715eeb82de112e0779" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_kernel_driver_active</definition>
        <argsstring>(libusb_device_handle *dev_handle, int interface_number)</argsstring>
        <name>libusb_kernel_driver_active</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>int</type>
          <declname>interface_number</declname>
        </param>
        <briefdescription>
<para>Determine if a kernel driver is active on an interface. </para>        </briefdescription>
        <detaileddescription>
<para>If a kernel driver is active, you cannot claim the interface, and libusb will be unable to perform I/O.</para><para>This functionality is not available on Windows.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>interface_number</parametername>
</parameternamelist>
<parameterdescription>
<para>the interface to check </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if no kernel driver is active </para></simplesect>
<simplesect kind="return"><para>1 if a kernel driver is active </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__dev_1ga5e0cc1d666097e915748593effdc634a" kindref="member">libusb_detach_kernel_driver()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1403" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1902" bodyend="1914"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1ga5e0cc1d666097e915748593effdc634a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_detach_kernel_driver</definition>
        <argsstring>(libusb_device_handle *dev_handle, int interface_number)</argsstring>
        <name>libusb_detach_kernel_driver</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>int</type>
          <declname>interface_number</declname>
        </param>
        <briefdescription>
<para>Detach a kernel driver from an interface. </para>        </briefdescription>
        <detaileddescription>
<para>If successful, you will then be able to claim the interface and perform I/O.</para><para>This functionality is not available on Darwin or Windows.</para><para>Note that libusb itself also talks to the device through a special kernel driver, if this driver is already attached to the device, this call will not detach it and return LIBUSB_ERROR_NOT_FOUND.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>interface_number</parametername>
</parameternamelist>
<parameterdescription>
<para>the interface to detach the driver from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if no kernel driver was active </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_INVALID_PARAM if the interface does not exist </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__dev_1ga1cabd4660a274f715eeb82de112e0779" kindref="member">libusb_kernel_driver_active()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1405" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1937" bodyend="1949"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gadeba36e900db663c0b7cf1b164a20d02" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_attach_kernel_driver</definition>
        <argsstring>(libusb_device_handle *dev_handle, int interface_number)</argsstring>
        <name>libusb_attach_kernel_driver</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>int</type>
          <declname>interface_number</declname>
        </param>
        <briefdescription>
<para>Re-attach an interface&apos;s kernel driver, which was previously detached using <ref refid="group__libusb__dev_1ga5e0cc1d666097e915748593effdc634a" kindref="member">libusb_detach_kernel_driver()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>This call is only effective on Linux and returns LIBUSB_ERROR_NOT_SUPPORTED on all other platforms.</para><para>This functionality is not available on Darwin or Windows.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>interface_number</parametername>
</parameternamelist>
<parameterdescription>
<para>the interface to attach the driver from </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if no kernel driver was active </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_INVALID_PARAM if the interface does not exist </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if the driver cannot be attached because the interface is claimed by a program or driver </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__dev_1ga1cabd4660a274f715eeb82de112e0779" kindref="member">libusb_kernel_driver_active()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1407" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="1971" bodyend="1983"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__dev_1gac35b26fef01271eba65c60b2b3ce1cbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_set_auto_detach_kernel_driver</definition>
        <argsstring>(libusb_device_handle *dev_handle, int enable)</argsstring>
        <name>libusb_set_auto_detach_kernel_driver</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>int</type>
          <declname>enable</declname>
        </param>
        <briefdescription>
<para>Enable/disable libusb&apos;s automatic kernel driver detachment. </para>        </briefdescription>
        <detaileddescription>
<para>When this is enabled libusb will automatically detach the kernel driver on an interface when claiming the interface, and attach it when releasing the interface.</para><para>Automatic kernel driver detachment is disabled on newly opened device handles by default.</para><para>On platforms which do not have LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER this function will return LIBUSB_ERROR_NOT_SUPPORTED, and libusb will continue as if this function was never called.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>enable</parametername>
</parameternamelist>
<parameterdescription>
<para>whether to enable or disable auto kernel driver detachment</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>LIBUSB_SUCCESS on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_SUPPORTED on platforms where the functionality is not available </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__dev_1gaee5076addf5de77c7962138397fd5b1a" kindref="member">libusb_claim_interface()</ref> </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__dev_1ga49b5cb0d894f6807cd1693ef29aecbfa" kindref="member">libusb_release_interface()</ref> </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__dev_1ga785ddea63a2b9bcb879a614ca4867bed" kindref="member">libusb_set_configuration()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1409" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/core.c" bodystart="2007" bodyend="2015"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gadf9c633586dde54ce62a3d66a4d7554c" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>unsigned char *</type>
        <definition>static unsigned char* libusb_control_transfer_get_data</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_control_transfer_get_data</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
<para>Get the data section of a control transfer. </para>        </briefdescription>
        <detaileddescription>
<para>This convenience function is here to remind you that the data does not start until 8 bytes into the actual buffer, as the setup packet comes first.</para><para>Calling this function only makes sense from a transfer callback function, or situations where you have already allocated a suitably sized buffer at transfer-&gt;buffer.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>a transfer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>pointer to the first byte of the data section </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1426" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1426" bodyend="1430"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga6ab02f15e11b5b03b1174fbd7c3bc061" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>struct <ref refid="structlibusb__control__setup" kindref="compound">libusb_control_setup</ref> *</type>
        <definition>static struct libusb_control_setup* libusb_control_transfer_get_setup</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_control_transfer_get_setup</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
<para>Get the control setup packet of a control transfer. </para>        </briefdescription>
        <detaileddescription>
<para>This convenience function is here to remind you that the control setup occupies the first 8 bytes of the transfer data buffer.</para><para>Calling this function only makes sense from a transfer callback function, or situations where you have already allocated a suitably sized buffer at transfer-&gt;buffer.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>a transfer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a casted pointer to the start of the transfer data buffer </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1444" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1444" bodyend="1448"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga5447311149ec2bd954b5f1a640a8e231" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void libusb_fill_control_setup</definition>
        <argsstring>(unsigned char *buffer, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint16_t wLength)</argsstring>
        <name>libusb_fill_control_setup</name>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>bmRequestType</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>bRequest</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>wValue</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>wIndex</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>wLength</declname>
        </param>
        <briefdescription>
<para>Helper function to populate the setup packet (first 8 bytes of the data buffer) for a control transfer. </para>        </briefdescription>
        <detaileddescription>
<para>The wIndex, wValue and wLength values should be given in host-endian byte order.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>buffer to output the setup packet into This pointer must be aligned to at least 2 bytes boundary. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bmRequestType</parametername>
</parameternamelist>
<parameterdescription>
<para>see the <ref refid="structlibusb__control__setup_1a39b148c231d675492ccd2383196926bf" kindref="member">bmRequestType</ref> field of <ref refid="structlibusb__control__setup" kindref="compound">libusb_control_setup</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bRequest</parametername>
</parameternamelist>
<parameterdescription>
<para>see the <ref refid="structlibusb__control__setup_1a1b80a28b8d4e8586fc54358194e70087" kindref="member">bRequest</ref> field of <ref refid="structlibusb__control__setup" kindref="compound">libusb_control_setup</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wValue</parametername>
</parameternamelist>
<parameterdescription>
<para>see the <ref refid="structlibusb__control__setup_1abbb6daa01fe4b6a05dc43492e4e53a7d" kindref="member">wValue</ref> field of <ref refid="structlibusb__control__setup" kindref="compound">libusb_control_setup</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>see the <ref refid="structlibusb__control__setup_1a70c2ae456344b200a19d434ace85ae2b" kindref="member">wIndex</ref> field of <ref refid="structlibusb__control__setup" kindref="compound">libusb_control_setup</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wLength</parametername>
</parameternamelist>
<parameterdescription>
<para>see the <ref refid="structlibusb__control__setup_1a3c442c64fd7619b43b782367235766cc" kindref="member">wLength</ref> field of <ref refid="structlibusb__control__setup" kindref="compound">libusb_control_setup</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1473" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1473" bodyend="1483"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga13cc69ea40c702181c430c950121c000" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
        <definition>struct libusb_transfer* libusb_alloc_transfer</definition>
        <argsstring>(int iso_packets)</argsstring>
        <name>libusb_alloc_transfer</name>
        <param>
          <type>int</type>
          <declname>iso_packets</declname>
        </param>
        <briefdescription>
<para>Allocate a libusb transfer with a specified number of isochronous packet descriptors. </para>        </briefdescription>
        <detaileddescription>
<para>The returned transfer is pre-initialized for you. When the new transfer is no longer needed, it should be freed with <ref refid="group__libusb__asyncio_1ga6ab8b2cff4de9091298a06b2f4b86cd6" kindref="member">libusb_free_transfer()</ref>.</para><para>Transfers intended for non-isochronous endpoints (e.g. control, bulk, interrupt) should specify an iso_packets count of zero.</para><para>For transfers intended for isochronous endpoints, specify an appropriate number of packet descriptors to be allocated as part of the transfer. The returned transfer is not specially initialized for isochronous I/O; you are still required to set the <ref refid="structlibusb__transfer_1a87d725a5521c26832fdc13611220014d" kindref="member">num_iso_packets</ref> and <ref refid="structlibusb__transfer_1a7c9fa575986fe9f23bbecb26b766dff1" kindref="member">type</ref> fields accordingly.</para><para>It is safe to allocate a transfer with some isochronous packets and then use it on a non-isochronous endpoint. If you do this, ensure that at time of submission, num_iso_packets is 0 and that type is set appropriately.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>iso_packets</parametername>
</parameternamelist>
<parameterdescription>
<para>number of isochronous packet descriptors to allocate </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a newly allocated transfer, or NULL on error </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1485" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1257" bodyend="1275"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gabb0932601f2c7dad2fee4b27962848ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_submit_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_submit_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
<para>Submit a transfer. </para>        </briefdescription>
        <detaileddescription>
<para>This function will fire off the USB transfer and then return immediately.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to submit </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if the transfer has already been submitted. </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_SUPPORTED if the transfer flags are not supported by the operating system. </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_INVALID_PARAM if the transfer size is larger than the operating system and/or hardware can support </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1486" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1469" bodyend="1544"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga685eb7731f9a0593f75beb99727bbe54" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_cancel_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_cancel_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
<para>Asynchronously cancel a previously submitted transfer. </para>        </briefdescription>
        <detaileddescription>
<para>This function returns immediately, but this does not indicate cancellation is complete. Your callback function will be invoked at some later time with a transfer status of <ref refid="group__libusb__asyncio_1gga9fcb2aa23d342060ebda1d0cf7478856a8af1f19e46cccafdcf3feadce47e880b" kindref="member">LIBUSB_TRANSFER_CANCELLED.</ref></para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to cancel </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NOT_FOUND if the transfer is not in progress, already complete, or already cancelled. </para></simplesect>
<simplesect kind="return"><para>a LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1487" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1560" bodyend="1591"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga6ab8b2cff4de9091298a06b2f4b86cd6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_free_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
<para>Free a transfer structure. </para>        </briefdescription>
        <detaileddescription>
<para>This should be called for all transfers allocated with <ref refid="group__libusb__asyncio_1ga13cc69ea40c702181c430c950121c000" kindref="member">libusb_alloc_transfer()</ref>.</para><para>If the <ref refid="group__libusb__asyncio_1gga1fb47dd0f7c209b60a3609ff0c03d56dae993a26f495ac9949118e23eafa19e86" kindref="member">LIBUSB_TRANSFER_FREE_BUFFER</ref> flag is set and the transfer buffer is non-NULL, this function will also free the transfer buffer using the standard system memory allocator (e.g. free()).</para><para>It is legal to call this function with a NULL transfer. In this case, the function will simply return safely.</para><para>It is not legal to free an active transfer (one which has been submitted and has not yet completed).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to free </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1488" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1294" bodyend="1307"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gaeae2db23b9de811af317483afdeb230f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_transfer_set_stream_id</definition>
        <argsstring>(struct libusb_transfer *transfer, uint32_t stream_id)</argsstring>
        <name>libusb_transfer_set_stream_id</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>stream_id</declname>
        </param>
        <briefdescription>
<para>Set a transfers bulk stream id. </para>        </briefdescription>
        <detaileddescription>
<para>Note users are advised to use <ref refid="group__libusb__asyncio_1gac2e84d8fb9218d3c67e6a4fd4ade5b10" kindref="member">libusb_fill_bulk_stream_transfer()</ref> instead of calling this function directly.</para><para>Since version 1.0.19, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000103</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to set the stream id for </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the stream id to set </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="group__libusb__asyncio_1gad7e786c1bedd4a668887564465101981" kindref="member">libusb_alloc_streams()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1489" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1604" bodyend="1611"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga631653487273f3306925131cdc0a3ffc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>uint32_t</type>
        <definition>uint32_t libusb_transfer_get_stream_id</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>libusb_transfer_get_stream_id</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
<para>Get a transfers bulk stream id. </para>        </briefdescription>
        <detaileddescription>
<para>Since version 1.0.19, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000103</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to get the stream id for </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the stream id for the transfer </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1491" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1621" bodyend="1628"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga3a8513ed87229fe2c9771ef0bf17206e" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void libusb_fill_control_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer, libusb_device_handle *dev_handle, unsigned char *buffer, libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)</argsstring>
        <name>libusb_fill_control_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__asyncio_1gac74874519794cd7aa40c0814702b0c88" kindref="member">libusb_transfer_cb_fn</ref></type>
          <declname>callback</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user_data</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Helper function to populate the required <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> fields for a control transfer. </para>        </briefdescription>
        <detaileddescription>
<para>If you pass a transfer buffer to this function, the first 8 bytes will be interpreted as a control setup packet, and the wLength field will be used to automatically populate the <ref refid="structlibusb__transfer_1a68c023e1f40b50aa8604a2495b6a391e" kindref="member">length</ref> field of the transfer. Therefore the recommended approach is:<orderedlist>
<listitem><para>Allocate a suitably sized data buffer (including space for control setup)</para></listitem><listitem><para>Call <ref refid="group__libusb__asyncio_1ga5447311149ec2bd954b5f1a640a8e231" kindref="member">libusb_fill_control_setup()</ref></para></listitem><listitem><para>If this is a host-to-device transfer with a data stage, put the data in place after the setup packet</para></listitem><listitem><para>Call this function</para></listitem><listitem><para>Call <ref refid="group__libusb__asyncio_1gabb0932601f2c7dad2fee4b27962848ce" kindref="member">libusb_submit_transfer()</ref></para></listitem></orderedlist>
</para><para>It is also legal to pass a NULL buffer to this function, in which case this function will not attempt to populate the length field. Remember that you must then populate the buffer and length fields later.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to populate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>handle of the device that will handle the transfer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>data buffer. If provided, this function will interpret the first 8 bytes as a setup packet and infer the transfer length from that. This pointer must be aligned to at least 2 bytes boundary. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>callback function to be invoked on transfer completion </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>user data to pass to callback function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout for the transfer in milliseconds </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1522" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1522" bodyend="1538"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gad4ddb1a5c6c7fefc979a44d7300b95d7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void libusb_fill_bulk_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer, libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, int length, libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)</argsstring>
        <name>libusb_fill_bulk_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__asyncio_1gac74874519794cd7aa40c0814702b0c88" kindref="member">libusb_transfer_cb_fn</ref></type>
          <declname>callback</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user_data</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Helper function to populate the required <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> fields for a bulk transfer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to populate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>handle of the device that will handle the transfer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>address of the endpoint where this transfer will be sent </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>data buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>length of data buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>callback function to be invoked on transfer completion </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>user data to pass to callback function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout for the transfer in milliseconds </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1553" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1553" bodyend="1566"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gac2e84d8fb9218d3c67e6a4fd4ade5b10" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void libusb_fill_bulk_stream_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer, libusb_device_handle *dev_handle, unsigned char endpoint, uint32_t stream_id, unsigned char *buffer, int length, libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)</argsstring>
        <name>libusb_fill_bulk_stream_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <param>
          <type>uint32_t</type>
          <declname>stream_id</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__asyncio_1gac74874519794cd7aa40c0814702b0c88" kindref="member">libusb_transfer_cb_fn</ref></type>
          <declname>callback</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user_data</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Helper function to populate the required <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> fields for a bulk transfer using bulk streams. </para>        </briefdescription>
        <detaileddescription>
<para>Since version 1.0.19, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000103</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to populate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>handle of the device that will handle the transfer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>address of the endpoint where this transfer will be sent </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>stream_id</parametername>
</parameternamelist>
<parameterdescription>
<para>bulk stream id for this transfer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>data buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>length of data buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>callback function to be invoked on transfer completion </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>user data to pass to callback function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout for the transfer in milliseconds </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1584" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1584" bodyend="1594"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga90f53cea1124a7566df1aa1202b77510" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void libusb_fill_interrupt_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer, libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, int length, libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)</argsstring>
        <name>libusb_fill_interrupt_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__asyncio_1gac74874519794cd7aa40c0814702b0c88" kindref="member">libusb_transfer_cb_fn</ref></type>
          <declname>callback</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user_data</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Helper function to populate the required <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> fields for an interrupt transfer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to populate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>handle of the device that will handle the transfer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>address of the endpoint where this transfer will be sent </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>data buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>length of data buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>callback function to be invoked on transfer completion </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>user data to pass to callback function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout for the transfer in milliseconds </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1609" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1609" bodyend="1622"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga30fdce8c461e851f0aa4c851014e1aa7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void libusb_fill_iso_transfer</definition>
        <argsstring>(struct libusb_transfer *transfer, libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, int length, int num_iso_packets, libusb_transfer_cb_fn callback, void *user_data, unsigned int timeout)</argsstring>
        <name>libusb_fill_iso_transfer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <param>
          <type>int</type>
          <declname>num_iso_packets</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__asyncio_1gac74874519794cd7aa40c0814702b0c88" kindref="member">libusb_transfer_cb_fn</ref></type>
          <declname>callback</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user_data</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Helper function to populate the required <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> fields for an isochronous transfer. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>the transfer to populate </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>handle of the device that will handle the transfer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>address of the endpoint where this transfer will be sent </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buffer</parametername>
</parameternamelist>
<parameterdescription>
<para>data buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>length of data buffer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num_iso_packets</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of isochronous packets </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callback</parametername>
</parameternamelist>
<parameterdescription>
<para>callback function to be invoked on transfer completion </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>user data to pass to callback function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout for the transfer in milliseconds </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1638" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1638" bodyend="1652"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1gacbdecd6f50093f0c1d0e72ee35ace274" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>static void libusb_set_iso_packet_lengths</definition>
        <argsstring>(struct libusb_transfer *transfer, unsigned int length)</argsstring>
        <name>libusb_set_iso_packet_lengths</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Convenience function to set the length of all packets in an isochronous transfer, based on the num_iso_packets field in the transfer structure. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>a transfer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>the length to set in each isochronous packet descriptor </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="see"><para><ref refid="group__libusb__dev_1gac81968047e262409e78f3fe24321b604" kindref="member">libusb_get_max_packet_size()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1662" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1662" bodyend="1668"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga7f6ea0eb35a216d19d984977e454a7b3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>unsigned char *</type>
        <definition>static unsigned char* libusb_get_iso_packet_buffer</definition>
        <argsstring>(struct libusb_transfer *transfer, unsigned int packet)</argsstring>
        <name>libusb_get_iso_packet_buffer</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>packet</declname>
        </param>
        <briefdescription>
<para>Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer. </para>        </briefdescription>
        <detaileddescription>
<para>This is a thorough function which loops through all preceding packets, accumulating their lengths to find the position of the specified packet. Typically you will assign equal lengths to each packet in the transfer, and hence the above method is sub-optimal. You may wish to use <ref refid="group__libusb__asyncio_1ga3df9a28c4f5c8f1850181ddb5efd12fd" kindref="member">libusb_get_iso_packet_buffer_simple()</ref> instead.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>a transfer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>packet</parametername>
</parameternamelist>
<parameterdescription>
<para>the packet to return the address of </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the base address of the packet buffer inside the transfer buffer, or NULL if the packet does not exist. </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__asyncio_1ga3df9a28c4f5c8f1850181ddb5efd12fd" kindref="member">libusb_get_iso_packet_buffer_simple()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1686" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1686" bodyend="1707"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__asyncio_1ga3df9a28c4f5c8f1850181ddb5efd12fd" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>unsigned char *</type>
        <definition>static unsigned char* libusb_get_iso_packet_buffer_simple</definition>
        <argsstring>(struct libusb_transfer *transfer, unsigned int packet)</argsstring>
        <name>libusb_get_iso_packet_buffer_simple</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>packet</declname>
        </param>
        <briefdescription>
<para>Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer, for transfers where each packet is of identical size. </para>        </briefdescription>
        <detaileddescription>
<para>This function relies on the assumption that every packet within the transfer is of identical size to the first packet. Calculating the location of the packet buffer is then just a simple calculation: <computeroutput>buffer + (packet_size * packet)</computeroutput></para><para>Do not use this function on transfers other than those that have identical packet lengths for each packet.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>transfer</parametername>
</parameternamelist>
<parameterdescription>
<para>a transfer </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>packet</parametername>
</parameternamelist>
<parameterdescription>
<para>the packet to return the address of </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the base address of the packet buffer inside the transfer buffer, or NULL if the packet does not exist. </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__asyncio_1ga7f6ea0eb35a216d19d984977e454a7b3" kindref="member">libusb_get_iso_packet_buffer()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1728" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1728" bodyend="1744"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__syncio_1gadb11f7a761bd12fc77a07f4568d56f38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_control_transfer</definition>
        <argsstring>(libusb_device_handle *dev_handle, uint8_t request_type, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, unsigned char *data, uint16_t wLength, unsigned int timeout)</argsstring>
        <name>libusb_control_transfer</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>request_type</declname>
          <defname>bmRequestType</defname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>bRequest</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>wValue</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>wIndex</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>wLength</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Perform a USB control transfer. </para>        </briefdescription>
        <detaileddescription>
<para>The direction of the transfer is inferred from the bmRequestType field of the setup packet.</para><para>The wValue, wIndex and wLength fields values should be given in host-endian byte order.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a handle for the device to communicate with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bmRequestType</parametername>
</parameternamelist>
<parameterdescription>
<para>the request type field for the setup packet </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bRequest</parametername>
</parameternamelist>
<parameterdescription>
<para>the request field for the setup packet </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wValue</parametername>
</parameternamelist>
<parameterdescription>
<para>the value field for the setup packet </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>the index field for the setup packet </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>a suitably-sized data buffer for either input or output (depending on direction bits within bmRequestType) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wLength</parametername>
</parameternamelist>
<parameterdescription>
<para>the length field for the setup packet. The data buffer should be at least this size. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout (in millseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>on success, the number of bytes actually transferred </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_TIMEOUT if the transfer timed out </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_PIPE if the control request was not supported by the device </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if called from event handling context </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_INVALID_PARAM if the transfer size is larger than the operating system and/or hardware can support </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failures </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1748" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" bodystart="94" bodyend="164"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__syncio_1gab8ae853ab492c22d707241dc26c8a805" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_bulk_transfer</definition>
        <argsstring>(libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *actual_length, unsigned int timeout)</argsstring>
        <name>libusb_bulk_transfer</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>actual_length</declname>
          <defname>transferred</defname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Perform a USB bulk transfer. </para>        </briefdescription>
        <detaileddescription>
<para>The direction of the transfer is inferred from the direction bits of the endpoint address.</para><para>For bulk reads, the <computeroutput>length</computeroutput> field indicates the maximum length of data you are expecting to receive. If less data arrives than expected, this function will return that data, so be sure to check the <computeroutput>transferred</computeroutput> output parameter.</para><para>You should also check the <computeroutput>transferred</computeroutput> parameter for bulk writes. Not all of the data may have been written.</para><para>Also check <computeroutput>transferred</computeroutput> when dealing with a timeout error code. libusb may have to split your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the timeout may expire after the first few chunks have completed. libusb is careful not to lose any data that may have been transferred; do not assume that timeout conditions indicate a complete lack of I/O.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a handle for the device to communicate with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>the address of a valid endpoint to communicate with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>a suitably-sized data buffer for either input or output (depending on endpoint) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>for bulk writes, the number of bytes from data to be sent. for bulk reads, the maximum number of bytes to receive into the data buffer. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transferred</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the number of bytes actually transferred. Since version 1.0.21 (<ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000105), it is legal to pass a NULL pointer if you do not wish to receive this information. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout (in millseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success (and populates <computeroutput>transferred</computeroutput>) </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_TIMEOUT if the transfer timed out (and populates <computeroutput>transferred</computeroutput>) </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_PIPE if the endpoint halted </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_OVERFLOW if the device offered more data, see <ref refid="libusb_packetoverflow" kindref="compound">Packets and overflows</ref> </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if called from event handling context </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failures </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1752" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" bodystart="269" bodyend="275"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__syncio_1gac412bda21b7ecf57e4c76877d78e6486" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_interrupt_transfer</definition>
        <argsstring>(libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *actual_length, unsigned int timeout)</argsstring>
        <name>libusb_interrupt_transfer</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>actual_length</declname>
          <defname>transferred</defname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Perform a USB interrupt transfer. </para>        </briefdescription>
        <detaileddescription>
<para>The direction of the transfer is inferred from the direction bits of the endpoint address.</para><para>For interrupt reads, the <computeroutput>length</computeroutput> field indicates the maximum length of data you are expecting to receive. If less data arrives than expected, this function will return that data, so be sure to check the <computeroutput>transferred</computeroutput> output parameter.</para><para>You should also check the <computeroutput>transferred</computeroutput> parameter for interrupt writes. Not all of the data may have been written.</para><para>Also check <computeroutput>transferred</computeroutput> when dealing with a timeout error code. libusb may have to split your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the timeout may expire after the first few chunks have completed. libusb is careful not to lose any data that may have been transferred; do not assume that timeout conditions indicate a complete lack of I/O.</para><para>The default endpoint bInterval value is used as the polling interval.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a handle for the device to communicate with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>the address of a valid endpoint to communicate with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>a suitably-sized data buffer for either input or output (depending on endpoint) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>for bulk writes, the number of bytes from data to be sent. for bulk reads, the maximum number of bytes to receive into the data buffer. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transferred</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the number of bytes actually transferred. Since version 1.0.21 (<ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000105), it is legal to pass a NULL pointer if you do not wish to receive this information. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout (in millseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success (and populates <computeroutput>transferred</computeroutput>) </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_TIMEOUT if the transfer timed out </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_PIPE if the endpoint halted </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_OVERFLOW if the device offered more data, see <ref refid="libusb_packetoverflow" kindref="compound">Packets and overflows</ref> </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if called from event handling context </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other error </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1756" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" bodystart="321" bodyend="327"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga9e34f7ecf3817e9bfe77ed09238940df" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int libusb_get_descriptor</definition>
        <argsstring>(libusb_device_handle *dev_handle, uint8_t desc_type, uint8_t desc_index, unsigned char *data, int length)</argsstring>
        <name>libusb_get_descriptor</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>desc_type</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>desc_index</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Retrieve a descriptor from the default control pipe. </para>        </briefdescription>
        <detaileddescription>
<para>This is a convenience function which formulates the appropriate control message to retrieve the descriptor.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>desc_type</parametername>
</parameternamelist>
<parameterdescription>
<para>the descriptor type, see <ref refid="group__libusb__desc_1ga0a2e8a25dfdebf29fdd4764dcdbc1a9c" kindref="member">libusb_descriptor_type</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>desc_index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index of the descriptor to retrieve </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>output buffer for descriptor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>size of data buffer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of bytes returned in data, or LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1772" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1772" bodyend="1778"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga09103309f98471387561bce0719d88ad" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>static int libusb_get_string_descriptor</definition>
        <argsstring>(libusb_device_handle *dev_handle, uint8_t desc_index, uint16_t langid, unsigned char *data, int length)</argsstring>
        <name>libusb_get_string_descriptor</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>desc_index</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>langid</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Retrieve a descriptor from a device. </para>        </briefdescription>
        <detaileddescription>
<para>This is a convenience function which formulates the appropriate control message to retrieve the descriptor. The string returned is Unicode, as detailed in the USB specifications.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>desc_index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index of the descriptor to retrieve </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>langid</parametername>
</parameternamelist>
<parameterdescription>
<para>the language ID for the string descriptor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>output buffer for descriptor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>size of data buffer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of bytes returned in data, or LIBUSB_ERROR code on failure </para></simplesect>
<simplesect kind="see"><para><ref refid="group__libusb__desc_1ga240aac96d92cb9f51e3aea79a4adbf42" kindref="member">libusb_get_string_descriptor_ascii()</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1794" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" bodystart="1794" bodyend="1800"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__desc_1ga240aac96d92cb9f51e3aea79a4adbf42" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_string_descriptor_ascii</definition>
        <argsstring>(libusb_device_handle *dev_handle, uint8_t desc_index, unsigned char *data, int length)</argsstring>
        <name>libusb_get_string_descriptor_ascii</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>desc_index</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <briefdescription>
<para>Retrieve a string descriptor in C style ASCII. </para>        </briefdescription>
        <detaileddescription>
<para>Wrapper around <ref refid="group__libusb__desc_1ga09103309f98471387561bce0719d88ad" kindref="member">libusb_get_string_descriptor()</ref>. Uses the first language supported by the device.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a device handle </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>desc_index</parametername>
</parameternamelist>
<parameterdescription>
<para>the index of the descriptor to retrieve </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>output buffer for ASCII string descriptor </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>size of data buffer </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>number of bytes returned in data, or LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1802" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/descriptor.c" bodystart="1140" bodyend="1191"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga6e5a116d5c9498ca4a0e29587fec1a05" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_try_lock_events</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_try_lock_events</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Attempt to acquire the event handling lock. </para>        </briefdescription>
        <detaileddescription>
<para>This lock is used to ensure that only one thread is monitoring libusb event sources at any one time.</para><para>You only need to use this lock if you are developing an application which calls poll() or select() on libusb&apos;s file descriptors directly. If you stick to libusb&apos;s event handling loop functions (e.g. <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref>) then you do not need to be concerned with this locking.</para><para>While holding this lock, you are trusted to actually be handling events. If you are no longer handling events, you must call <ref refid="group__libusb__poll_1gacefbeabdd3409490dc4678f00779c165" kindref="member">libusb_unlock_events()</ref> as soon as possible.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if the lock was obtained successfully </para></simplesect>
<simplesect kind="return"><para>1 if the lock was not obtained (i.e. another thread holds the lock) <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1807" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1740" bodyend="1762"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1gaa72153938dc4f34decfacbc6cc6237ef" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_lock_events</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_lock_events</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Acquire the event handling lock, blocking until successful acquisition if it is contended. </para>        </briefdescription>
        <detaileddescription>
<para>This lock is used to ensure that only one thread is monitoring libusb event sources at any one time.</para><para>You only need to use this lock if you are developing an application which calls poll() or select() on libusb&apos;s file descriptors directly. If you stick to libusb&apos;s event handling loop functions (e.g. <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref>) then you do not need to be concerned with this locking.</para><para>While holding this lock, you are trusted to actually be handling events. If you are no longer handling events, you must call <ref refid="group__libusb__poll_1gacefbeabdd3409490dc4678f00779c165" kindref="member">libusb_unlock_events()</ref> as soon as possible.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1808" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1782" bodyend="1787"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1gacefbeabdd3409490dc4678f00779c165" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_unlock_events</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_unlock_events</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Release the lock previously acquired with <ref refid="group__libusb__poll_1ga6e5a116d5c9498ca4a0e29587fec1a05" kindref="member">libusb_try_lock_events()</ref> or <ref refid="group__libusb__poll_1gaa72153938dc4f34decfacbc6cc6237ef" kindref="member">libusb_lock_events()</ref>. </para>        </briefdescription>
        <detaileddescription>
<para>Releasing this lock will wake up any threads blocked on <ref refid="group__libusb__poll_1gae22755d523560be2867be7d09034ca50" kindref="member">libusb_wait_for_event()</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1809" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1797" bodyend="1809"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga63592b28c265185d9469d1e6920d8373" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_event_handling_ok</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_event_handling_ok</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Determine if it is still OK for this thread to be doing event handling. </para>        </briefdescription>
        <detaileddescription>
<para>Sometimes, libusb needs to temporarily pause all event handlers, and this is the function you should use before polling file descriptors to see if this is the case.</para><para>If this function instructs your thread to give up the events lock, you should just continue the usual logic that is documented in <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref>. On the next iteration, your thread will fail to obtain the events lock, and will hence become an event waiter.</para><para>This function should be called while the events lock is held: you don&apos;t need to worry about the results of this function if your thread is not the current event handler.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if event handling can start or continue </para></simplesect>
<simplesect kind="return"><para>0 if this thread must give up the events lock <ref refid="libusb_mtasync_1fullstory" kindref="member">Multi-threaded I/O: the full story</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1810" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1832" bodyend="1848"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga3a0a6e8be310c20f1ca68722149f9dbf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_event_handler_active</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_event_handler_active</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Determine if an active thread is handling events (i.e. </para>        </briefdescription>
        <detaileddescription>
<para>if anyone is holding the event handling lock).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>1 if a thread is handling events </para></simplesect>
<simplesect kind="return"><para>0 if there are no threads currently handling events <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1811" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1860" bodyend="1876"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga188b6c50944b49f122ccfd45b93fa9f2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_interrupt_event_handler</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_interrupt_event_handler</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Interrupt any active thread that is handling events. </para>        </briefdescription>
        <detaileddescription>
<para>This is mainly useful for interrupting a dedicated event handling thread when an application wishes to call <ref refid="group__libusb__lib_1ga86532f222d4f1332a5f8f5eef9a92da9" kindref="member">libusb_exit()</ref>.</para><para>Since version 1.0.21, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000105</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1812" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1888" bodyend="1899"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga150865a3f35c38173d688efa7ee52929" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_lock_event_waiters</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_lock_event_waiters</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Acquire the event waiters lock. </para>        </briefdescription>
        <detaileddescription>
<para>This lock is designed to be obtained under the situation where you want to be aware when events are completed, but some other thread is event handling so calling <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref> is not allowed.</para><para>You then obtain this lock, re-check that another thread is still handling events, then call <ref refid="group__libusb__poll_1gae22755d523560be2867be7d09034ca50" kindref="member">libusb_wait_for_event()</ref>.</para><para>You only need to use this lock if you are developing an application which calls poll() or select() on libusb&apos;s file descriptors directly, <bold>and</bold> may potentially be handling events from 2 threads simultaenously. If you stick to libusb&apos;s event handling loop functions (e.g. <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref>) then you do not need to be concerned with this locking.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1813" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1920" bodyend="1924"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga41d7716458c11ee02d0deb19a31233ed" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_unlock_event_waiters</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_unlock_event_waiters</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Release the event waiters lock. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1814" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1931" bodyend="1935"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1gae22755d523560be2867be7d09034ca50" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_wait_for_event</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv)</argsstring>
        <name>libusb_wait_for_event</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <briefdescription>
<para>Wait for another thread to signal completion of an event. </para>        </briefdescription>
        <detaileddescription>
<para>Must be called with the event waiters lock held, see <ref refid="group__libusb__poll_1ga150865a3f35c38173d688efa7ee52929" kindref="member">libusb_lock_event_waiters()</ref>.</para><para>This function will block until any of the following conditions are met:<orderedlist>
<listitem><para>The timeout expires</para></listitem><listitem><para>A transfer completes</para></listitem><listitem><para>A thread releases the event handling lock through <ref refid="group__libusb__poll_1gacefbeabdd3409490dc4678f00779c165" kindref="member">libusb_unlock_events()</ref></para></listitem></orderedlist>
</para><para>Condition 1 is obvious. Condition 2 unblocks your thread <emphasis>after</emphasis> the callback for the transfer has completed. Condition 3 is important because it means that the thread that was previously handling events is no longer doing so, so if any events are to complete, another thread needs to step up and start event handling.</para><para>This function releases the event waiters lock before putting your thread to sleep, and reacquires the lock as it is being woken up.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tv</parametername>
</parameternamelist>
<parameterdescription>
<para>maximum timeout for this blocking function. A NULL value indicates unlimited timeout. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 after a transfer completes or another thread stops event handling </para></simplesect>
<simplesect kind="return"><para>1 if the timeout expired <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1815" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="1962" bodyend="1979"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga6deff4c7d3a6c04bb9ec9fd259b48933" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_handle_events_timeout</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv)</argsstring>
        <name>libusb_handle_events_timeout</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <briefdescription>
<para>Handle any pending events. </para>        </briefdescription>
        <detaileddescription>
<para>Like <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref>, but without the completed parameter, calling this function is equivalent to calling <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref> with a NULL completed parameter.</para><para>This function is kept primarily for backwards compatibility. All new code should call <ref refid="group__libusb__poll_1ga0bc99f39e4cf5ad393cd5936c36037d1" kindref="member">libusb_handle_events_completed()</ref> or <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref> to avoid race conditions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tv</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum time to block waiting for events, or an all zero timeval struct for non-blocking mode </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1817" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2396" bodyend="2400"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_handle_events_timeout_completed</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv, int *completed)</argsstring>
        <name>libusb_handle_events_timeout_completed</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>completed</declname>
        </param>
        <briefdescription>
<para>Handle any pending events. </para>        </briefdescription>
        <detaileddescription>
<para>libusb determines &quot;pending events&quot; by checking if any timeouts have expired and by checking the set of file descriptors for activity.</para><para>If a zero timeval is passed, this function will handle any already-pending events and then immediately return in non-blocking style.</para><para>If a non-zero timeval is passed and no events are currently pending, this function will block waiting for events to handle up until the specified timeout. If an event arrives or a signal is raised, this function will return early.</para><para>If the parameter completed is not NULL then <emphasis>after obtaining the event handling lock</emphasis> this function will return immediately if the integer pointed to is not 0. This allows for race free waiting for the completion of a specific transfer.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tv</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum time to block waiting for events, or an all zero timeval struct for non-blocking mode </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>completed</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to completion integer to check, or NULL </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1819" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2327" bodyend="2378"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_handle_events</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_handle_events</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Handle any pending events in blocking mode. </para>        </briefdescription>
        <detaileddescription>
<para>There is currently a timeout hardcoded at 60 seconds but we plan to make it unlimited in future. For finer control over whether this function is blocking or non-blocking, or for control over the timeout, use <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref> instead.</para><para>This function is kept primarily for backwards compatibility. All new code should call <ref refid="group__libusb__poll_1ga0bc99f39e4cf5ad393cd5936c36037d1" kindref="member">libusb_handle_events_completed()</ref> or <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref> to avoid race conditions.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1821" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2416" bodyend="2422"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga0bc99f39e4cf5ad393cd5936c36037d1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_handle_events_completed</definition>
        <argsstring>(libusb_context *ctx, int *completed)</argsstring>
        <name>libusb_handle_events_completed</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>completed</declname>
        </param>
        <briefdescription>
<para>Handle any pending events in blocking mode. </para>        </briefdescription>
        <detaileddescription>
<para>Like <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref>, with the addition of a completed parameter to allow for race free waiting for the completion of a specific transfer.</para><para>See <ref refid="group__libusb__poll_1ga43e52b912a760b41a0cf8a4a472fbd5b" kindref="member">libusb_handle_events_timeout_completed()</ref> for details on the completed parameter.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>completed</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to completion integer to check, or NULL </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1822" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2438" bodyend="2445"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga71da081f97afa3bf68aed8e372254e8f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_handle_events_locked</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv)</argsstring>
        <name>libusb_handle_events_locked</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <briefdescription>
<para>Handle any pending events by polling file descriptors, without checking if any other threads are already doing so. </para>        </briefdescription>
        <detaileddescription>
<para>Must be called with the event lock held, see <ref refid="group__libusb__poll_1gaa72153938dc4f34decfacbc6cc6237ef" kindref="member">libusb_lock_events()</ref>.</para><para>This function is designed to be called under the situation where you have taken the event lock and are calling poll()/select() directly on libusb&apos;s file descriptors (as opposed to using <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref> or similar). You detect events on libusb&apos;s descriptors, so you then call this function with a zero timeout value (while still holding the event lock).</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tv</parametername>
</parameternamelist>
<parameterdescription>
<para>the maximum time to block waiting for events, or zero for non-blocking mode </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success, or a LIBUSB_ERROR code on failure <ref refid="libusb_mtasync" kindref="compound">Multi-threaded applications and asynchronous I/O</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1823" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2464" bodyend="2478"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1gae7a654315636bebf404c1784429f06df" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_pollfds_handle_timeouts</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_pollfds_handle_timeouts</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Determines whether your application must apply special timing considerations when monitoring libusb&apos;s file descriptors. </para>        </briefdescription>
        <detaileddescription>
<para>This function is only useful for applications which retrieve and poll libusb&apos;s file descriptors in their own main loop (<ref refid="group__libusb__poll_1libusb_pollmain" kindref="member">The more advanced option</ref>).</para><para>Ordinarily, libusb&apos;s event handler needs to be called into at specific moments in time (in addition to times when there is activity on the file descriptor set). The usual approach is to use <ref refid="group__libusb__poll_1ga5bc6f5bc71a43845244912da6679f634" kindref="member">libusb_get_next_timeout()</ref> to learn about when the next timeout occurs, and to adjust your poll()/select() timeout accordingly so that you can make a call into the library at that time.</para><para>Some platforms supported by libusb do not come with this baggage - any events relevant to timing will be represented by activity on the file descriptor set, and <ref refid="group__libusb__poll_1ga5bc6f5bc71a43845244912da6679f634" kindref="member">libusb_get_next_timeout()</ref> will always return 0. This function allows you to detect whether you are running on such a platform.</para><para>Since v1.0.5.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if you must call into libusb at times determined by <ref refid="group__libusb__poll_1ga5bc6f5bc71a43845244912da6679f634" kindref="member">libusb_get_next_timeout()</ref>, or 1 if all timeout events are handled internally or through regular activity on the file descriptors. <ref refid="group__libusb__poll_1libusb_pollmain" kindref="member">Polling libusb file descriptors for event handling</ref> </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1825" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2508" bodyend="2517"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga5bc6f5bc71a43845244912da6679f634" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_get_next_timeout</definition>
        <argsstring>(libusb_context *ctx, struct timeval *tv)</argsstring>
        <name>libusb_get_next_timeout</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type>struct timeval *</type>
          <declname>tv</declname>
        </param>
        <briefdescription>
<para>Determine the next internal timeout that libusb needs to handle. </para>        </briefdescription>
        <detaileddescription>
<para>You only need to use this function if you are calling poll() or select() or similar on libusb&apos;s file descriptors yourself - you do not need to use it if you are calling <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref> or a variant directly.</para><para>You should call this function in your main loop in order to determine how long to wait for select() or poll() to return results. libusb needs to be called into at this timeout, so you should use it as an upper bound on your select() or poll() call.</para><para>When the timeout has expired, call into <ref refid="group__libusb__poll_1ga6deff4c7d3a6c04bb9ec9fd259b48933" kindref="member">libusb_handle_events_timeout()</ref> (perhaps in non-blocking mode) so that libusb can handle the timeout.</para><para>This function may return 1 (success) and an all-zero timeval. If this is the case, it indicates that libusb has a timeout that has already expired so you should call <ref refid="group__libusb__poll_1ga6deff4c7d3a6c04bb9ec9fd259b48933" kindref="member">libusb_handle_events_timeout()</ref> or similar immediately. A return code of 0 indicates that there are no pending timeouts.</para><para>On some platforms, this function will always returns 0 (no pending timeouts). See <ref refid="group__libusb__poll_1polltime" kindref="member">Notes on time-based events</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tv</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for a relative time against the current clock in which libusb must be called into in order to process timeout events </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 if there are no pending timeouts, 1 if a timeout was returned, or LIBUSB_ERROR_OTHER on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1826" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2547" bodyend="2602"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga54c27dcf8a95d2a3a03cfb7dd37eae63" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>const struct <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> **</type>
        <definition>const struct libusb_pollfd** libusb_get_pollfds</definition>
        <argsstring>(libusb_context *ctx)</argsstring>
        <name>libusb_get_pollfds</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <briefdescription>
<para>Retrieve a list of file descriptors that should be polled by your main loop as libusb event sources. </para>        </briefdescription>
        <detaileddescription>
<para>The returned list is NULL-terminated and should be freed with <ref refid="group__libusb__poll_1gad703b12ab275b6420c2c27e6279c955f" kindref="member">libusb_free_pollfds()</ref> when done. The actual list contents must not be touched.</para><para>As file descriptors are a Unix-specific concept, this function is not available on Windows and will always return NULL.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a NULL-terminated list of <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> structures </para></simplesect>
<simplesect kind="return"><para>NULL on error </para></simplesect>
<simplesect kind="return"><para>NULL on platforms where the functionality is not available </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1867" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2719" bodyend="2746"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1gad703b12ab275b6420c2c27e6279c955f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_free_pollfds</definition>
        <argsstring>(const struct libusb_pollfd **pollfds)</argsstring>
        <name>libusb_free_pollfds</name>
        <param>
          <type>const struct <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> **</type>
          <declname>pollfds</declname>
        </param>
        <briefdescription>
<para>Free a list of <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> structures. </para>        </briefdescription>
        <detaileddescription>
<para>This should be called for all pollfd lists allocated with <ref refid="group__libusb__poll_1ga54c27dcf8a95d2a3a03cfb7dd37eae63" kindref="member">libusb_get_pollfds()</ref>.</para><para>Since version 1.0.20, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000104</para><para>It is legal to call this function with a NULL pollfd list. In this case, the function will simply return safely.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>pollfds</parametername>
</parameternamelist>
<parameterdescription>
<para>the list of <ref refid="structlibusb__pollfd" kindref="compound">libusb_pollfd</ref> structures to free </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1869" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2759" bodyend="2765"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__poll_1ga1b7b2deb193f2e9ffda5e727361d7e67" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_set_pollfd_notifiers</definition>
        <argsstring>(libusb_context *ctx, libusb_pollfd_added_cb added_cb, libusb_pollfd_removed_cb removed_cb, void *user_data)</argsstring>
        <name>libusb_set_pollfd_notifiers</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__poll_1ga2962a11284b09a3f18936d8f73a43804" kindref="member">libusb_pollfd_added_cb</ref></type>
          <declname>added_cb</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__poll_1ga32aa803f54cfb5bfe8b41747e6b62af5" kindref="member">libusb_pollfd_removed_cb</ref></type>
          <declname>removed_cb</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user_data</declname>
        </param>
        <briefdescription>
<para>Register notification functions for file descriptor additions/removals. </para>        </briefdescription>
        <detaileddescription>
<para>These functions will be invoked for every new or removed file descriptor that libusb uses as an event source.</para><para>To remove notifiers, pass NULL values for the function pointers.</para><para>Note that file descriptors may have been added even before you register these notifiers (e.g. at <ref refid="group__libusb__lib_1ga9517c37281bba0b51cc62eba728be48b" kindref="member">libusb_init()</ref> time).</para><para>Additionally, note that the removal notifier may be called during <ref refid="group__libusb__lib_1ga86532f222d4f1332a5f8f5eef9a92da9" kindref="member">libusb_exit()</ref> (e.g. when it is closing file descriptors that were opened and added to the poll set at <ref refid="group__libusb__lib_1ga9517c37281bba0b51cc62eba728be48b" kindref="member">libusb_init()</ref> time). If you don&apos;t want this, remove the notifiers immediately before calling <ref refid="group__libusb__lib_1ga86532f222d4f1332a5f8f5eef9a92da9" kindref="member">libusb_exit()</ref>.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>the context to operate on, or NULL for the default context </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>added_cb</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to function for addition notifications </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>removed_cb</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to function for removal notifications </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>User data to be passed back to callbacks (useful for passing context information) </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1870" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/io.c" bodystart="2625" bodyend="2633"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__hotplug_1ga00e0c69ddf1fb1b6774dc918192e8dc7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_hotplug_register_callback</definition>
        <argsstring>(libusb_context *ctx, libusb_hotplug_event events, libusb_hotplug_flag flags, int vendor_id, int product_id, int dev_class, libusb_hotplug_callback_fn cb_fn, void *user_data, libusb_hotplug_callback_handle *callback_handle)</argsstring>
        <name>libusb_hotplug_register_callback</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__hotplug_1ga556d598ca379618a41bbec3597f55dcf" kindref="member">libusb_hotplug_event</ref></type>
          <declname>events</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__hotplug_1ga95ce2ec85dec177854c423cea2853c52" kindref="member">libusb_hotplug_flag</ref></type>
          <declname>flags</declname>
        </param>
        <param>
          <type>int</type>
          <declname>vendor_id</declname>
        </param>
        <param>
          <type>int</type>
          <declname>product_id</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dev_class</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__hotplug_1ga3d45c3fdf4d2e47a007fe2d9463b3f7f" kindref="member">libusb_hotplug_callback_fn</ref></type>
          <declname>cb_fn</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>user_data</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__hotplug_1ga4868157346bbf2c70b6af0cb0a6c0094" kindref="member">libusb_hotplug_callback_handle</ref> *</type>
          <declname>callback_handle</declname>
        </param>
        <briefdescription>
<para>Register a hotplug callback function. </para>        </briefdescription>
        <detaileddescription>
<para>Register a callback with the libusb_context. The callback will fire when a matching event occurs on a matching device. The callback is armed until either it is deregistered with <ref refid="group__libusb__hotplug_1ga8110f57eab2064375934f1449b2602bc" kindref="member">libusb_hotplug_deregister_callback()</ref> or the supplied callback returns 1 to indicate it is finished processing events.</para><para>If the <ref refid="group__libusb__hotplug_1gga95ce2ec85dec177854c423cea2853c52a01a1c0c9f4e6852cb6df713f2e8a7f6b" kindref="member">LIBUSB_HOTPLUG_ENUMERATE</ref> is passed the callback will be called with a <ref refid="group__libusb__hotplug_1gga556d598ca379618a41bbec3597f55dcfac012270cba6e08dafe7e3bec204dffd6" kindref="member">LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED</ref> for all devices already plugged into the machine. Note that libusb modifies its internal device list from a separate thread, while calling hotplug callbacks from <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref>, so it is possible for a device to already be present on, or removed from, its internal device list, while the hotplug callbacks still need to be dispatched. This means that when using <ref refid="group__libusb__hotplug_1gga95ce2ec85dec177854c423cea2853c52a01a1c0c9f4e6852cb6df713f2e8a7f6b" kindref="member">LIBUSB_HOTPLUG_ENUMERATE</ref>, your callback may be called twice for the arrival of the same device, once from <ref refid="group__libusb__hotplug_1ga00e0c69ddf1fb1b6774dc918192e8dc7" kindref="member">libusb_hotplug_register_callback()</ref> and once from <ref refid="group__libusb__poll_1ga4989086e3f0327f3886a4c474ec7c327" kindref="member">libusb_handle_events()</ref>; and/or your callback may be called for the removal of a device for which an arrived call was never made.</para><para>Since version 1.0.16, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000102</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>context to register this callback with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">events</parametername>
</parameternamelist>
<parameterdescription>
<para>bitwise or of events that will trigger this callback. See <ref refid="group__libusb__hotplug_1ga556d598ca379618a41bbec3597f55dcf" kindref="member">libusb_hotplug_event</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">flags</parametername>
</parameternamelist>
<parameterdescription>
<para>hotplug callback flags. See <ref refid="group__libusb__hotplug_1ga95ce2ec85dec177854c423cea2853c52" kindref="member">libusb_hotplug_flag</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">vendor_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the vendor id to match or <ref refid="group__libusb__hotplug_1ga6d4f5e524a3b7ab4a25b751073335d4c" kindref="member">LIBUSB_HOTPLUG_MATCH_ANY</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">product_id</parametername>
</parameternamelist>
<parameterdescription>
<para>the product id to match or <ref refid="group__libusb__hotplug_1ga6d4f5e524a3b7ab4a25b751073335d4c" kindref="member">LIBUSB_HOTPLUG_MATCH_ANY</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">dev_class</parametername>
</parameternamelist>
<parameterdescription>
<para>the device class to match or <ref refid="group__libusb__hotplug_1ga6d4f5e524a3b7ab4a25b751073335d4c" kindref="member">LIBUSB_HOTPLUG_MATCH_ANY</ref> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">cb_fn</parametername>
</parameternamelist>
<parameterdescription>
<para>the function to be invoked on a matching event/device </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">user_data</parametername>
</parameternamelist>
<parameterdescription>
<para>user data to pass to the callback function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">callback_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to store the handle of the allocated callback (can be NULL) </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>LIBUSB_SUCCESS on success LIBUSB_ERROR code on failure </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="1981" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/hotplug.c" bodystart="237" bodyend="312"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__hotplug_1ga8110f57eab2064375934f1449b2602bc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void libusb_hotplug_deregister_callback</definition>
        <argsstring>(libusb_context *ctx, libusb_hotplug_callback_handle callback_handle)</argsstring>
        <name>libusb_hotplug_deregister_callback</name>
        <param>
          <type><ref refid="group__libusb__lib_1ga4ec088aa7b79c4a9599e39bf36a72833" kindref="member">libusb_context</ref> *</type>
          <declname>ctx</declname>
        </param>
        <param>
          <type><ref refid="group__libusb__hotplug_1ga4868157346bbf2c70b6af0cb0a6c0094" kindref="member">libusb_hotplug_callback_handle</ref></type>
          <declname>callback_handle</declname>
        </param>
        <briefdescription>
<para>Deregisters a hotplug callback. </para>        </briefdescription>
        <detaileddescription>
<para>Deregister a callback from a libusb_context. This function is safe to call from within a hotplug callback.</para><para>Since version 1.0.16, <ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000102</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">ctx</parametername>
</parameternamelist>
<parameterdescription>
<para>context this callback is registered with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">callback_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>the handle of the callback to deregister </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h" line="2001" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/hotplug.c" bodystart="314" bodyend="337"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/libusb.h"/>
  </compounddef>
</doxygen>
