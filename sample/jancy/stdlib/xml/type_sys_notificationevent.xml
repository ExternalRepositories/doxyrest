<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='class' id='type_sys_notificationevent' language='Jancy'>
<compoundname>NotificationEvent</compoundname>

<sectiondef>
<memberdef kind='function' id='function_sys_notificationevent_construct'>
<functionkind>construct</functionkind>
<name>construct</name>
<type>void</type>
<argsstring>(sys.NotificationEvent safe* this)</argsstring>
<location file='sys_NotificationEvent.jnc' line='73' col='2'/>
</memberdef>
<memberdef kind='function' id='function_sys_notificationevent_destruct'>
<functionkind>destruct</functionkind>
<name>destruct</name>
<type>void</type>
<argsstring>(sys.NotificationEvent safe* this)</argsstring>
<location file='sys_NotificationEvent.jnc' line='74' col='2'/>
</memberdef>
</sectiondef>

<sectiondef>
<memberdef kind='function' id='function_sys_notificationevent_signal'>
<functionkind>named-function</functionkind>
<name>signal</name>
<type>void</type>
<argsstring>(sys.NotificationEvent safe* this)</argsstring>
<detaileddescription>
<para>Sets event to *signalled* state. All the waiting threads wake up, the event remains in *signalled* state.</para>
</detaileddescription>
<location file='sys_NotificationEvent.jnc' line='80' col='2'/>
</memberdef>

<memberdef kind='function' id='function_sys_notificationevent_reset'>
<functionkind>named-function</functionkind>
<name>reset</name>
<type>void</type>
<argsstring>(sys.NotificationEvent safe* this)</argsstring>
<detaileddescription>
<para>Returns event to *idle* state.</para>
</detaileddescription>
<location file='sys_NotificationEvent.jnc' line='86' col='2'/>
</memberdef>

<memberdef kind='function' id='function_sys_notificationevent_wait'>
<functionkind>named-function</functionkind>
<name>wait</name>
<type>bool</type>
<argsstring>(sys.NotificationEvent safe* this, uint_t timeout - 1)</argsstring>
<param>
<declname>timeout</declname>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<array></array>
<defval>- 1</defval>
</param>
<detaileddescription>
<para>Waits until event goes to *signalled* state. When it happens, ``wait`` returns ``true`` but the event remains in *signalled* state.

If ``timeout`` parameter is not ``-1`` then it's a wait with a *time limit*. If the event does not get signalled until timeout expires, ``wait`` return ``false``. Timeout is expressed in *milliseconds*.</para>
</detaileddescription>
<location file='sys_NotificationEvent.jnc' line='94' col='7'/>
</memberdef>

</sectiondef>
<includes>sys_NotificationEvent.jnc</includes>
<briefdescription><para>This class provides standard means of synchronization between threads.</para></briefdescription>
<detaileddescription>
<para>Any object of this class can be in one of the following two states: *idle* or *signalled*. One or more threads can wait until the event becomes signalled by invoking ``wait`` method. When some other thread signals the event by invoking ``signal`` method, *all* the waiging threads wake up, and the event remains in *signalled* state.

To return event to *idle* state, use ``reset`` method.

Code sample::

	import "sys_NotificationEvent.jnc"

	sys.NotificationEvent g_event;

	thread1 ()
	{
		// ...

		g_event.wait (); // thread sleeps here until event is signalled

		// continue...
	}

	thread2 ()
	{
		// ...

		g_event.wait (); // thread sleeps here until event is signalled

		// continue...
	}

	thread3 ()
	{
		// ...

		g_event.signal (); // thread1 and thread2 wake up and continue, g_event is still signalled

		// ...
		// if any other thread issues g_event.wait (), it will be satisfied immediatly

		g_event.reset (); // not signalled anymore
	}</para>
<para><simplesect kind='see'><para>`sys.Event`, `sys.Lock`, `sys.Thread`</para></simplesect></para>
</detaileddescription>
<location file='sys_NotificationEvent.jnc' line='71' col='14'/>
</compounddef>
</doxygen>
