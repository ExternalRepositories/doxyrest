<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen>
<compounddef kind='namespace' id='namespace_io' language='Jancy'>
<compoundname>io</compoundname>
<innerclass refid='type_io_socketeventparams'/>
<innerclass refid='type_io_socket'/>
<innerclass refid='type_io_address_ip4'/>
<innerclass refid='type_io_address_ip6'/>
<innerclass refid='type_io_socketaddress_ip4'/>
<innerclass refid='type_io_socketaddress_ip6'/>
<innerclass refid='type_io_socketaddress'/>
<innerclass refid='type_io_mailsloteventparams'/>
<innerclass refid='type_io_mailslot'/>
<innerclass refid='type_io_namedpipe'/>
<innerclass refid='type_io_mappedfile'/>
<innerclass refid='type_io_networkadapteraddress'/>
<innerclass refid='type_io_networkadapterdesc'/>
<innerclass refid='type_io_file'/>
<innerclass refid='type_io_socketaddressresolvereventparams'/>
<innerclass refid='type_io_socketaddressresolver'/>
<innerclass refid='type_io_filestreameventparams'/>
<innerclass refid='type_io_filestream'/>
<innerclass refid='type_io_serialeventparams'/>
<innerclass refid='type_io_serial'/>
<innerclass refid='type_io_serialportdesc'/>
<innerclass refid='type_io_ssheventparams'/>
<innerclass refid='type_io_sshchannel'/>
<innerclass refid='type_io_pcapeventparams'/>
<innerclass refid='type_io_pcap'/>
<innerclass refid='type_io_pcapaddress'/>
<innerclass refid='type_io_pcapdevicedesc'/>
<innerclass refid='type_io_usbendpointdesc'/>
<innerclass refid='type_io_usbinterfacedesc'/>
<innerclass refid='type_io_usbconfigurationdesc'/>
<innerclass refid='type_io_usbdevicedesc'/>
<innerclass refid='type_io_usbendpointeventparams'/>
<innerclass refid='type_io_usbendpoint'/>
<innerclass refid='type_io_usbinterface'/>
<innerclass refid='type_io_usbdevice'/>
<sectiondef>
<memberdef kind='enum' id='type_io_socketeventcode'>
<name>SocketEventCode</name>
<enumvalue id='enum_member_io_socketeventcode_connectcompleted'>
<name>ConnectCompleted</name>
<detaileddescription>
<para>Connection request completed successfully.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketeventcode_connectcancelled'>
<name>ConnectCancelled</name>
<detaileddescription>
<para>Connection request cancelled by `io.Socket.close` call.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketeventcode_connecterror'>
<name>ConnectError</name>
<detaileddescription>
<para>Connection request failed; detailed information about the error is available at: `io.SocketEventParams.m_error`.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketeventcode_disconnected'>
<name>Disconnected</name>
<detaileddescription>
<para>Connection has been terminated by the remote node. `io.SocketEventParams.m_flags` contains additional information about disconnect type. Note that if connection was terminated by the local node (using `io.Socket.close`), ``Disconnect`` event is **not** fired.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketeventcode_incomingdata'>
<name>IncomingData</name>
<detaileddescription>
<para>More data is available on the socket; this data could be fetched with `io.Socket.recv` or `io.Socket.recvFrom` methods.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketeventcode_incomingconnection'>
<name>IncomingConnection</name>
<detaileddescription>
<para>New incoming client connection is pending on the listening server socket. The new client can be accepted using `io.Socket.accept` method (to reject the connection you still have to accept it first, and then close it)</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketeventcode_transmitbufferready'>
<name>TransmitBufferReady</name>
<detaileddescription>
<para>Socket transmit buffer is ready to accept more data; it's OK to issue more `io.Socket.send` requests. Note that this event is not supposed to be used with datagram sockets.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_Socket.jnc</includes>
<briefdescription><para>This enumeration contains codes of all possible events that might happen on `io.Socket` object.</para></briefdescription>
<detaileddescription>
<para>When `io.Socket` object is about to fire an event, it allocates an `io.SocketEventParams` structure, sets `io.SocketEventParams.m_eventCode` field to one of the values below, fills other relevant fields of and then calls all subscribers of `io.Socket.m_onSocketEvent`.</para>
<para><simplesect kind='see'><para>`io.Socket`, `io.SocketEventParams`</para></simplesect></para>
</detaileddescription>
<location file='io_Socket.jnc' line='32' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_socketdisconnecteventflags'>
<name>SocketDisconnectEventFlags</name>
<modifiers>bitflag</modifiers>
<enumvalue id='enum_member_io_socketdisconnecteventflags_reset'>
<name>Reset</name>
<detaileddescription>
<para>Connection was terminated abruptly (by a ``RST`` packet) rather than gracefully (with a ``FIN-ACK-FIN-ACK`` sequence)</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_Socket.jnc</includes>
<briefdescription><para>This enumeration lists all possible values for `io.SocketEventParams.m_flags` when `io.SocketEventParams.m_eventCode` equals `io.SocketEventCode.Disconnected`.</para></briefdescription>
<detaileddescription>
<para>Currently only one flag ``Reset`` is supported -- it is used to distinguish between different disconnect types.</para>
<para><simplesect kind='see'><para>`io.SocketEventParams`, `io.SocketEventCode`</para></simplesect></para>
</detaileddescription>
<location file='io_Socket.jnc' line='90' col='14'/>
</memberdef>

<memberdef kind='enum' id='type_io_socketclosekind'>
<name>SocketCloseKind</name>
<enumvalue id='enum_member_io_socketclosekind_reset'>
<name>Reset</name>
<initializer>= 0</initializer>
<detaileddescription>
<para>Send ``RST`` packet and drop the connection abruptly.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketclosekind_graceful'>
<name>Graceful</name>
<detaileddescription>
<para>Follow the controlled disconnect sequence which starts with disconnect initiator issuing a ``FIN`` packet (``FIN-ACK-FIN-ACK``).</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_Socket.jnc</includes>
<briefdescription><para>This enumeration lists options for ``TCP`` socket disconnect type.</para></briefdescription>
<detaileddescription>
<para>``TCP`` socket could be closed using either of the below ways.</para>
</detaileddescription>
<location file='io_Socket.jnc' line='154' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_socketopenflags'>
<name>SocketOpenFlags</name>
<modifiers>bitflag</modifiers>
<enumvalue id='enum_member_io_socketopenflags_raw'>
<name>Raw</name>
<detaileddescription>
<para>Opens a ``RAW`` socket (i.e a socket which allows direct access to transport- and network- layer headers of ``IP``-packets). Internally maps to ``IPPROTO_RAW`` protocol.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketopenflags_asynchronous'>
<name>Asynchronous</name>
<detaileddescription>
<para>Opens an asynchronous socket. Asynchronous sockets notify subscribers about asynhronous events (such as completions of pending operations) via `io.Socket.m_onSocketEvent`, while methods of synchronous sockets wait until pending operations complete and only then return. Also, asynchronous sockets create a dedicated IO thread upon socket open while synchronous sockets do not use any dedicated IO threads.

By default sockets are opened in synchronous mode.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketopenflags_reuseaddress'>
<name>ReuseAddress</name>
<detaileddescription>
<para>Allow binding multiple sockets to the same local address (unless a socket is already bound to the same address and this socket did *not* use ``ReuseAddress``). Internally maps to ``SO_REUSEADDR`` socket option.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_Socket.jnc</includes>
<detaileddescription>
<para>This enumeration lists all possible flag options for `io.Socket.open` method.</para>
<para><simplesect kind='see'><para>`io.Socket`</para></simplesect></para>
</detaileddescription>
<location file='io_Socket.jnc' line='181' col='14'/>
</memberdef>

<memberdef kind='enum' id='type_io_addressfamily'>
<name>AddressFamily</name>
<enumvalue id='enum_member_io_addressfamily_undefined'>
<name>Undefined</name>
<initializer>= 0</initializer>
<detaileddescription>
<para>Used to designate an uninitialized value.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_addressfamily_ip4'>
<name>Ip4</name>
<initializer>= 2</initializer>
<detaileddescription>
<para>Specifies ``IP4``-address; maps to ``AF_INET`` platform constant.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_addressfamily_ip6'>
<name>Ip6</name>
<detaileddescription>
<para>Specifies ``IP6``-address; maps to ``AF_INET6`` platform constant.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_SocketAddress.jnc</includes>
<briefdescription><para>This enumeration contains possible values for socket address types (families).</para></briefdescription>
<detaileddescription>
<para>``io.AddressFamily`` values map to ``AF_XXX`` platform constants. At the moment, only ``IP4`` and ``IP6`` address families are supported.</para>
<para><simplesect kind='see'><para>`io.SocketAddress`</para></simplesect></para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='30' col='21'/>
</memberdef>

<memberdef kind='enum' id='type_io_protocol'>
<name>Protocol</name>
<enumvalue id='enum_member_io_protocol_icmp'>
<name>Icmp</name>
<initializer>= 1</initializer>
<detaileddescription>
<para>``ICMP`` protocol; maps to ``IPPROTO_ICMP`` platform constant.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_protocol_tcp'>
<name>Tcp</name>
<initializer>= 6</initializer>
<detaileddescription>
<para>``TCP`` protocol; maps to ``IPPROTO_TCP`` platform constant.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_protocol_udp'>
<name>Udp</name>
<initializer>= 17</initializer>
<detaileddescription>
<para>``UDP`` protocol; maps to ``IPPROTO_UDP`` platform constant.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_SocketAddress.jnc</includes>
<briefdescription><para>This enumeration contains all possible values for network protocols that can be used with sockets.</para></briefdescription>
<detaileddescription>
<para>When opening a socket using `io.Socket.open` method you have to specify the protocol to use (all overloads of `io.Socket.open` methods require a ``protocol`` argument).</para>
<para><simplesect kind='see'><para>`io.Socket`</para></simplesect></para>
</detaileddescription>
<location file='io_SocketAddress.jnc' line='58' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_mailsloteventcode'>
<name>MailslotEventCode</name>
<enumvalue id='enum_member_io_mailsloteventcode_incomingdata'>
<name>IncomingData</name>
<detaileddescription>
<para>More data is available on the mailslot; this data could be fetched with `io.Mailslot.read` method.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_mailsloteventcode_ioerror'>
<name>IoError</name>
<detaileddescription>
<para>An IO error occured on the mailslot; detailed information about the error is available at `io.MailslotEventParams.m_error`.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_Mailslot.jnc</includes>
<briefdescription><para>This enumeration contains codes of all possible events that might happen on `io.Mailslot` object.</para></briefdescription>
<detaileddescription>
<para>When `io.Mailslot` object is about to fire an event, it allocates an `io.MailslotEventParams` structure, sets `io.MailslotEventParams.m_eventCode` field to one of the values below, fills other relevant fields of and then calls all subscribers of `io.Mailslot.m_onMailslotEvent`.</para>
<para><simplesect kind='see'><para>`io.Mailslot`, `io.MailslotEventParams`</para></simplesect></para>
</detaileddescription>
<location file='io_Mailslot.jnc' line='30' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_networkadaptertype'>
<name>NetworkAdapterType</name>
<enumvalue id='enum_member_io_networkadaptertype_unknown'>
<name>Unknown</name>
<initializer>= 0</initializer>
<detaileddescription>
<para>Denotes uninitialized value (or undetected type of the network adapter)</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadaptertype_loopback'>
<name>Loopback</name>
<detaileddescription>
<para>Software loopback network interface.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadaptertype_ethernet'>
<name>Ethernet</name>
<detaileddescription>
<para>Ethernet network interface.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadaptertype_wireless'>
<name>Wireless</name>
<detaileddescription>
<para>``IEEE 802.11`` wireless network interface.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadaptertype_ppp'>
<name>Ppp</name>
<detaileddescription>
<para>``PPP`` (point-to-point) network interface.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadaptertype_tokenring'>
<name>TokenRing</name>
<detaileddescription>
<para>Token ring network interface.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadaptertype_slip'>
<name>Slip</name>
<detaileddescription>
<para>``SLIP`` (serial-line-internet-protocol) network interface.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadaptertype_tunnel'>
<name>Tunnel</name>
<detaileddescription>
<para>Tunnel type encapsulation network interface.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadaptertype__count'>
<name>_Count</name>
<detaileddescription>
<para><![CDATA[Not really a type of interface; rather, this is a convenience constant denoting the total count  of adapter types. Should you need a table indexed by adapter type, you could write something like::

	char const* getNetworkAdapterTypeString (io.NetworkAdapterType type)
	{
		static char const stringTable [io.NetworkAdapterType._Count] =
		{
			"<unknown>",
			"loopback",
			// ...
		}

		return stringTable [type];
	}]]></para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_NetworkAdapter.jnc</includes>
<briefdescription><para>This enumeration specifies available types of the network adapter.</para></briefdescription>
<detaileddescription>
<para>When enumerating available network adapter you first call `io.createNetworkAdapterDescList`, then iterate through the resulting list of `io.NetworkAdapterDesc` structures, each contains its type information `io.NetworkAdapterDesc.m_type` field.</para>
</detaileddescription>
<location file='io_NetworkAdapter.jnc' line='28' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_networkadapterflags'>
<name>NetworkAdapterFlags</name>
<modifiers>bitflag</modifiers>
<enumvalue id='enum_member_io_networkadapterflags_dhcp'>
<name>Dhcp</name>
<detaileddescription>
<para>``DHCP`` (Dynamic Host Configuration Protocol) is enabled on this adapter.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadapterflags_ddns'>
<name>Ddns</name>
<detaileddescription>
<para>``DDNS`` (Dynamic DNS) is enabled on this adapter.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadapterflags_broadcast'>
<name>Broadcast</name>
<detaileddescription>
<para>This adapter supports broadcast.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadapterflags_multicast'>
<name>Multicast</name>
<detaileddescription>
<para>This adapter supports multicast.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadapterflags_ip4'>
<name>Ip4</name>
<detaileddescription>
<para>``IPv4`` is enabled on this adapter.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_networkadapterflags_ip6'>
<name>Ip6</name>
<detaileddescription>
<para>``IPv6`` is enabled on this adapter.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_NetworkAdapter.jnc</includes>
<briefdescription><para>This enumeration specifies flag properties of the network adapter.</para></briefdescription>
<detaileddescription>
<para>When enumerating available network adapter you first call `io.createNetworkAdapterDescList`, then iterate through the resulting list of `io.NetworkAdapterDesc` structures, each contains a set of flag properties in `io.NetworkAdapterDesc.m_flags` field.</para>
<para><simplesect kind='see'><para>`io.createNetworkAdapterDescList`, `io.NetworkAdapterDesc`</para></simplesect></para>
</detaileddescription>
<location file='io_NetworkAdapter.jnc' line='94' col='14'/>
</memberdef>

<memberdef kind='function' id='function_io_createnetworkadapterdesclist'>
<functionkind>named-function</functionkind>
<name>createNetworkAdapterDescList</name>
<type><ref refid="type_io_networkadapterdesc">io.NetworkAdapterDesc</ref> const*</type>
<argsstring>(size_t* adapterCount null, size_t* addressCount null)</argsstring>
<param>
<declname>adapterCount</declname>
<type><ref refid="typedef_size_t">size_t</ref>*</type>
<array></array>
<defval>null</defval>
</param>
<param>
<declname>addressCount</declname>
<type><ref refid="typedef_size_t">size_t</ref>*</type>
<array></array>
<defval>null</defval>
</param>
<detaileddescription>
<para>Enumerates all available network adapters on the system.

``count`` argument can be used to obtain the total number of devices in the resulting list.

Returns a pointer to the very first `io.NetworkAdapterDesc` in the resulting list. You can walk through the list by inspecting `io.NetworkAdapterDesc.m_next` field:

.. ref-code-block::

	`io.NetworkAdapterDesc` const* adapterDesc = io.createNetworkAdapterDescList ();
	for (; adapterDesc; adapterDesc = adapterDesc.m_next)
	{
		// add adapter to the combo box...
	}</para>
</detaileddescription>
<location file='io_NetworkAdapter.jnc' line='238' col='27'/>
</memberdef>

<memberdef kind='enum' id='type_io_fileopenflags'>
<name>FileOpenFlags</name>
<modifiers>bitflag</modifiers>
<enumvalue id='enum_member_io_fileopenflags_readonly'>
<name>ReadOnly</name>
<detaileddescription>
<para>File or device should be opened in read-only mode. When file is opened in read-only mode, trying to perform modifying operations such as calling ``write`` method or changing the file size via ``m_size`` property will fail with ``access violation`` system error.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_fileopenflags_writeonly'>
<name>WriteOnly</name>
<detaileddescription>
<para>File or device should be opened in write-only mode. When file is opened in read-only mode, calling ``read`` method fail with ``access violation`` system error.

Note that certain files and devices could *only* be opened in write-only mode (e.g., client mailslot files on Windows)</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_fileopenflags_openexisting'>
<name>OpenExisting</name>
<detaileddescription>
<para>Do not try to create a file if it does not exist.

If file specified by ``name`` argument to ``open`` method does not exist, ``open`` method should fail rather than try to create a new empty file with such a name (which would be the default option).</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_fileopenflags_exclusive'>
<name>Exclusive</name>
<detaileddescription>
<para>Open a file or device in exclusive mode. If another thread or process simultaneously tries to open the same file -- no matter if it specifies read-write, read-only or write-only modes -- it will fail with ``access violation`` system error.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_fileopenflags_sharewrite'>
<name>ShareWrite</name>
<detaileddescription>
<para>Allow multiple threads or processes to open the same file for writing. This overrides the default behaviour -- normally, only one write-access handle to the file is allowed at the same time (subsequent attempts to open the file for writing will fail with ``access violation`` system error)</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_fileopenflags_deleteonclose'>
<name>DeleteOnClose</name>
<detaileddescription>
<para>File should be deleted as soon as the last handle to it is being closed.

Currently it only works nicely on Windows which natively provides support for this functionality via ``FILE_FLAG_DELETE_ON_CLOSE``. Current implementation for POSIX platforms simply calls ``unlink`` immediatly after open.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_File.jnc</includes>
<briefdescription><para>This enumeration specifies available options for opening `io.File`, `io.FileStream` or `io.MappedFile`.</para></briefdescription>
<detaileddescription>
<para>When opening files or devices with ``open`` method, the second argument ``flags`` can be used to adjust options.</para>
<para><simplesect kind='see'><para>`io.File`, `io.FileStream`, `io.MappedFile`</para></simplesect></para>
</detaileddescription>
<location file='io_File.jnc' line='30' col='14'/>
</memberdef>

<memberdef kind='enum' id='type_io_socketaddressresolvereventcode'>
<name>SocketAddressResolverEventCode</name>
<enumvalue id='enum_member_io_socketaddressresolvereventcode_resolvecompleted'>
<name>ResolveCompleted</name>
<detaileddescription>
<para>Hostname successfully resolved. Result address table is located at: `io.SocketAddressResolverEventParams.m_addressTable` (contains `io.SocketAddressResolverEventParams.m_addressCount` elements).</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketaddressresolvereventcode_resolvecancelled'>
<name>ResolveCancelled</name>
<detaileddescription>
<para>Hostname resolve request was cancelled (by `io.SocketAddressResolver.cancel` or `io.SocketAddressResolver.cancelAll` methods).</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_socketaddressresolvereventcode_resolveerror'>
<name>ResolveError</name>
<detaileddescription>
<para>Hostname could not be resolved. Detailed error information could be found at: `io.SocketAddressResolverEventParams.m_error`.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_SocketAddressResolver.jncx</includes>
<briefdescription><para>This enumeration contains codes of all possible events that might happen on `io.SocketAddressResolver` object.</para></briefdescription>
<detaileddescription>
<para>When `io.SocketAddressResolver` object is about to fire an event, it allocates an `io.SocketAddressResolverEventParams` structure, sets `io.SocketAddressResolverEventParams.m_eventCode` field to one of the values below, fills other relevant fields of and then calls all subscribers of `io.SocketAddressResolver.m_onResolverEvent`.</para>
<para><simplesect kind='see'><para>`io.SocketAddressResolver`, `io.SocketAddressResolverEventParams`</para></simplesect></para>
</detaileddescription>
<location file='io_SocketAddressResolver.jnc' line='32' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_filestreamkind'>
<name>FileStreamKind</name>
<enumvalue id='enum_member_io_filestreamkind_unknown'>
<name>Unknown</name>
<detaileddescription>
<para>Denotes undefined (or generic) file stream.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_filestreamkind_disk'>
<name>Disk</name>
<detaileddescription>
<para>The file stream represents a disk file.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_filestreamkind_serial'>
<name>Serial</name>
<detaileddescription>
<para>The file stream represents a serial port.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_filestreamkind_pipe'>
<name>Pipe</name>
<detaileddescription>
<para>The file stream represents a named pipe.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_FileStream.jnc</includes>
<briefdescription><para>This enumeration contains all possible values for the underlying type of of `io.FileStream` object.</para></briefdescription>
<detaileddescription>
<para>Currently, this functionality is only available on Windows (via WinAPI function ``GetFileType``).</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='30' col='6'/>
</memberdef>

<memberdef kind='function' id='function_io_getfilestreamkindstring'>
<functionkind>named-function</functionkind>
<name>getFileStreamKindString</name>
<type>char const*</type>
<argsstring>(io.FileStreamKind kind)</argsstring>
<param>
<declname>kind</declname>
<type><ref refid="type_io_filestreamkind">io.FileStreamKind</ref></type>
<array></array>
</param>
<detaileddescription>
<para>Returns string representation of the ``kind`` argument. In case ``kind`` does not correspond to any known file stream kind (e.g. you have casted a random integer number to `io.FileStreamKind` enumeration type), string ``unknown device`` is returned.</para>
</detaileddescription>
<location file='io_FileStream.jnc' line='56' col='13'/>
</memberdef>

<memberdef kind='enum' id='type_io_filestreameventcode'>
<name>FileStreamEventCode</name>
<enumvalue id='enum_member_io_filestreameventcode_eof'>
<name>Eof</name>
<detaileddescription>
<para>End-of-file was reached on the file stream.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_filestreameventcode_incomingdata'>
<name>IncomingData</name>
<detaileddescription>
<para>More data is available on the file stream; this data could be fetched with `io.FileStream.read` method.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_filestreameventcode_ioerror'>
<name>IoError</name>
<detaileddescription>
<para>An IO error occured on the file stream; detailed information about the error is available at `io.FileStreamEventParams.m_error`.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_filestreameventcode_transmitbufferready'>
<name>TransmitBufferReady</name>
<detaileddescription>
<para>File stream transmit buffer is ready to accept more data; it's OK to issue more `io.FileStream.write` requests.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_FileStream.jnc</includes>
<briefdescription><para>This enumeration contains codes of all possible events that might happen on `io.FileStream` object.</para></briefdescription>
<detaileddescription>
<para>When `io.FileStream` object is about to fire an event, it allocates an `io.FileStreamEventParams` structure, sets `io.FileStreamEventParams.m_eventCode` field to one of the values below, fills other relevant fields of and then calls all subscribers of `io.FileStream.m_onFileStreamEvent`.</para>
<para><simplesect kind='see'><para>`io.FileStream`, `io.FileStreamEventParams`</para></simplesect></para>
</detaileddescription>
<location file='io_FileStream.jnc' line='84' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_serialflowcontrol'>
<name>SerialFlowControl</name>
<enumvalue id='enum_member_io_serialflowcontrol_none'>
<name>None</name>
<initializer>= 0</initializer>
<detaileddescription>
<para>No flow control protocol is employed. If the receiving end is not capable of handling arriving data fast enough, the data is unconditionally lost.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialflowcontrol_rtscts'>
<name>RtsCts</name>
<detaileddescription>
<para>``RTS/CTS`` flow control (sometimes called **hardware** flow control). Remote side is only allowed to send the data if the ``RTS`` control line is ``high``; likewise, the local side should only send data when ``CTS`` status line is ``high``.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialflowcontrol_xonxoff'>
<name>XOnXOff</name>
<detaileddescription>
<para>``XON/XOFF`` flow control (sometimes called **software** flow control). In this protocol, two special charaters are selected as ``XON`` (``0x11``) and ``XOFF`` (``0x13``). Note that current implementation of ``io.Serial`` class does not allow overriding these values.

If a side of transmission detects ``XOFF`` character in input stream, this side should suspend the transmission until it sees ``XON`` character; at which moment the transmission may be resumed.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_Serial.jnc</includes>
<briefdescription><para>This enumeration specifies all possible values for the serial flow control setting.</para></briefdescription>
<detaileddescription>
<para>Flow control is the protocol of attempted prevention of data loss during serial transmission which may happen when transmission side sends data faster than the receiving side is able to process it.

To adjust the flow control protocol, modify `io.Serial.m_flowControl` property at any time (both pre-open and post-open modifications are supported).</para>
<para><simplesect kind='see'><para>`io.Serial`</para></simplesect></para>
</detaileddescription>
<location file='io_Serial.jnc' line='32' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_serialstopbits'>
<name>SerialStopBits</name>
<enumvalue id='enum_member_io_serialstopbits__1'>
<name>_1</name>
<initializer>= 0</initializer>
<detaileddescription>
<para>One stop bit.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialstopbits__15'>
<name>_15</name>
<initializer>= 1</initializer>
<detaileddescription>
<para>One and a half stop bit (1.5 bit duration).</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialstopbits__2'>
<name>_2</name>
<initializer>= 2</initializer>
<detaileddescription>
<para>Two stop bits.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_Serial.jnc</includes>
<briefdescription><para>This enumeration lists all possible values for stop bits setting of the serial port.</para></briefdescription>
<detaileddescription>
<para>Stop bits are auxillary (non-data) bits sent at the end of each character to re-synchronize the receiver; normally 1 stop bit is used.</para>
</detaileddescription>
<location file='io_Serial.jnc' line='66' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_serialparity'>
<name>SerialParity</name>
<enumvalue id='enum_member_io_serialparity_none'>
<name>None</name>
<initializer>= 0</initializer>
<detaileddescription>
<para>No parity bit is sent alongside the data.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialparity_odd'>
<name>Odd</name>
<detaileddescription>
<para>A parity bit is sent; **odd** parity check is used (total number of ones including data and parity bit should be *odd*).</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialparity_even'>
<name>Even</name>
<detaileddescription>
<para>A parity bit is sent; **even** parity check is used (total number of ones including data and parity bit should be *odd*).</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialparity_mark'>
<name>Mark</name>
<detaileddescription>
<para>A parity bit is sent; parity bit should always be set to ``1``.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialparity_space'>
<name>Space</name>
<detaileddescription>
<para>A parity bit is sent; parity bit should always be set to ``0``.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_Serial.jnc</includes>
<briefdescription><para>This enumeration specifies all possible values for the serial parity bit setting.</para></briefdescription>
<detaileddescription>
<para>Serial parity bit is an extra bit transmitted alongside the data so that the total number of one's including data bits *and* this parity bit is always *odd* or always *even*.

This is a rather weak error detection method as it does not detect data corruption if an *even* number of bits are altered. Usually it's much more reliable to employ other checksums/hash checks after the data has been transmitted.

To adjust the parity protocol, modify `io.Serial.m_parity` property at any time (both pre-open and post-open modifications are supported).</para>
<para><simplesect kind='see'><para>`io.Serial`</para></simplesect></para>
</detaileddescription>
<location file='io_Serial.jnc' line='98' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_serialstatuslines'>
<name>SerialStatusLines</name>
<modifiers>bitflag</modifiers>
<enumvalue id='enum_member_io_serialstatuslines_cts'>
<name>Cts</name>
<detaileddescription>
<para>``CTS`` status line (clear-to-send).</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialstatuslines_dsr'>
<name>Dsr</name>
<detaileddescription>
<para>``DSR`` status line (data-source-ready)</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialstatuslines_ring'>
<name>Ring</name>
<detaileddescription>
<para>``RING`` status line (ring-indicator)</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialstatuslines_dcd'>
<name>Dcd</name>
<detaileddescription>
<para>``DCD`` status line (device-carrier-detect)</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_Serial.jnc</includes>
<briefdescription><para>This enumeration lists all possible status lines on the serial port.</para></briefdescription>
<detaileddescription>
<para>You can read values of all the status lines at once by accessing `io.Serial.m_statusLines` property. You also get all the values of *changed* status lines in `io.SerialEventParams.m_lines`.</para>
<para><simplesect kind='see'><para>`io.Serial`</para></simplesect></para>
</detaileddescription>
<location file='io_Serial.jnc' line='144' col='14'/>
</memberdef>

<memberdef kind='enum' id='type_io_serialeventcode'>
<name>SerialEventCode</name>
<enumvalue id='enum_member_io_serialeventcode_incomingdata'>
<name>IncomingData</name>
<detaileddescription>
<para>More data is available on the serial port; this data could be fetched with `io.Serial.read` method.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialeventcode_ioerror'>
<name>IoError</name>
<detaileddescription>
<para>An IO error occured on the serial port; detailed information about the error is available at `io.SerialEventParams.m_error`.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialeventcode_transmitbufferready'>
<name>TransmitBufferReady</name>
<detaileddescription>
<para>Serial port transmit buffer is ready to accept more data; it's OK to issue more `io.Serial.write` requests.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_serialeventcode_statuslinechanged'>
<name>StatusLineChanged</name>
<detaileddescription>
<para>One or more serial status lines has changed. All the information about the change is contained in event params structure. `io.SerialEventParams.m_mask` holds the mask of all serial lines that has changed; `io.SerialEventParams.m_lines` holds new values of those lines.</para>
</detaileddescription>
</enumvalue>

<includes>io_base.jncx</includes>
<includes>io_Serial.jnc</includes>
<briefdescription><para>This enumeration contains codes of all possible events that might happen on `io.Serial` object.</para></briefdescription>
<detaileddescription>
<para>When `io.Serial` object is about to fire an event, it allocates an `io.SerialEventParams` structure, sets `io.SerialEventParams.m_eventCode` field to once of the values below, fills other relevant fields of and then calls all subscribers of `io.Serial.m_onSerialEvent`.</para>
<para><simplesect kind='see'><para>`io.Serial`, `io.SerialEventParams`</para></simplesect></para>
</detaileddescription>
<location file='io_Serial.jnc' line='176' col='6'/>
</memberdef>

<memberdef kind='function' id='function_io_createserialportdesclist'>
<functionkind>named-function</functionkind>
<name>createSerialPortDescList</name>
<type><ref refid="type_io_serialportdesc">io.SerialPortDesc</ref> const*</type>
<argsstring>(size_t* count null)</argsstring>
<param>
<declname>count</declname>
<type><ref refid="typedef_size_t">size_t</ref>*</type>
<array></array>
<defval>null</defval>
</param>
<detaileddescription>
<para>Enumerates all available serial ports.

``count`` argument can be used to obtain the total number of devices in the resulting list.

Returns a pointer to the very first `io.SerialPortDesc` in the resulting list. You can walk through the list by inspecting `io.SerialPortDesc.m_next` field:

.. ref-code-block::

	`io.SerialPortDesc` const* portDesc = io.createSerialPortDescList ();
	for (; portDesc; portDesc = portDesc.m_next)
	{
		// add port to the combo box...
	}</para>
</detaileddescription>
<location file='io_Serial.jnc' line='546' col='23'/>
</memberdef>

<memberdef kind='enum' id='type_io_ssheventcode'>
<name>SshEventCode</name>
<enumvalue id='enum_member_io_ssheventcode_tcpconnectcompleted'>
<name>TcpConnectCompleted</name>
<detaileddescription>
<para>Underlying transport ``TCP`` has been established.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_sshhandshakecompleted'>
<name>SshHandshakeCompleted</name>
<detaileddescription>
<para>``SSH`` handshake and protocol information exchange has been completed successfully.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_sshauthcompleted'>
<name>SshAuthCompleted</name>
<detaileddescription>
<para>``SSH`` authentication has been completed successfully.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_sshautherror'>
<name>SshAuthError</name>
<detaileddescription>
<para>``SSH`` authentication has failed. You have a chance to re-authenticate: ask user for new credentials and then call `io.SshChannel.authenticate`.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_sshchannelopened'>
<name>SshChannelOpened</name>
<detaileddescription>
<para>``SSH`` channel to the server has been opened successfully.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_sshptyrequested'>
<name>SshPtyRequested</name>
<detaileddescription>
<para>Request has been sent to the ``SSH`` server for a specific pseudo-terminal (such as ``xterm``).</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_sshprocessstarted'>
<name>SshProcessStarted</name>
<detaileddescription>
<para>Remote process (such as ``shell``) has been started by the ``SSH`` server.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_connectcompleted'>
<name>ConnectCompleted</name>
<detaileddescription>
<para>The full ``SSH`` connect sequence has been completed successfully. ``SSH`` channel is ready to use.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_connectcancelled'>
<name>ConnectCancelled</name>
<detaileddescription>
<para>``SSH`` connect sequence has been interrupted by `io.SshChannel.close` method.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_connecterror'>
<name>ConnectError</name>
<detaileddescription>
<para>Failure happened during ``SSH`` connect sequence. Detailed error information is available at: `io.SshEventParams.m_error`.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_disconnected'>
<name>Disconnected</name>
<detaileddescription>
<para>``SSH`` channel has been closed by the remote server. Note that if connection was terminated by the local node (using `io.SshChannel.close`), ``Disconnect`` event is **not** fired.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_reauthenticateinitiated'>
<name>ReauthenticateInitiated</name>
<detaileddescription>
<para>User has issued `io.SshChannel.authenticate` using the same user name; no re-connect is needed for ``SSH`` re-authentication.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_reconnectinitiated'>
<name>ReconnectInitiated</name>
<detaileddescription>
<para>User has issued `io.SshChannel.authenticate` using a different user name; a full cycle of re-connect (starting at the transport ``TCP`` level) is required.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_incomingdata'>
<name>IncomingData</name>
<detaileddescription>
<para>More data is available on the socket; this data could be fetched with `io.SshChannel.read` method.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_ssheventcode_transmitbufferready'>
<name>TransmitBufferReady</name>
<detaileddescription>
<para>Socket transmit buffer is ready to accept more data; it's OK to issue more `io.SshChannel.write` requests.</para>
</detaileddescription>
</enumvalue>

<includes>io_ssh.jncx</includes>
<briefdescription><para>This enumeration contains codes of all possible events that might happen on `io.SshChannel` object.</para></briefdescription>
<detaileddescription>
<para>When `io.SshChannel` object is about to fire an event, it allocates an `io.SshEventParams` structure, sets `io.SshEventParams.m_eventCode` field to one of the values below, fills other relevant fields of and then calls all subscribers of `io.SshChannel.m_onSshEvent`.</para>
<para><simplesect kind='see'><para>`io.SshChannel`, `io.SshEventParams`</para></simplesect></para>
</detaileddescription>
<location file='io_Ssh.jnc' line='31' col='6'/>
</memberdef>

<memberdef kind='enum' id='type_io_pcapeventcode'>
<name>PcapEventCode</name>
<enumvalue id='enum_member_io_pcapeventcode_readyread'>
<name>ReadyRead</name>
<detaileddescription>
<para>New packet(s) are available on the Pcap device or file; the next packet could be fetched with `io.Pcap.read` method.</para>
</detaileddescription>
</enumvalue>

<enumvalue id='enum_member_io_pcapeventcode_eof'>
<name>Eof</name>
<detaileddescription>
<para>End-of-file was reached on the Pcap file.</para>
</detaileddescription>
</enumvalue>

<includes>io_pcap.jncx</includes>
<briefdescription><para>This enumeration contains codes of all possible events that might happen on `io.Pcap` object.</para></briefdescription>
<detaileddescription>
<para>When `io.Pcap` object is about to fire an event, it allocates an `io.PcapEventParams` structure, sets `io.PcapEventParams.m_eventCode` field to one of the values below, fills other relevant fields of and then calls all subscribers of `io.Pcap.m_onPcapEvent`.</para>
<para><simplesect kind='see'><para>`io.Pcap`, `io.PcapEventParams`</para></simplesect></para>
</detaileddescription>
<location file='io_Pcap.jnc' line='31' col='6'/>
</memberdef>

<memberdef kind='function' id='function_io_createpcapdevicedesclist'>
<functionkind>named-function</functionkind>
<name>createPcapDeviceDescList</name>
<type><ref refid="type_io_pcapdevicedesc">io.PcapDeviceDesc</ref> const*</type>
<argsstring>(size_t* count null)</argsstring>
<param>
<declname>count</declname>
<type><ref refid="typedef_size_t">size_t</ref>*</type>
<array></array>
<defval>null</defval>
</param>
<detaileddescription>
<para>Enumerates all available devices Pcap can start a live capture session on.

``count`` argument can be used to obtain the total number of devices in the resulting list.

Returns a pointer to the very first `io.PcapDeviceDesc` in the resulting list. You can walk through the list by inspecting `io.PcapDeviceDesc.m_next` field:

.. ref-code-block::

	`io.PcapDeviceDesc` const* deviceDesc = io.createPcapDeviceDescList ();
	for (; deviceDesc; deviceDesc = deviceDesc.m_next)
	{
		// add device to the combo box...
	}</para>
</detaileddescription>
<location file='io_Pcap.jnc' line='379' col='23'/>
</memberdef>

<memberdef kind='enum' id='type_io_usbtransfertype'>
<name>UsbTransferType</name>
<enumvalue id='enum_member_io_usbtransfertype_control'>
<name>Control</name>
<initializer>= 0</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbtransfertype_isochronous'>
<name>Isochronous</name>
<initializer>= 1</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbtransfertype_bulk'>
<name>Bulk</name>
<initializer>= 2</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbtransfertype_interrupt'>
<name>Interrupt</name>
<initializer>= 3</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbtransfertype_bulkstream'>
<name>BulkStream</name>
<initializer>= 4</initializer>
</enumvalue>

<location file='io_Usb.jnc' line='19' col='23'/>
</memberdef>

<memberdef kind='enum' id='type_io_usbisosynctype'>
<name>UsbIsoSyncType</name>
<enumvalue id='enum_member_io_usbisosynctype_none'>
<name>None</name>
<initializer>= 0</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbisosynctype_async'>
<name>Async</name>
<initializer>= 1</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbisosynctype_adaptive'>
<name>Adaptive</name>
<initializer>= 2</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbisosynctype_sync'>
<name>Sync</name>
<initializer>= 3</initializer>
</enumvalue>

<location file='io_Usb.jnc' line='28' col='22'/>
</memberdef>

<memberdef kind='enum' id='type_io_usbisousage'>
<name>UsbIsoUsage</name>
<enumvalue id='enum_member_io_usbisousage_data'>
<name>Data</name>
<initializer>= 0</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbisousage_feedback'>
<name>Feedback</name>
<initializer>= 1</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbisousage_implicit'>
<name>Implicit</name>
<initializer>= 2</initializer>
</enumvalue>

<location file='io_Usb.jnc' line='36' col='19'/>
</memberdef>

<memberdef kind='enum' id='type_io_usbclass'>
<name>UsbClass</name>
<enumvalue id='enum_member_io_usbclass_perinterface'>
<name>PerInterface</name>
<initializer>= 0</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_audio'>
<name>Audio</name>
<initializer>= 1</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_comm'>
<name>Comm</name>
<initializer>= 2</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_hid'>
<name>Hid</name>
<initializer>= 3</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_physical'>
<name>Physical</name>
<initializer>= 5</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_ptp'>
<name>Ptp</name>
<initializer>= 6</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_printer'>
<name>Printer</name>
<initializer>= 7</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_massstorage'>
<name>MassStorage</name>
<initializer>= 8</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_hub'>
<name>Hub</name>
<initializer>= 9</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_data'>
<name>Data</name>
<initializer>= 10</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_smartcard'>
<name>SmartCard</name>
<initializer>= 0x0b</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_contentsecurity'>
<name>ContentSecurity</name>
<initializer>= 0x0d</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_video'>
<name>Video</name>
<initializer>= 0x0e</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_personalhealthcare'>
<name>PersonalHealthcare</name>
<initializer>= 0x0f</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_diagnosticdevice'>
<name>DiagnosticDevice</name>
<initializer>= 0xdc</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_wireless'>
<name>Wireless</name>
<initializer>= 0xe0</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_application'>
<name>Application</name>
<initializer>= 0xfe</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbclass_vendorspec'>
<name>VendorSpec</name>
<initializer>= 0xff</initializer>
</enumvalue>

<location file='io_Usb.jnc' line='43' col='16'/>
</memberdef>

<memberdef kind='enum' id='type_io_usbspeed'>
<name>UsbSpeed</name>
<enumvalue id='enum_member_io_usbspeed_unknown'>
<name>Unknown</name>
<initializer>= 0</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbspeed_low'>
<name>Low</name>
<initializer>= 1</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbspeed_full'>
<name>Full</name>
<initializer>= 2</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbspeed_high'>
<name>High</name>
<initializer>= 3</initializer>
</enumvalue>

<enumvalue id='enum_member_io_usbspeed_super'>
<name>Super</name>
<initializer>= 4</initializer>
</enumvalue>

<location file='io_Usb.jnc' line='65' col='16'/>
</memberdef>

<memberdef kind='function' id='function_io_getusbclassstring'>
<functionkind>named-function</functionkind>
<name>getUsbClassString</name>
<type>char const*</type>
<argsstring>(io.UsbClass cls)</argsstring>
<param>
<declname>cls</declname>
<type><ref refid="type_io_usbclass">io.UsbClass</ref></type>
<array></array>
</param>
<location file='io_Usb.jnc' line='77' col='1'/>
</memberdef>

<memberdef kind='function' id='function_io_getusbspeedstring'>
<functionkind>named-function</functionkind>
<name>getUsbSpeedString</name>
<type>char const*</type>
<argsstring>(io.UsbSpeed speed)</argsstring>
<param>
<declname>speed</declname>
<type><ref refid="type_io_usbspeed">io.UsbSpeed</ref></type>
<array></array>
</param>
<location file='io_Usb.jnc' line='80' col='1'/>
</memberdef>

<memberdef kind='function' id='function_io_getusbtransfertypestring'>
<functionkind>named-function</functionkind>
<name>getUsbTransferTypeString</name>
<type>char const*</type>
<argsstring>(io.UsbTransferType type)</argsstring>
<param>
<declname>type</declname>
<type><ref refid="type_io_usbtransfertype">io.UsbTransferType</ref></type>
<array></array>
</param>
<location file='io_Usb.jnc' line='83' col='1'/>
</memberdef>

<memberdef kind='enum' id='type_io_usbendpointeventcode'>
<name>UsbEndpointEventCode</name>
<enumvalue id='enum_member_io_usbendpointeventcode_readyread'>
<name>ReadyRead</name>
</enumvalue>

<enumvalue id='enum_member_io_usbendpointeventcode_ioerror'>
<name>IoError</name>
</enumvalue>

<location file='io_Usb.jnc' line='149' col='6'/>
</memberdef>

<memberdef kind='function' id='function_io_createusbdevicearray'>
<functionkind>named-function</functionkind>
<name>createUsbDeviceArray</name>
<type><ref refid="type_io_usbdevice">io.UsbDevice</ref>* const* errorcode</type>
<argsstring>(size_t* count null)</argsstring>
<param>
<declname>count</declname>
<type><ref refid="typedef_size_t">size_t</ref>*</type>
<array></array>
<defval>null</defval>
</param>
<location file='io_Usb.jnc' line='249' col='29'/>
</memberdef>

<memberdef kind='function' id='function_io_openusbdevice'>
<functionkind>named-function</functionkind>
<name>openUsbDevice</name>
<type><ref refid="type_io_usbdevice">io.UsbDevice</ref>* errorcode</type>
<argsstring>(uint_t vendorId, uint_t productId)</argsstring>
<param>
<declname>vendorId</declname>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<array></array>
</param>
<param>
<declname>productId</declname>
<type><ref refid="typedef_uint_t">uint_t</ref></type>
<array></array>
</param>
<location file='io_Usb.jnc' line='251' col='22'/>
</memberdef>

</sectiondef>
<location file='io_Socket.jnc' line='14' col='11'/>
</compounddef>
</doxygen>
