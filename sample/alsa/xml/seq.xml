<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="seq" kind="page">
    <compoundname>seq</compoundname>
    <title>Sequencer interface</title>
    <detaileddescription>
<sect1 id="seq_1seq_general">
<title>General</title>
<para>The ALSA sequencer interface is designed to deliver the MIDI-like events between clients/ports. A typical usage is the MIDI patch-bay. A MIDI application can be connected arbitrarily from/to the other MIDI clients. The routing between clients can be changed dynamically, so the application can handle incoming or outgoing MIDI events regardless of the devices or the application connections.</para><para>The sequencer core stuff only takes care of two things: scheduling events and dispatching them to the destination at the right time. All processing of MIDI events has to be done within the clients. The event can be dispatched immediately without queueing, too. The event scheduling can be done either on a MIDI tempo queue or on a wallclock-time queue.</para></sect1>
<sect1 id="seq_1seq_client">
<title>Client and Port</title>
<para>A <emphasis>client</emphasis> is created at each time <ref refid="group___sequencer_1ga95462dc59c0319e186cda713ecfb4ed3" kindref="member">snd_seq_open()</ref> is called. Later on, the attributes of client such as its name string can be changed via <ref refid="group___seq_client_1ga109f62fb356c322533ddde4a6ce2c587" kindref="member">snd_seq_set_client_info()</ref>. There are helper functions for ease of use, e.g. <ref refid="group___seq_middle_1gaec3acab3bfb3df3f0c9ccc4903570b9d" kindref="member">snd_seq_set_client_name()</ref> and <ref refid="group___seq_middle_1ga888bf17bbc8141d1624f7bbef52dddce" kindref="member">snd_seq_set_client_event_filter()</ref>. A typical code would be like below: <programlisting><codeline><highlight class="normal">//<sp/>create<sp/>a<sp/>new<sp/>client</highlight></codeline>
<codeline><highlight class="normal">snd_seq_t<sp/>*open_client()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_t<sp/>*handle;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>err;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>err<sp/>=<sp/>snd_seq_open(&amp;handle,<sp/>&quot;default&quot;,<sp/>SND_SEQ_OPEN_INPUT,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if<sp/>(err<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>return<sp/>NULL;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_set_client_name(handle,<sp/>&quot;My<sp/>Client&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>handle;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>You&apos;ll need to know the id number of the client eventually, for example, when accessing to a certain port (see the section <ref refid="seq_1seq_subs" kindref="member">Subscription</ref>). The client id can be obtained by <ref refid="group___sequencer_1ga2cdaded101f041b9a0930b665ac44b93" kindref="member">snd_seq_client_id()</ref> function.</para><para>A client can have one or more <emphasis>ports</emphasis> to communicate between other clients. A port is corresponding to the MIDI port in the case of MIDI device, but in general it is nothing but the access point between other clients. Each port may have capability flags, which specify the read/write accessibility and subscription permissions of the port. For creation of a port, call <ref refid="group___seq_port_1gab40867ed02d9d6e40a75f929b5adf24d" kindref="member">snd_seq_create_port()</ref> with the appropriate port attribute specified in <ref refid="group___seq_port_1ga122b704fdab734223ef90b5e26f358e9" kindref="member">snd_seq_port_info_t</ref> record.</para><para>For creating a port for the normal use, there is a helper function <ref refid="group___seq_middle_1ga9368266bde7b5c0f8d5ddeaf64914719" kindref="member">snd_seq_create_simple_port()</ref>. An example with this function is like below. <programlisting><codeline><highlight class="normal">//<sp/>create<sp/>a<sp/>new<sp/>port;<sp/>return<sp/>the<sp/>port<sp/>id</highlight></codeline>
<codeline><highlight class="normal">//<sp/>port<sp/>will<sp/>be<sp/>writable<sp/>and<sp/>accept<sp/>the<sp/>write-subscription.</highlight></codeline>
<codeline><highlight class="normal">int<sp/>my_new_port(snd_seq_t<sp/>*handle)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>snd_seq_create_simple_port(handle,<sp/>&quot;my<sp/>port&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SND_SEQ_PORT_CAP_WRITE|SND_SEQ_PORT_CAP_SUBS_WRITE,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>SND_SEQ_PORT_TYPE_MIDI_GENERIC);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect1>
<sect1 id="seq_1seq_memory">
<title>Memory Pool</title>
<para>Each client owns memory pools on kernel space for each input and output events. Here, input and output mean input (read) from other clients and output (write) to others, respectively. Since memory pool of each client is independent from others, it avoids such a situation that a client eats the whole events pool and interfere other clients&apos; response.</para><para>The all scheduled output events or input events from dispatcher are stored on these pools until delivered to other clients or extracted to user space. The size of input/output pools can be changed independently. The output pool has also a room size, which is used to wake up the thread when it falls into sleep in blocking write mode.</para><para>Note that ports on the same client share the same memory pool. If a port fills the memory pool, another can&apos;t use it any more. For avoiding this, multiple clients can be used.</para><para>For chancing the pool size and the condition, access to <ref refid="group___seq_client_1gadc7ce8adaec84d42695492f0ba2515af" kindref="member">snd_seq_client_pool_t</ref> record. There are helper functions, <ref refid="group___seq_middle_1ga38e40d84154122798c9fad8e56c60a0f" kindref="member">snd_seq_set_client_pool_output()</ref>, <ref refid="group___seq_middle_1ga597d2417e0fd512f56d31464cc2ea7d7" kindref="member">snd_seq_set_client_pool_output_room()</ref> and <ref refid="group___seq_middle_1ga1344c7aadb847bd409093c179557732d" kindref="member">snd_seq_set_client_pool_input()</ref>, for setting the total output-pool size, the output-room size and the input-pool size, respectively.</para></sect1>
<sect1 id="seq_1seq_subs">
<title>Subscription</title>
<para>One of the new features in ALSA sequencer system is <emphasis>subscription</emphasis> of ports. In general, subscription is a connection between two sequencer ports. Even though an event can be delivered to a port without subscription using an explicit destination address, the subscription mechanism provides us more abstraction.</para><para>Suppose a MIDI input device which sends events from a keyboard. The port associated with this device has READ capability - which means this port is readable from other ports. If a user program wants to capture events from keyboard and store them as MIDI stream, this program must subscribe itself to the MIDI port for read. Then, a connection from MIDI input port to this program is established. From this time, events from keyboard are automatically sent to this program. Timestamps will be updated according to the subscribed queue. <programlisting><codeline><highlight class="normal">MIDI<sp/>input<sp/>port<sp/>(keyboard)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>V</highlight></codeline>
<codeline><highlight class="normal">ALSA<sp/>sequencer<sp/>-<sp/>update<sp/>timestamp</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>V</highlight></codeline>
<codeline><highlight class="normal">application<sp/>port</highlight></codeline>
</programlisting></para><para>There is another subscription type for opposite direction: Suppose a MIDI sequencer program which sends events to a MIDI output device. In ALSA system, MIDI device is not opened until the associated MIDI port is accessed. Thus, in order to activate MIDI device, we have to subscribe to MIDI port for write. After this connection is established, events will be properly sent to MIDI output device. <programlisting><codeline><highlight class="normal">application<sp/>port</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>V</highlight></codeline>
<codeline><highlight class="normal">ALSA<sp/>sequencer<sp/>-<sp/>events<sp/>are<sp/>scheduled</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>V</highlight></codeline>
<codeline><highlight class="normal">MIDI<sp/>output<sp/>port<sp/>(WaveTable<sp/>etc.)</highlight></codeline>
</programlisting></para><para>From the viewpoint of subscription, the examples above are special cases. Basically, subscription means the connection between two arbitrary ports. For example, imagine a filter application which modifies the MIDI events like program, velocity or chorus effects. This application can accept arbitrary MIDI input and send to arbitrary port, just like a Unix pipe application using stdin and stdout files. We can even connect several filter applications which work individually in order to process the MIDI events. Subscription can be used for this purpose. The connection between ports can be done also by the &quot;third&quot; client. Thus, filter applications have to manage only input and output events regardless of receiver/sender addresses. <programlisting><codeline><highlight class="normal">sequencer<sp/>port<sp/>#1</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>V</highlight></codeline>
<codeline><highlight class="normal">ALSA<sp/>sequencer<sp/>(scheduled<sp/>or<sp/>real-time)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>V</highlight></codeline>
<codeline><highlight class="normal">sequencer<sp/>port<sp/>#2</highlight></codeline>
</programlisting></para><para>For the detail about subscription, see the section <ref refid="seq_1seq_subs_more" kindref="member">More inside the subscription</ref>.</para></sect1>
<sect1 id="seq_1seq_events">
<title>Sequencer Events</title>
<para>Messaging between clients is performed by sending events from one client to another. These events contain high-level MIDI oriented messages or sequencer specific messages.</para><para>All the sequencer events are stored in a sequencer event record, <ref refid="structsnd__seq__event__t" kindref="compound">snd_seq_event_t</ref> type. Application can send and receive these event records to/from other clients via sequencer. An event has several storage types according to its usage. For example, a SYSEX message is stored on the variable length event, and a large synth sample data is delivered using a user-space data pointer.</para><sect2 id="seq_1seq_ev_struct">
<title>Structure of an event</title>
<para>An event consists of the following items: <itemizedlist>
<listitem>
<para>The type of the event </para></listitem>
<listitem>
<para>Event flags. It describes various conditions: <itemizedlist>
<listitem>
<para>time stamp; &quot;real time&quot; / &quot;song ticks&quot; </para></listitem>
<listitem>
<para>time mode; &quot;absolute&quot; / &quot;relative to current time&quot; </para></listitem>
</itemizedlist>
</para></listitem>
<listitem>
<para>Timestamp of the event. </para></listitem>
<listitem>
<para>Scheduling queue id. </para></listitem>
<listitem>
<para>Source address of the event, given by the combination of client id and port id numbers. </para></listitem>
<listitem>
<para>Destination address of the event. </para></listitem>
<listitem>
<para>The actual event data. (up to 12 bytes) </para></listitem>
</itemizedlist>
</para><para>The actual record is shown in <ref refid="structsnd__seq__event__t" kindref="compound">snd_seq_event_t</ref>. The type field contains the type of the event (1 byte). The flags field consists of bit flags which describe several conditions of the event (1 byte). It includes the time-stamp mode, data storage type, and scheduling priority. The tag field is an arbitrary tag. This tag can used for removing a distinct event from the event queue via <ref refid="group___seq_event_1ga7ed1109642fdb8dbd9f8a20564e40362" kindref="member">snd_seq_remove_events()</ref>. The queue field is the queue id for scheduling. The source and dest fields are source and destination addresses. The data field is a union of event data.</para></sect2>
<sect2 id="seq_1seq_ev_queue">
<title>Scheduling queue</title>
<para>An event can be delivered either on scheduled or direct dispatch mode. On the scheduling mode, an event is once stored on the priority queue and delivered later (or even immediately) to the destination, whereas on the direct dispatch mode, an event is passed to the destination without any queue.</para><para>For a scheduled delivery, a queue to process the event must exist. Usually, a client creates its own queue by <ref refid="group___seq_queue_1ga036e62b321b56bee2e8d2e8280a6416a" kindref="member">snd_seq_alloc_queue()</ref> function. Alternatively, a queue may be shared among several clients. For scheduling an event on the specified queue, a client needs to fill queue field with the preferred queue id.</para><para>Meanwhile, for dispatching an event directly, just use <ref refid="group___seq_queue_1ga2a5be7ea9ad68adc9a7288ba25850245" kindref="member">SND_SEQ_QUEUE_DIRECT</ref> as the target queue id. A macro <ref refid="group___seq_middle_1gae2674210b5601e8aa3e787c1ddbdcb62" kindref="member">snd_seq_ev_set_direct()</ref> is provided for ease and compatibility.</para><para>Note that scheduling at the current or earlier time is different from the direct dispatch mode even though the event is delivered immediately. On the former scheme, an event is once stored on priority queue, then delivered actually. Thus, it acquires a space from memory pool. On the other hand, the latter is passed without using memory pool. Although the direct dispatched event needs less memory, it means also that the event cannot be resent if the destination is unable to receive it momentarily.</para></sect2>
<sect2 id="seq_1seq_ev_time">
<title>Time stamp</title>
<para>The timestamp of the event can either specified in <emphasis>real time</emphasis> or in <emphasis>song ticks</emphasis>. The former means the wallclock time while the latter corresponds to the MIDI ticks. Which format is used is determined by the event flags.</para><para>The resolution of real-time value is in nano second. Since 64 bit length is required for the actual time calculation, it is represented by a structure of pair of second and nano second defined as <ref refid="structsnd__seq__real__time__t" kindref="compound">snd_seq_real_time_t</ref> type. The song tick is defined simply as a 32 bit integer, defined as <ref refid="group___seq_events_1gaa6a1e0c4394f9b26cc55e0181a5e2cb8" kindref="member">snd_seq_tick_time_t</ref> type. The time stored in an event record is a union of these two different time values.</para><para>Note that the time format used for real time events is very similar to timeval struct used for Unix system time. The absurd resolution of the timestamps allows us to perform very accurate conversions between songposition and real time. Round-off errors can be neglected.</para><para>If a timestamp with a <emphasis>relative</emphasis> timestamp is delivered to ALSA, the specified timestamp will be used as an offset to the current time of the queue the event is sent into. An <emphasis>absolute</emphasis> timestamp is on the contrary the time counted from the moment when the queue started.</para><para>An client that relies on these relative timestamps is the MIDI input port. As each sequencer queue has it&apos;s own clock the only way to deliver events at the right time is by using the relative timestamp format. When the event arrives at the queue it is normalized to absolute format.</para><para>The timestamp format is specified in the flag bitfield masked by <ref refid="group___seq_events_1gac7da1e1965e86a68f663babec22a99ba" kindref="member">SND_SEQ_TIME_STAMP_MASK</ref>. To schedule the event in a real-time queue or in a tick queue, macros <ref refid="group___seq_middle_1ga713370bf29736477532e791b4ad92530" kindref="member">snd_seq_ev_schedule_real()</ref> and <ref refid="group___seq_middle_1ga589469c27715bfae205ce26d5801d8b1" kindref="member">snd_seq_ev_schedule_tick()</ref> are provided, respectively.</para></sect2>
<sect2 id="seq_1seq_ev_addr">
<title>Source and destination addresses</title>
<para>To identify the source and destination of an event, the addressing field contains a combination of client id and port id numbers, defined as <ref refid="structsnd__seq__addr__t" kindref="compound">snd_seq_addr_t</ref> type. When an event is passed to sequencer from a client, sequencer fills source.client field with the sender&apos;s id automatically. It is the responsibility of sender client to fill the port id of source.port and both client and port of dest field.</para><para>If an existing address is set to the destination, the event is simply delivered to it. When <ref refid="group___sequencer_1ga383b235d2afbe48704952edfd3a33eed" kindref="member">SND_SEQ_ADDRESS_SUBSCRIBERS</ref> is set to the destination client id, the event is delivered to all the clients connected to the source port.</para><para>A sequencer core has two pre-defined system ports on the system client <ref refid="group___sequencer_1ga5437f98c59679c92ee4d940ac643169e" kindref="member">SND_SEQ_CLIENT_SYSTEM</ref>: <ref refid="group___seq_port_1ga02870ceddec24d3cc5609ec728b0cb92" kindref="member">SND_SEQ_PORT_SYSTEM_TIMER</ref> and <ref refid="group___seq_port_1gaf12ff6ca6077edc7c6027a3fb1d0664b" kindref="member">SND_SEQ_PORT_SYSTEM_ANNOUNCE</ref>. The <ref refid="group___seq_port_1ga02870ceddec24d3cc5609ec728b0cb92" kindref="member">SND_SEQ_PORT_SYSTEM_TIMER</ref> is the system timer port, and <ref refid="group___seq_port_1gaf12ff6ca6077edc7c6027a3fb1d0664b" kindref="member">SND_SEQ_PORT_SYSTEM_ANNOUNCE</ref> is the system announce port. In order to control a queue from a client, client should send a queue-control event like start, stop and continue queue, change tempo, etc. to the system timer port. Then the sequencer system handles the queue according to the received event. This port supports subscription. The received timer events are broadcasted to all subscribed clients.</para><para>The latter port does not receive messages but supports subscription. When each client or port is attached, detached or modified, an announcement is sent to subscribers from this port.</para></sect2>
<sect2 id="seq_1seq_ev_data">
<title>Data storage type</title>
<para>Some events like SYSEX message, however, need larger data space than the standard data. For such events, ALSA sequencer provides several different data storage types. The data type is specified in the flag bits masked by <ref refid="group___seq_events_1ga69fa938ef7ebc12e3d1b8758b39b7967" kindref="member">SND_SEQ_EVENT_LENGTH_MASK</ref>. The following data types are available:</para><para><simplesect kind="par"><title>Fixed size data</title><para>Normal events stores their parameters on data field (12 byte). The flag-bit type is <ref refid="group___seq_events_1ga35b6aacb44080053e0ca0eeaefbe8dc2" kindref="member">SND_SEQ_EVENT_LENGTH_FIXED</ref>. A macro <ref refid="group___seq_middle_1ga8c949038f36fd3e27de8b8e419978793" kindref="member">snd_seq_ev_set_fixed()</ref> is provided to set this type.</para></simplesect>
<simplesect kind="par"><title>Variable length data</title><para>SYSEX or a returned error use this type. The actual data is stored on an extra allocated space. On sequencer kernel, the whole extra-data is duplicated, so that the event can be scheduled on queue. The data contains only the length and the pointer of extra-data. The flag-bit type is <ref refid="group___seq_events_1ga273f82dce70a0284a4dcabd34f1bfe7d" kindref="member">SND_SEQ_EVENT_LENGTH_VARIABLE</ref>. A macro <ref refid="group___seq_middle_1ga12ac15c961d96d3122f7c2f6a0849fb1" kindref="member">snd_seq_ev_set_variable()</ref> is provided to set this type.</para></simplesect>
<simplesect kind="par"><title>User-space data</title><para>This type refers also an extra data space like variable length data, but the extra-data is not duplicated but but referred as a user-space data on kernel, so that it reduces the time and resource for transferring large bulk of data like synth sample wave. This data type, however, can be used only for direct dispatch mode, and supposed to be used only for a special purpose like a bulk data transfer. The data length and pointer are stored also in data.ext field as well as variable length data. The flag-bit type is <ref refid="group___seq_events_1ga5e38e6cf87f023332b797c30b74223b1" kindref="member">SND_SEQ_EVENT_LENGTH_VARUSR</ref>. A macro <ref refid="group___seq_middle_1ga993e1f46d8122a227fa0072a73af813e" kindref="member">snd_seq_ev_set_varusr()</ref> is provided to set this type.</para></simplesect>
</para></sect2>
<sect2 id="seq_1seq_ev_sched">
<title>Scheduling priority</title>
<para>There are two priorities for scheduling: <simplesect kind="par"><title>Normal priority</title><para>If an event with the same scheduling time is already present on the queue, the new event is appended to the older. </para></simplesect>
<simplesect kind="par"><title>High priority</title><para>If an event with the same scheduling time is already present on the queue, the new event is inserted before others.</para></simplesect>
The scheduling priority is set in the flag bitfeld masked by <ref refid="group___seq_events_1gaea7b84a517451282036dad991a45239c" kindref="member">SND_SEQ_PRIORITY_MASK</ref>. A macro <ref refid="group___seq_middle_1ga9b6fba99052fb11977559f15192581d4" kindref="member">snd_seq_ev_set_priority()</ref> is provided to set the mode type.</para></sect2>
</sect1>
<sect1 id="seq_1seq_queue">
<title>Event Queues</title>
<sect2 id="seq_1seq_ev_control">
<title>Creation of a queue</title>
<para>Creating a queue is done usually by calling <ref refid="group___seq_queue_1ga036e62b321b56bee2e8d2e8280a6416a" kindref="member">snd_seq_alloc_queue</ref>. You can create a queue with a certain name by <ref refid="group___seq_queue_1ga8efa821e0fc96fd05460306808e8fb7d" kindref="member">snd_seq_alloc_named_queue()</ref>, too. <programlisting><codeline><highlight class="normal">//<sp/>create<sp/>a<sp/>queue<sp/>and<sp/>return<sp/>its<sp/>id</highlight></codeline>
<codeline><highlight class="normal">int<sp/>my_queue(snd_seq_t<sp/>*handle)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>snd_seq_alloc_named_queue(handle,<sp/>&quot;my<sp/>queue&quot;);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> These functions are the wrapper to the function <ref refid="group___seq_queue_1ga05fc43229e94aecbb4379909200aeeae" kindref="member">snd_seq_create_queue()</ref>. For releasing the allocated queue, call <ref refid="group___seq_queue_1ga5b2cf5082861776ac9f7f986459cbccf" kindref="member">snd_seq_free_queue()</ref> with the obtained queue id.</para><para>Once when a queue is created, the two queues are associated to that queue record in fact: one is the realtime queue and another is the tick queue. These two queues are bound together to work synchronously. Hence, when you schedule an event, you have to choose which queue type is used as described in the section <ref refid="seq_1seq_ev_time" kindref="member">Time stamp</ref>.</para></sect2>
<sect2 id="seq_1seq_ev_tempo">
<title>Setting queue tempo</title>
<para>The tempo (or the speed) of the scheduling queue is variable. In the case of <emphasis>tick</emphasis> queue, the tempo is controlled in the manner of MIDI. There are two parameters to define the actual tempo, PPQ (pulse per quarter note) and MIDI tempo. The former defines the base resolution of the ticks, while the latter defines the beat tempo in microseconds. As default, 96 PPQ and 120 BPM are used, respectively. That is, the tempo is set to 500000 (= 60 * 1000000 / 120). Note that PPQ cannot be changed while the queue is running. It must be set before the queue is started.</para><para>On the other hand, in the case of <emphasis>realtime</emphasis> queue, the time resolution is fixed to nanoseconds. There is, however, a parameter to change the speed of this queue, called <emphasis>skew</emphasis>. You can make the queue faster or slower by setting the skew value bigger or smaller. In the API, the skew is defined by two values, the skew base and the skew value. The actual skew is the fraction of them, <emphasis>value/base</emphasis>. As default, the skew base is set to 16bit (0x10000) and the skew value is the identical, so that the queue is processed as well as in the real world.</para><para>When the tempo of realtime queue is changed, the tempo of the associated tick queue is changed together, too. That&apos;s the reason why two queues are created always. This feature can be used to synchronize the event queue with the external synchronization source like SMPTE. In such a case, the realtime queue is skewed to match with the external source, so that both the realtime timestamp and the MIDI timestamp are synchronized.</para><para>For setting these tempo parameters, use <ref refid="group___seq_queue_1ga8cef04796cda140f86f8e6298f26b4da" kindref="member">snd_seq_queue_tempo_t</ref> record. For example, to set the tempo of the queue <computeroutput>q</computeroutput> to 48 PPQ, 60 BPM, <programlisting><codeline><highlight class="normal">void<sp/>set_tempo(snd_seq_t<sp/>*handle)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_queue_tempo_t<sp/>*tempo;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_queue_tempo_alloca(&amp;tempo);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_queue_tempo_set_tempo(tempo,<sp/>1000000);<sp/>//<sp/>60<sp/>BPM</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_queue_tempo_set_ppq(tempo,<sp/>48);<sp/>//<sp/>48<sp/>PPQ</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_set_queue_tempo(handle,<sp/>tempo);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>For changing the (running) queue&apos;s tempo on the fly, you can either set the tempo via <ref refid="group___seq_queue_1ga84793898d689520441a4c1164a8c0c77" kindref="member">snd_seq_set_queue_tempo()</ref> or send a MIDI tempo event to the system timer port. For example, <programlisting><codeline><highlight class="normal">int<sp/>change_tempo(snd_seq_t<sp/>*handle,<sp/>int<sp/>q,<sp/>unsigned<sp/>int<sp/>tempo)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>snd_seq_event_t<sp/>ev;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>snd_seq_ev_clear(&amp;ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ev.dest.client<sp/>=<sp/>SND_SEQ_CLIENT_SYSTEM;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ev.dest.port<sp/>=<sp/>SND_SEQ_PORT_SYSTEM_TIMER;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ev.source.client<sp/>=<sp/>my_client_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ev.source.port<sp/>=<sp/>my_port_id;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ev.queue<sp/>=<sp/>SND_SEQ_QUEUE_DIRECT;<sp/>//<sp/>no<sp/>scheduling</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ev.data.queue.queue<sp/>=<sp/>q;<sp/><sp/><sp/><sp/>//<sp/>affected<sp/>queue<sp/>id</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ev.data.queue.value<sp/>=<sp/>tempo;<sp/><sp/><sp/><sp/>//<sp/>new<sp/>tempo<sp/>in<sp/>microsec.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>return<sp/>snd_seq_event_output(handle,<sp/>&amp;ev);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> There is a helper function to do this easily, <ref refid="group___seq_middle_1gab77f13c0b39dec12ef983eb706925d00" kindref="member">snd_seq_change_queue_tempo()</ref>. Set NULL to the last argument, if you don&apos;t need any special settings.</para><para>In the above example, the tempo is changed immediately after the buffer is flushed by <ref refid="group___seq_event_1ga64a0ed5488504ef91b5b6b92172bc0aa" kindref="member">snd_seq_drain_output()</ref> call. You can schedule the event in a certain queue so that the tempo change happens at the scheduled time, too.</para></sect2>
<sect2 id="seq_1seq_ev_start">
<title>Starting and stopping a queue</title>
<para>To start, stop, or continue a queue, you need to send a queue-control event to the system timer port as well. There are helper functions, <ref refid="group___seq_middle_1ga0c7a86bb19188a00c5a3b4907d558058" kindref="member">snd_seq_start_queue()</ref>, <ref refid="group___seq_middle_1gab62a2e964135fdff96d21835d4cddad6" kindref="member">snd_seq_stop_queue()</ref> and <ref refid="group___seq_middle_1gad6b0c90be37eeb583318c9077f095b86" kindref="member">snd_seq_continue_queue()</ref>. Note that if the last argument of these functions is NULL, the event is sent (i.e. operated) immediately after the buffer flush. If you want to schedule the event at the certain time, set up the event record and provide the pointer of that event record as the argument.</para><para>Only calling these functions doesn&apos;t deliver the event to the sequencer core but only put to the output buffer. You&apos;ll need to call <ref refid="group___seq_event_1ga64a0ed5488504ef91b5b6b92172bc0aa" kindref="member">snd_seq_drain_output()</ref> eventually.</para></sect2>
</sect1>
<sect1 id="seq_1seq_subs_more">
<title>More inside the subscription</title>
<sect2 id="seq_1seq_subs_perm">
<title>Permissions</title>
<para>Each ALSA port can have capability flags. The most basic capability flags are <ref refid="group___seq_port_1ga81a7a5385af746364b757eb7911ec2f0" kindref="member">SND_SEQ_PORT_CAP_READ</ref> and <ref refid="group___seq_port_1gae8afb5ac8f546461b4bab25454972aeb" kindref="member">SND_SEQ_PORT_CAP_WRITE</ref>. The former means that the port allows to send events to other ports, whereas the latter capability means that the port allows to receive events from other ports. You may have noticed that meanings of <computeroutput>READ</computeroutput> and <computeroutput>WRITE</computeroutput> are permissions of the port from the viewpoint of other ports.</para><para>For allowing subscription from/to other clients, another capability flags must be set together with read/write capabilities above. For allowing read and write subscriptions, <ref refid="group___seq_port_1ga4b8aa6cbeb3c99c3ad033f4ce69c06e2" kindref="member">SND_SEQ_PORT_CAP_SUBS_READ</ref> and <ref refid="group___seq_port_1ga52ff1c51578166e67936cfb826c966c0" kindref="member">SND_SEQ_PORT_CAP_SUBS_WRITE</ref> are used, respectively. For example, the port with MIDI input device always has <ref refid="group___seq_port_1ga4b8aa6cbeb3c99c3ad033f4ce69c06e2" kindref="member">SND_SEQ_PORT_CAP_SUBS_READ</ref> capability, and the port with MIDI output device always has <ref refid="group___seq_port_1ga52ff1c51578166e67936cfb826c966c0" kindref="member">SND_SEQ_PORT_CAP_SUBS_WRITE</ref> capability together with <ref refid="group___seq_port_1ga81a7a5385af746364b757eb7911ec2f0" kindref="member">SND_SEQ_PORT_CAP_READ</ref> and <ref refid="group___seq_port_1gae8afb5ac8f546461b4bab25454972aeb" kindref="member">SND_SEQ_PORT_CAP_WRITE</ref> capabilities, respectively. Obviously, these flags have no influence if <computeroutput>READ</computeroutput> or <computeroutput>WRITE&gt;</computeroutput> capability is not set.</para><para>Note that these flags are not necessary if the client subscribes itself to the specified port. For example, when a port makes READ subscription to MIDI input port, this port must have <ref refid="group___seq_port_1gae8afb5ac8f546461b4bab25454972aeb" kindref="member">SND_SEQ_PORT_CAP_WRITE</ref> capability, but no <ref refid="group___seq_port_1ga52ff1c51578166e67936cfb826c966c0" kindref="member">SND_SEQ_PORT_CAP_SUBS_WRITE</ref> capability is required. Only MIDI input port must have <ref refid="group___seq_port_1ga4b8aa6cbeb3c99c3ad033f4ce69c06e2" kindref="member">SND_SEQ_PORT_CAP_SUBS_READ</ref> capability.</para><para>As default, the connection of ports via the third client is always allowed if proper read and write (subscription) capabilities are set both to the source and destination ports. For prohibiting this behavior, set a capability <ref refid="group___seq_port_1gaa0a63e34744ed9faedf64fe0b364bfd4" kindref="member">SND_SEQ_PORT_CAP_NO_EXPORT</ref> to the port. If this flag is set, subscription must be done by sender or receiver client itself. It is useful to avoid unexpected disconnection. The ports which won&apos;t accept subscription should have this capability for better security.</para></sect2>
<sect2 id="seq_1seq_subs_handle">
<title>Subscription handlers</title>
<para>In ALSA library, subscription is done via <ref refid="group___seq_subscribe_1ga2b216ec66cd724af31d376398e7b4863" kindref="member">snd_seq_subscribe_port()</ref> function. It takes the argument of <ref refid="group___seq_subscribe_1gafdf1b5614ce0d591c86bfcd3f369fa38" kindref="member">snd_seq_port_subscribe_t</ref> record pointer. Suppose that you have a client which will receive data from a MIDI input device. The source and destination addresses are like the below; <programlisting><codeline><highlight class="normal">snd_seq_addr_t<sp/>sender,<sp/>dest;</highlight></codeline>
<codeline><highlight class="normal">sender.client<sp/>=<sp/>MIDI_input_client;</highlight></codeline>
<codeline><highlight class="normal">sender.port<sp/>=<sp/>MIDI_input_port;</highlight></codeline>
<codeline><highlight class="normal">dest.client<sp/>=<sp/>my_client;</highlight></codeline>
<codeline><highlight class="normal">dest.port<sp/>=<sp/>my_port;</highlight></codeline>
</programlisting> To set these values as the connection call like this. <programlisting><codeline><highlight class="normal">snd_seq_port_subscribe_t<sp/>*subs;</highlight></codeline>
<codeline><highlight class="normal">snd_seq_port_subscribe_alloca(&amp;subs);</highlight></codeline>
<codeline><highlight class="normal">snd_seq_port_subscribe_set_sender(subs,<sp/>&amp;sender);</highlight></codeline>
<codeline><highlight class="normal">snd_seq_port_subscribe_set_dest(subs,<sp/>&amp;dest);</highlight></codeline>
<codeline><highlight class="normal">snd_seq_subscribe_port(handle,<sp/>subs);</highlight></codeline>
</programlisting></para><para>When the connection should be exclusively done only between a certain pair, set <emphasis>exclusive</emphasis> attribute to the subscription record before calling <ref refid="group___seq_subscribe_1ga2b216ec66cd724af31d376398e7b4863" kindref="member">snd_seq_subscribe_port</ref>. <programlisting><codeline><highlight class="normal">snd_seq_port_subscribe_set_exclusive(subs,<sp/>1);</highlight></codeline>
</programlisting> The succeeding subscriptions will be refused.</para><para>The timestamp can be updated independently on each connection. When set up, the timestamp of incoming queue to the destination port is updated automatically to the time of the specified queue. <programlisting><codeline><highlight class="normal">snd_seq_port_subscribe_set_time_update(subs,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal">snd_seq_port_subscribe_set_queue(subs,<sp/>q);</highlight></codeline>
</programlisting> For getting the wallclock time (sec/nsec pair), set <emphasis>real</emphasis> attribute: <programlisting><codeline><highlight class="normal">snd_seq_port_subscribe_set_time_real(subs,<sp/>1);</highlight></codeline>
</programlisting> Otherwise, the timestamp is stored in tick unit. This feature is useful when receiving events from MIDI input device. The event time is automatically set in the event record.</para><para>Note that an outsider client may connect other ports. In this case, however, the subscription may be refused if <ref refid="group___seq_port_1gaa0a63e34744ed9faedf64fe0b364bfd4" kindref="member">SND_SEQ_PORT_CAP_NO_EXPORT</ref> capability is set in either sender or receiver port.</para></sect2>
</sect1>
<sect1 id="seq_1seq_subs_ex">
<title>Examples of subscription</title>
<sect2 id="seq_1seq_subs_ex_capt">
<title>Capture from keyboard</title>
<para>Assume MIDI input port = 64:0, application port = 128:0, and queue for timestamp = 1 with real-time stamp. The application port must have capability <ref refid="group___seq_port_1gae8afb5ac8f546461b4bab25454972aeb" kindref="member">SND_SEQ_PORT_CAP_WRITE</ref>. <programlisting><codeline><highlight class="normal">void<sp/>capture_keyboard(snd_seq_t<sp/>*seq)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_addr_t<sp/>sender,<sp/>dest;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_t<sp/>*subs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sender.client<sp/>=<sp/>64;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sender.port<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dest.client<sp/>=<sp/>128;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dest.port<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_alloca(&amp;subs);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_set_sender(subs,<sp/>&amp;sender);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_set_dest(subs,<sp/>&amp;dest);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_set_queue(subs,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_set_time_update(subs,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_set_time_real(subs,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_subscribe_port(seq,<sp/>subs);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="seq_1seq_subs_ex_out">
<title>Output to MIDI device</title>
<para>Assume MIDI output port = 65:1 and application port = 128:0. The application port must have capability <ref refid="group___seq_port_1ga81a7a5385af746364b757eb7911ec2f0" kindref="member">SND_SEQ_PORT_CAP_READ</ref>. <programlisting><codeline><highlight class="normal">void<sp/>subscribe_output(snd_seq_t<sp/>*seq)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_addr_t<sp/>sender,<sp/>dest;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_t<sp/>*subs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sender.client<sp/>=<sp/>128;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sender.port<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dest.client<sp/>=<sp/>65;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dest.port<sp/>=<sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_alloca(&amp;subs);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_set_sender(subs,<sp/>&amp;sender);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_set_dest(subs,<sp/>&amp;dest);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_subscribe_port(seq,<sp/>subs);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> This example can be simplified by using <ref refid="group___seq_middle_1gab39e210c5d93e96c241644f334c6c9ca" kindref="member">snd_seq_connect_to()</ref> function. <programlisting><codeline><highlight class="normal">void<sp/>subscribe_output(snd_seq_t<sp/>*seq)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_connect_to(seq,<sp/>0,<sp/>65,<sp/>1);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
<sect2 id="seq_1seq_subs_ex_arbit">
<title>Arbitrary connection</title>
<para>Assume connection from application 128:0 to 129:0, and that subscription is done by the third application (130:0). The sender must have capabilities both <ref refid="group___seq_port_1ga81a7a5385af746364b757eb7911ec2f0" kindref="member">SND_SEQ_PORT_CAP_READ</ref> and <ref refid="group___seq_port_1ga4b8aa6cbeb3c99c3ad033f4ce69c06e2" kindref="member">SND_SEQ_PORT_CAP_SUBS_READ</ref>, and the receiver <ref refid="group___seq_port_1gae8afb5ac8f546461b4bab25454972aeb" kindref="member">SND_SEQ_PORT_CAP_WRITE</ref> and <ref refid="group___seq_port_1ga52ff1c51578166e67936cfb826c966c0" kindref="member">SND_SEQ_PORT_CAP_SUBS_WRITE</ref>, respectively. <programlisting><codeline><highlight class="normal">//<sp/>..in<sp/>the<sp/>third<sp/>application<sp/>(130:0)<sp/>..</highlight></codeline>
<codeline><highlight class="normal">void<sp/>coupling(snd_seq_t<sp/>*seq)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_addr_t<sp/>sender,<sp/>dest;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_t<sp/>*subs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sender.client<sp/>=<sp/>128;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sender.port<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dest.client<sp/>=<sp/>129;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>dest.port<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_alloca(&amp;subs);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_set_sender(subs,<sp/>&amp;sender);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_port_subscribe_set_dest(subs,<sp/>&amp;dest);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_subscribe_port(seq,<sp/>subs);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para></sect2>
</sect1>
<sect1 id="seq_1seq_ex_event">
<title>Event Processing</title>
<sect2 id="seq_1seq_ex_address">
<title>Addressing</title>
<para>Now, two ports are connected by subscription. Then how to send events?</para><para>The subscribed port doesn&apos;t have to know the exact sender address. Instead, there is a special address for subscribers, <ref refid="group___sequencer_1ga383b235d2afbe48704952edfd3a33eed" kindref="member">SND_SEQ_ADDRESS_SUBSCRIBERS</ref>. The sender must set this value as the destination client. Destination port is ignored.</para><para>The other values in source and destination addresses are identical with the normal event record. If the event is scheduled, proper queue and timestamp values must be set.</para><para>There is a convenient function to set the address in an event record. In order to set destination as subscribers, use <ref refid="group___seq_middle_1ga1eb546b3a1a23044d0ba7818731ed6d7" kindref="member">snd_seq_ev_set_subs()</ref>.</para></sect2>
<sect2 id="seq_1Scheduled">
<title>Delivery</title>
<para>If we send an event at the scheduled time <computeroutput>t</computeroutput> (tick) on the queue <computeroutput>Q</computeroutput>, the sender must set both schedule queue and time in the event record. The program appears like this: <programlisting><codeline><highlight class="normal">void<sp/>schedule_event(snd_seq_t<sp/>*seq)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_event_t<sp/>ev;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_clear(&amp;ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_set_source(&amp;ev,<sp/>my_port);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_set_subs(&amp;ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_schedule_tick(&amp;ev,<sp/>Q,<sp/>0,<sp/>t);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...<sp/>//<sp/>set<sp/>event<sp/>type,<sp/>data,<sp/>so<sp/>on..</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_event_output(seq,<sp/>&amp;ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_drain_output(seq);<sp/><sp/>//<sp/>if<sp/>necessary</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> Of course, you can use realtime stamp, too.</para></sect2>
<sect2 id="seq_1seq_ex_direct">
<title>Direct Delivery</title>
<para>If the event is sent immediately without enqueued, the sender doesn&apos;t take care of queue and timestamp. As well as the case above, there is a function to set the direct delivery, <ref refid="group___seq_middle_1gae2674210b5601e8aa3e787c1ddbdcb62" kindref="member">snd_seq_ev_set_direct()</ref>. The program can be more simplified as follows: <programlisting><codeline><highlight class="normal">void<sp/>direct_delivery(snd_seq_t<sp/>*seq)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_event_t<sp/>ev;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_clear(&amp;ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_set_source(&amp;ev,<sp/>port);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_set_subs(&amp;ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_set_direct(&amp;ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>...<sp/>//<sp/>set<sp/>event<sp/>type,<sp/>data,<sp/>so<sp/>on..</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_event_output(seq,<sp/>&amp;ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_drain_output(seq);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> You should flush event soon after output event. Otherwise, the event is enqueued on output queue of ALSA library (not in the kernel!), and will be never processed until this queue becomes full.</para></sect2>
<sect2 id="seq_1seq_ex_filter">
<title>Filter Application</title>
<para>A typical filter program, which receives an event and sends it immediately after some modification, will appear as following: <programlisting><codeline><highlight class="normal">void<sp/>event_filter(snd_seq_t<sp/>*seq,<sp/>snd_seq_event_t<sp/>*ev)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>while<sp/>(snd_seq_event_input(seq,<sp/>&amp;ev)<sp/>&gt;=<sp/>0)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//..<sp/>modify<sp/>input<sp/>event<sp/>..</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_set_source(ev,<sp/>my_port);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_set_subs(ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_ev_set_direct(ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_event_output(seq,<sp/>ev);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>snd_seq_drain_output(seq);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para></sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
