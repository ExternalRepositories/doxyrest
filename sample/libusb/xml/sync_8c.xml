<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="sync_8c" kind="file" language="C++">
    <compoundname>sync.c</compoundname>
    <includes local="no">config.h</includes>
    <includes local="no">errno.h</includes>
    <includes local="no">stdint.h</includes>
    <includes local="no">stdlib.h</includes>
    <includes local="no">string.h</includes>
    <includes local="yes">libusbi.h</includes>
    <incdepgraph>
      <node id="61">
        <label>stdint.h</label>
      </node>
      <node id="62">
        <label>stdlib.h</label>
      </node>
      <node id="60">
        <label>errno.h</label>
      </node>
      <node id="63">
        <label>string.h</label>
      </node>
      <node id="58">
        <label>sync.c</label>
        <link refid="sync_8c"/>
        <childnode refid="59" relation="include">
        </childnode>
        <childnode refid="60" relation="include">
        </childnode>
        <childnode refid="61" relation="include">
        </childnode>
        <childnode refid="62" relation="include">
        </childnode>
        <childnode refid="63" relation="include">
        </childnode>
        <childnode refid="64" relation="include">
        </childnode>
      </node>
      <node id="59">
        <label>config.h</label>
      </node>
      <node id="64">
        <label>libusbi.h</label>
      </node>
    </incdepgraph>
      <sectiondef kind="func">
      <memberdef kind="function" id="sync_8c_1abc33927bb75a9566adcfc5799bd39710" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void sync_transfer_cb</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>sync_transfer_cb</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" line="37" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" bodystart="37" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="sync_8c_1a5774204b7e198e95287d3944dca9c01e" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>static void sync_transfer_wait_for_completion</definition>
        <argsstring>(struct libusb_transfer *transfer)</argsstring>
        <name>sync_transfer_wait_for_completion</name>
        <param>
          <type>struct <ref refid="structlibusb__transfer" kindref="compound">libusb_transfer</ref> *</type>
          <declname>transfer</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" line="45" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" bodystart="45" bodyend="61"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__syncio_1gadb11f7a761bd12fc77a07f4568d56f38" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_control_transfer</definition>
        <argsstring>(libusb_device_handle *dev_handle, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, unsigned char *data, uint16_t wLength, unsigned int timeout)</argsstring>
        <name>libusb_control_transfer</name>
        <param>
          <type><ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>bmRequestType</declname>
        </param>
        <param>
          <type>uint8_t</type>
          <declname>bRequest</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>wValue</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>wIndex</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>uint16_t</type>
          <declname>wLength</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Perform a USB control transfer. </para>        </briefdescription>
        <detaileddescription>
<para>The direction of the transfer is inferred from the bmRequestType field of the setup packet.</para><para>The wValue, wIndex and wLength fields values should be given in host-endian byte order.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a handle for the device to communicate with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bmRequestType</parametername>
</parameternamelist>
<parameterdescription>
<para>the request type field for the setup packet </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bRequest</parametername>
</parameternamelist>
<parameterdescription>
<para>the request field for the setup packet </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wValue</parametername>
</parameternamelist>
<parameterdescription>
<para>the value field for the setup packet </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>the index field for the setup packet </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>a suitably-sized data buffer for either input or output (depending on direction bits within bmRequestType) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>wLength</parametername>
</parameternamelist>
<parameterdescription>
<para>the length field for the setup packet. The data buffer should be at least this size. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout (in millseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0. </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>on success, the number of bytes actually transferred </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_TIMEOUT if the transfer timed out </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_PIPE if the control request was not supported by the device </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if called from event handling context </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_INVALID_PARAM if the transfer size is larger than the operating system and/or hardware can support </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failures </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" line="94" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" bodystart="94" bodyend="164"/>
      </memberdef>
      <memberdef kind="function" id="sync_8c_1a1c8bd359b44bef6782fdf8e4611a11ae" prot="public" static="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>static int do_sync_bulk_transfer</definition>
        <argsstring>(struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *buffer, int length, int *transferred, unsigned int timeout, unsigned char type)</argsstring>
        <name>do_sync_bulk_transfer</name>
        <param>
          <type>struct <ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>buffer</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>transferred</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>type</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" line="166" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" bodystart="166" bodyend="224"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__syncio_1gab8ae853ab492c22d707241dc26c8a805" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_bulk_transfer</definition>
        <argsstring>(struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *transferred, unsigned int timeout)</argsstring>
        <name>libusb_bulk_transfer</name>
        <param>
          <type>struct <ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>transferred</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Perform a USB bulk transfer. </para>        </briefdescription>
        <detaileddescription>
<para>The direction of the transfer is inferred from the direction bits of the endpoint address.</para><para>For bulk reads, the <computeroutput>length</computeroutput> field indicates the maximum length of data you are expecting to receive. If less data arrives than expected, this function will return that data, so be sure to check the <computeroutput>transferred</computeroutput> output parameter.</para><para>You should also check the <computeroutput>transferred</computeroutput> parameter for bulk writes. Not all of the data may have been written.</para><para>Also check <computeroutput>transferred</computeroutput> when dealing with a timeout error code. libusb may have to split your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the timeout may expire after the first few chunks have completed. libusb is careful not to lose any data that may have been transferred; do not assume that timeout conditions indicate a complete lack of I/O.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a handle for the device to communicate with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>the address of a valid endpoint to communicate with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>a suitably-sized data buffer for either input or output (depending on endpoint) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>for bulk writes, the number of bytes from data to be sent. for bulk reads, the maximum number of bytes to receive into the data buffer. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transferred</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the number of bytes actually transferred. Since version 1.0.21 (<ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000105), it is legal to pass a NULL pointer if you do not wish to receive this information. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout (in millseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success (and populates <computeroutput>transferred</computeroutput>) </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_TIMEOUT if the transfer timed out (and populates <computeroutput>transferred</computeroutput>) </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_PIPE if the endpoint halted </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_OVERFLOW if the device offered more data, see <ref refid="libusb_packetoverflow" kindref="compound">Packets and overflows</ref> </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if called from event handling context </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other failures </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" line="269" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" bodystart="269" bodyend="275"/>
      </memberdef>
      <memberdef kind="function" id="group__libusb__syncio_1gac412bda21b7ecf57e4c76877d78e6486" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int libusb_interrupt_transfer</definition>
        <argsstring>(struct libusb_device_handle *dev_handle, unsigned char endpoint, unsigned char *data, int length, int *transferred, unsigned int timeout)</argsstring>
        <name>libusb_interrupt_transfer</name>
        <param>
          <type>struct <ref refid="group__libusb__dev_1ga7df95821d20d27b5597f1d783749d6a4" kindref="member">libusb_device_handle</ref> *</type>
          <declname>dev_handle</declname>
        </param>
        <param>
          <type>unsigned char</type>
          <declname>endpoint</declname>
        </param>
        <param>
          <type>unsigned char *</type>
          <declname>data</declname>
        </param>
        <param>
          <type>int</type>
          <declname>length</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>transferred</declname>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>timeout</declname>
        </param>
        <briefdescription>
<para>Perform a USB interrupt transfer. </para>        </briefdescription>
        <detaileddescription>
<para>The direction of the transfer is inferred from the direction bits of the endpoint address.</para><para>For interrupt reads, the <computeroutput>length</computeroutput> field indicates the maximum length of data you are expecting to receive. If less data arrives than expected, this function will return that data, so be sure to check the <computeroutput>transferred</computeroutput> output parameter.</para><para>You should also check the <computeroutput>transferred</computeroutput> parameter for interrupt writes. Not all of the data may have been written.</para><para>Also check <computeroutput>transferred</computeroutput> when dealing with a timeout error code. libusb may have to split your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the timeout may expire after the first few chunks have completed. libusb is careful not to lose any data that may have been transferred; do not assume that timeout conditions indicate a complete lack of I/O.</para><para>The default endpoint bInterval value is used as the polling interval.</para><para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dev_handle</parametername>
</parameternamelist>
<parameterdescription>
<para>a handle for the device to communicate with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>endpoint</parametername>
</parameternamelist>
<parameterdescription>
<para>the address of a valid endpoint to communicate with </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>data</parametername>
</parameternamelist>
<parameterdescription>
<para>a suitably-sized data buffer for either input or output (depending on endpoint) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>length</parametername>
</parameternamelist>
<parameterdescription>
<para>for bulk writes, the number of bytes from data to be sent. for bulk reads, the maximum number of bytes to receive into the data buffer. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>transferred</parametername>
</parameternamelist>
<parameterdescription>
<para>output location for the number of bytes actually transferred. Since version 1.0.21 (<ref refid="group__libusb__misc_1gaabe4bc36a83358685d36a6c853cbb4de" kindref="member">LIBUSB_API_VERSION</ref> &gt;= 0x01000105), it is legal to pass a NULL pointer if you do not wish to receive this information. </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeout</parametername>
</parameternamelist>
<parameterdescription>
<para>timeout (in millseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>0 on success (and populates <computeroutput>transferred</computeroutput>) </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_TIMEOUT if the transfer timed out </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_PIPE if the endpoint halted </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_OVERFLOW if the device offered more data, see <ref refid="libusb_packetoverflow" kindref="compound">Packets and overflows</ref> </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_NO_DEVICE if the device has been disconnected </para></simplesect>
<simplesect kind="return"><para>LIBUSB_ERROR_BUSY if called from event handling context </para></simplesect>
<simplesect kind="return"><para>another LIBUSB_ERROR code on other error </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" line="321" column="1" bodyfile="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c" bodystart="321" bodyend="327"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/vladimir/Develop/libusb/libusb-1.0.21/libusb/sync.c"/>
  </compounddef>
</doxygen>
